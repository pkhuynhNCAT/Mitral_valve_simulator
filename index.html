<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Mitral Valve Simulator ‚Äî Single File</title>
  <meta name="description" content="Web-based, single-file mitral valve simulator for repair training."/>
  <style>
    :root {
      color-scheme: dark;
      --bg: #0b0f14;
      --panel: #0f1620;
      --ink: #d8e1ea;
      --accent: #4cc9f0;
      --ok: #7ef7c9;
      --warn: #ffd166;
      --err: #ff6b6b;
    }
    html, body { height: 100%; margin: 0; }
    body {
      background: radial-gradient(1200px 800px at 70% 10%, #101826, #0b0f14 55%);
      color: var(--ink);
      font: 14px/1.4 ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
    }
    #app { position: relative; height: 100%; width: 100%; overflow: hidden; }
    canvas { display: block; width: 100%; height: 100%; }

    .hud { position: absolute; inset: 0; pointer-events: none; }
    .panel {
      position: absolute;
      background: color-mix(in oklab, var(--panel) 88%, transparent);
      backdrop-filter: blur(8px) saturate(120%);
      border: 1px solid #1d2735; border-radius: 16px;
      box-shadow: 0 10px 30px rgba(0,0,0,.35);
      color: var(--ink); pointer-events: auto;
    }
    .panel h3 { margin: 0; padding: 10px 12px; font-weight: 600; letter-spacing: .2px; border-bottom: 1px solid #1d2735; }
    .panel .body { padding: 10px 12px; }

    #stats    { position: absolute; top: 12px; left: 12px; min-width: 220px; }
    #controls { position: absolute; top: 12px; right: 12px; min-width: 340px; }
    #toasts   { position: absolute; bottom: 12px; left: 50%; transform: translateX(-50%); display: grid; gap: 10px; }

    .btn { display: inline-flex; align-items: center; gap: 8px; background: #1a2331; padding: 8px 12px; border-radius: 12px; border: 1px solid #253247;
      color: var(--ink); cursor: pointer; user-select: none; text-decoration: none; transition: .15s ease; }
    .btn:hover  { background: #213248; border-color: #2f4461; }
    .btn:active { transform: translateY(1px); }
    .btn[aria-pressed="true"] { outline: 2px solid var(--accent); }

    .kv { display: grid; grid-template-columns: 1fr auto; gap: 4px 12px; align-items: center; }
    .kv .k { opacity: .72; }
    .kv .v { font-variant-numeric: tabular-nums; }

    #error { position: absolute; left: 50%; top: 50%; transform: translate(-50%, -60%); max-width: 720px; background: #141b23; border: 1px solid #2a374c;
      border-left: 6px solid var(--err); padding: 18px 20px; border-radius: 14px; display: none; }
    #error h2 { margin: 0 0 6px; }
    #error pre { background: #0b1118; padding: 10px 12px; border-radius: 10px; overflow-x: auto; }

    footer.disclaimer {
      position: absolute; left: 12px; bottom: 6px; opacity: .55; font-size: 12px; pointer-events: none;
    }
  </style>
</head>
<body>
  <div id="app">
    <canvas id="sim" aria-label="Mitral Valve Simulator canvas"></canvas>
    <div class="hud" aria-live="polite">
      <div id="stats" class="panel" role="group" aria-label="Runtime statistics">
        <h3>Runtime</h3>
        <div class="body kv">
          <div class="k">Renderer</div><div class="v" id="stat-renderer">‚Äî</div>
          <div class="k">FPS</div><div class="v" id="stat-fps">‚Äî</div>
          <div class="k">Frame (ms)</div><div class="v" id="stat-ms">‚Äî</div>
          <div class="k">Sim (ms)</div><div class="v" id="stat-sim">‚Äî</div>
          <div class="k">Draw (ms)</div><div class="v" id="stat-draw">‚Äî</div>
          <div class="k">Substeps</div><div class="v" id="stat-sub">‚Äî</div>
        </div>
      </div>

      <div id="controls" class="panel" role="group" aria-label="Controls">
        <h3>Controls</h3>
        <div class="body" style="display: grid; gap: 10px;">
          <div style="display: flex; gap: 8px; flex-wrap: wrap;">
            <button class="btn" id="btn-pause" aria-pressed="false">‚è∏ Pause (P)</button>
            <button class="btn" id="btn-reset">üîÑ Reset</button>
            <button class="btn" id="btn-full">‚§¢ Fullscreen</button>
          </div>
          <div class="kv">
            <div class="k">Grid</div>
            <div class="v"><input type="checkbox" id="chk-grid" checked aria-label="Toggle grid"></div>
            <div class="k">Bloom</div>
            <div class="v"><input type="checkbox" id="chk-bloom" checked aria-label="Toggle bloom"></div>
          </div>
          <div style="opacity:.85">
            Orbit: L-drag ‚Ä¢ Zoom: Wheel ‚Ä¢ Pan: Shift+L-drag<br/>
            <strong>Instrument:</strong> R-drag move ‚Ä¢ Wheel depth ‚Ä¢ L-click jaw ‚Ä¢ Q/E roll ‚Ä¢ W/S pitch ‚Ä¢ A/D yaw ‚Ä¢ R reset<br/>
            <strong>Hemodynamics:</strong> Adjust Flow (L/min) in the Hemodynamics panel (bottom-right).
          </div>
        </div>
      </div>

      <div id="toasts" aria-live="polite"></div>
      <div id="error" role="alert">
        <h2>Initialization error</h2>
        <div>Sorry ‚Äî the simulator couldn't start. Details:</div>
        <pre id="error-log"></pre>
      </div>
      <footer class="disclaimer">Educational simulator (non-clinical).</footer>
    </div>
  </div>

  <!-- All logic inline as one ES module -->
  <script type="module">
    // External ESM modules
    import * as THREE from 'https://esm.sh/three@0.160.0';
    import { OrbitControls } from 'https://esm.sh/three@0.160.0/examples/jsm/controls/OrbitControls.js';
    import { WebGPURenderer } from 'https://esm.sh/three@0.160.0/examples/jsm/renderers/webgpu/WebGPURenderer.js';
    // =============== Engine Core ===============
    class EventBus extends EventTarget {
      on(type, listener) { this.addEventListener(type, listener); }
      off(type, listener) { this.removeEventListener(type, listener); }
      emit(type, detail = {}) { this.dispatchEvent(new CustomEvent(type, { detail })); }
    }
    class Plugin {
      onInit(engine) {}
      onFixedUpdate(dt) {}
      onBeforeRender(alpha) {}
      onAfterRender() {}
      onDispose() {}
    }
    class Perf {
      constructor(){ this._last = performance.now(); this.fps = 0; this.ms = 0; }
      frameStart(){ this._t0 = performance.now(); }
      frameEnd(){
        const now = performance.now();
        this.ms = now - this._t0;
        const dt = now - this._last; this._last = now;
        this.fps = 1000 / dt;
      }
    }
    class Engine {
      constructor(opts){
        this.canvas = opts.canvas;
        this.fixedHz = opts.fixedHz ?? 120;
        this.dtFixed = 1 / this.fixedHz;
        this.maxSubsteps = 5;
        this.timeScale = 1;
        this.running = false;
        this.paused = false;
        this.eventBus = new EventBus();
        this.perf = new Perf();
        this.perfSim = 0; this.perfDraw = 0; this.lastAlpha = 0;
        this._plugins = [];
        this._accum = 0; this._lastStamp = performance.now();

        this.scene = new THREE.Scene();
        this.scene.background = new THREE.Color('#0c121a');
        this.camera = new THREE.PerspectiveCamera(50, 16/9, 0.05, 200);
        this.camera.position.set(0.85, 0.65, 1.6);

        this.rendererKind = 'WebGL';
        try {
          if (opts.useWebGPU !== false && 'gpu' in navigator) {
            this.renderer = new WebGPURenderer({ canvas: this.canvas, antialias: true });
            this.renderer.init();
            this.renderer.toneMapping = THREE.ACESFilmicToneMapping;
            this.renderer.toneMappingExposure = 1.0;
            this.rendererKind = 'WebGPU';
          } else {
            throw new Error('WebGPU not requested or not available');
          }
        } catch (e) {
          this.renderer = new THREE.WebGLRenderer({ canvas: this.canvas, antialias: true, alpha: true });
          this.renderer.outputColorSpace = THREE.SRGBColorSpace;
          this.renderer.toneMapping = THREE.ACESFilmicToneMapping;
          this.renderer.toneMappingExposure = 1.0;
          this.renderer.shadowMap.enabled = true;
          this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
          try { this.renderer.getContext().getExtension('OES_element_index_uint'); } catch {}
        }

        this.controls = new OrbitControls(this.camera, this.canvas);
        this.controls.enableDamping = true;
        this.controls.dampingFactor = 0.06;
        this.controls.target.set(0, 0.12, 0);

        this._bindResize();
        this._bindInput();
        this.resize();
      }
      addPlugin(p){ this._plugins.push(p); p.onInit?.(this); return p; }
      start(){ if (this.running) return; this.running = true; this._tick(); }
      stop(){ this.running = false; }
      setPaused(v){ this.paused = v; document.getElementById('btn-pause')?.setAttribute('aria-pressed', v ? 'true' : 'false'); }
      resetClock(){ this._accum = 0; this._lastStamp = performance.now(); }
      _tick(){
        if (!this.running) return;
        this.perf.frameStart();
        const now = performance.now();
        let dt = (now - this._lastStamp) / 1000 * this.timeScale;
        this._lastStamp = now;
        dt = Math.min(dt, 0.2);
        this._accum += dt;

        const t0 = performance.now();
        let substeps = 0;
        while (this._accum >= this.dtFixed && substeps < this.maxSubsteps){
          if (!this.paused){
            for (const p of this._plugins) p.onFixedUpdate?.(this.dtFixed);
            this.eventBus.emit('fixedStep', { dt: this.dtFixed });
          }
          this._accum -= this.dtFixed; substeps++;
        }
        this.perfSim = performance.now() - t0;

        const alpha = this._accum / this.dtFixed; this.lastAlpha = alpha;
        for (const p of this._plugins) p.onBeforeRender?.(alpha);

        const d0 = performance.now();
        this.controls.update();
        this.renderer.render(this.scene, this.camera);
        this.perfDraw = performance.now() - d0;

        for (const p of this._plugins) p.onAfterRender?.();
        this.perf.frameEnd();

        const el = (id)=>document.getElementById(id);
        const s = (e, v)=>{ if (e) e.textContent = v; };
        s(el('stat-renderer'), this.rendererKind);
        s(el('stat-fps'), this.perf.fps.toFixed(1));
        s(el('stat-ms'), this.perf.ms.toFixed(2));
        s(el('stat-sim'), this.perfSim.toFixed(2));
        s(el('stat-draw'), this.perfDraw.toFixed(2));
        s(el('stat-sub'), String(substeps));

        requestAnimationFrame(()=>this._tick());
      }
      _bindResize(){ window.addEventListener('resize', ()=>this.resize()); }
      resize(){
        const w = this.canvas.clientWidth; const h = this.canvas.clientHeight;
        const dpr = Math.min(window.devicePixelRatio || 1, 2.0);
        this.renderer.setPixelRatio(dpr);
        this.renderer.setSize(w, h, false);
        this.camera.aspect = w / h; this.camera.updateProjectionMatrix();
      }
      _bindInput(){
        window.addEventListener('keydown', (e)=>{
          if (e.repeat) return;
          if (e.key === 'p' || e.key === 'P'){ this.setPaused(!this.paused); this.toast(this.paused ? 'Paused' : 'Resumed'); }
          if (e.key === 'g' || e.key === 'G'){ this.eventBus.emit('toggleGrid'); }
        });
        const btnPause = document.getElementById('btn-pause');
        const btnReset = document.getElementById('btn-reset');
        const btnFull  = document.getElementById('btn-full');
        const chkGrid  = document.getElementById('chk-grid');
        const chkBloom = document.getElementById('chk-bloom');
        btnPause?.addEventListener('click', ()=>{ this.setPaused(!this.paused); this.toast(this.paused ? 'Paused' : 'Resumed'); });
        btnReset?.addEventListener('click', ()=>{ this.eventBus.emit('reset'); this.resetClock(); this.toast('Scene reset'); });
        btnFull?.addEventListener('click', ()=> document.documentElement.requestFullscreen?.());
        chkGrid?.addEventListener('change', (e)=> this.eventBus.emit('toggleGrid', { value: e.target.checked }));
        chkBloom?.addEventListener('change', (e)=> this.eventBus.emit('toggleBloom', { value: e.target.checked }));
      }
      toast(text, kind='info', ms=1200){
        const host = document.getElementById('toasts'); if (!host) return;
        const el = document.createElement('div');
        el.textContent = text;
        el.style.padding = '10px 14px';
        el.style.borderRadius = '12px';
        el.style.border = '1px solid #2b3a52';
        el.style.background = '#121a26';
        if (kind === 'ok')   el.style.borderLeft = '6px solid var(--ok)';
        if (kind === 'warn') el.style.borderLeft = '6px solid var(--warn)';
        if (kind === 'err')  el.style.borderLeft = '6px solid var(--err)';
        host.appendChild(el);
        setTimeout(()=>{
          el.style.opacity = '0'; el.style.transform = 'translateY(8px)'; el.style.transition = '.4s ease';
          setTimeout(()=> el.remove(), 450);
        }, ms);
      }
      fail(err){
        console.error(err);
        const box = document.getElementById('error');
        const log = document.getElementById('error-log');
        if (box && log){ log.textContent = String(err?.stack || err); box.style.display = 'block'; }
      }
    }

    // =============== Surgical Shell ===============
    class SurgicalShellPlugin extends Plugin {
      onInit(engine){
        this.engine = engine;
        const scene = engine.scene;

        const amb = new THREE.AmbientLight(0x8aa0b7, 0.55);
        scene.add(amb);

        const key = new THREE.DirectionalLight(0xe9eef7, 1.15);
        key.position.set(1.6, 2.2, 1.2);
        key.castShadow = true;
        key.shadow.mapSize.set(2048, 2048);
        key.shadow.camera.near = 0.1; key.shadow.camera.far = 10;
        scene.add(key);

        const fill = new THREE.DirectionalLight(0x6687b0, 0.4);
        fill.position.set(-1.2, 1.4, -1.4);
        scene.add(fill);

        const floorGeo = new THREE.PlaneGeometry(10, 10);
        const floorMat = new THREE.MeshStandardMaterial({ color: 0x0e1722, roughness: 0.9, metalness: 0.0 });
        const floor = new THREE.Mesh(floorGeo, floorMat);
        floor.rotation.x = -Math.PI/2; floor.receiveShadow = true; scene.add(floor);

        this.grid = new THREE.GridHelper(4, 40, 0x27405f, 0x1b2a40);
        this.grid.position.y = 0.001; scene.add(this.grid);

        // Annulus look-alike (visual)
        const annulus = new THREE.TorusGeometry(0.22, 0.01, 24, 96);
        const annulusMat = new THREE.MeshPhysicalMaterial({
          color: 0x4cc9f0, roughness: 0.25, metalness: 0.1, clearcoat: 0.8, transparent: true, opacity: 0.7
        });
        const ring = new THREE.Mesh(annulus, annulusMat);
        ring.rotation.x = Math.PI * 0.5;
        ring.position.y = 0.12;
        ring.castShadow = true; ring.receiveShadow = true;
        scene.add(ring);

        // Visual proxy (not simulated)
        const leafletGeo = new THREE.PlaneGeometry(0.36, 0.26, 50, 30);
        leafletGeo.rotateX(-Math.PI/2);
        for (let i = 0; i < leafletGeo.attributes.position.count; i++) {
          const x = leafletGeo.attributes.position.getX(i);
          const z = leafletGeo.attributes.position.getZ(i);
          const r = Math.sqrt(x*x + z*z);
          const y = 0.14 * Math.exp(-(r*r) / (2 * 0.12*0.12)) - 0.02 * z;
          leafletGeo.attributes.position.setY(i, y);
        }
        leafletGeo.computeVertexNormals();
        const leafletMat = new THREE.MeshPhysicalMaterial({
          color: 0x8fb6ff, roughness: 0.85, metalness: 0.0, transmission: 0.6, thickness: 0.05, transparent: true, opacity: 0.8
        });
        const leaflet = new THREE.Mesh(leafletGeo, leafletMat);
        leaflet.position.y = 0.12;
        leaflet.castShadow = true; leaflet.receiveShadow = true;
        leaflet.userData.isProxy = true;
        scene.add(leaflet);

        engine.eventBus.on('toggleGrid', (e)=>{
          const v = e.detail?.value ?? !this.grid.visible; this.grid.visible = v;
        });
        engine.eventBus.on('reset', ()=>{
          engine.controls.target.set(0, 0.12, 0);
          engine.camera.position.set(0.85, 0.65, 1.6);
        });
      }
    }

    // =============== Posterior Leaflet (XPBD) ===============
    class LeafletXPBDPlugin extends Plugin {
      constructor(opts={}){ 
        super();
        this.opts = Object.assign({
          width: 0.36, height: 0.26, ny: 26, nx: 36, saddleHeight: 0.14, yOffset: 0.12,
          massPerVertex: 0.002, damping: 0.02, substeps: 1, iterations: 10,
          k_par: 2000, k_perp: 600, k_shear: 400, k_area: 3000, k_bend: 200,
          chordCount: 10, chordSlack: 0.002, chordK: 1200, chordTmax: 3.5,
          papillaryLeft:{x:-0.06,y:0.02,z:-0.10}, papillaryRight:{x:0.06,y:0.02,z:-0.10},
          showFibers: true, showStress: true
        }, opts);
      }
      onInit(engine){
        this.engine = engine; this.scene = engine.scene;
        this._buildMesh();
        this.geom = new THREE.BufferGeometry();
        this.posAttr = new THREE.BufferAttribute(this.x, 3);
        this.geom.setAttribute('position', this.posAttr);
        this.geom.setIndex(this.indices);
        this.geom.computeVertexNormals();
        this.colors = new Float32Array(this.vertexCount * 3);
        this.colorAttr = new THREE.BufferAttribute(this.colors, 3);
        this.geom.setAttribute('color', this.colorAttr);
        const mat = new THREE.MeshPhysicalMaterial({
          color: 0x8fb6ff, roughness: 0.8, metalness: 0.0,
          transmission: 0.55, thickness: 0.05, transparent: true, opacity: 0.94,
          vertexColors: true, clearcoat: 0.3, clearcoatRoughness: 0.6
        });
        this.mesh = new THREE.Mesh(this.geom, mat);
        this.mesh.castShadow = true; this.mesh.receiveShadow = true;
        this.scene.add(this.mesh);
        if (this.opts.showFibers) this._buildFiberGizmos();
        this._buildChordLines();
        engine.eventBus.on('reset', ()=> this._resetState());
      }
      _buildMesh(){
        const { nx, ny, width, height, saddleHeight, yOffset } = this.opts;
        const cols = nx + 1, rows = ny + 1; const nVerts = cols * rows; this.vertexCount = nVerts;
        this.x = new Float32Array(nVerts * 3);
        this.xPrev = new Float32Array(nVerts * 3);
        this.xRest = new Float32Array(nVerts * 3);
        this.v = new Float32Array(nVerts * 3);
        this.invMass = new Float32Array(nVerts);
        const idx = (i, j)=> (j * cols + i);
        const toXYZ = (i, j)=>{
          const u = (i / nx - 0.5) * width;
          const v = (j / ny - 0.5) * height;
          const r2 = u*u + v*v;
          const y = saddleHeight * Math.exp(-r2 / (2 * 0.12 * 0.12)) - 0.02 * v + yOffset;
          return [u, y, v];
        };
        for (let j=0; j<=ny; j++){
          for (let i=0; i<=nx; i++){
            const id = idx(i,j), off = id*3;
            const [px, py, pz] = toXYZ(i,j);
            this.x[off]=this.xPrev[off]=this.xRest[off]=px;
            this.x[off+1]=this.xPrev[off+1]=this.xRest[off+1]=py;
            this.x[off+2]=this.xPrev[off+2]=this.xRest[off+2]=pz;
            this.v[off]=this.v[off+1]=this.v[off+2]=0;
            const boundary = (i===0 || i===nx || j===0 || j===ny);
            this.invMass[id] = boundary ? 0 : 1/this.opts.massPerVertex;
          }
        }
        const indices = [];
        for (let j=0; j<ny; j++){
          for (let i=0; i<nx; i++){
            const i0 = idx(i, j), i1 = idx(i+1, j), i2 = idx(i, j+1), i3 = idx(i+1, j+1);
            indices.push(i0, i2, i1); indices.push(i1, i2, i3);
          }
        }
        this.indices = new Uint32Array(indices);
        this._buildConstraints(cols, rows, idx);
        this._buildChords(cols, rows, idx);
      }
      _buildConstraints(cols, rows, idx){
        const { k_par, k_perp, k_shear, k_area, k_bend } = this.opts;
        this.distanceCons = []; this.areaCons = []; this.bendCons = [];
        const addDist = (a, b, k)=>{
          const L0 = this._restLengthFromRest(a, b);
          this.distanceCons.push({ i:a, j:b, L0, alpha: 1/(k+1e-9), lambda: 0 });
        };
        for (let r=0; r<rows; r++){
          for (let c=0; c<cols; c++){
            const id = (r*cols + c);
            if (c+1 < cols) addDist(id, id+1,       k_par);
            if (r+1 < rows) addDist(id, id+cols,    k_perp);
            if (c+1 < cols && r+1 < rows) addDist(id, id+cols+1, k_shear);
            if (c+1 < cols && r-1 >= 0)   addDist(id, id-cols+1, k_shear);
            if (c+2 < cols) addDist(id, id+2,         k_bend);
            if (r+2 < rows) addDist(id, id+2*cols,    k_bend);
          }
        }
        const triA0 = (i0, i1, i2)=> this._triAreaFromRest(i0, i1, i2);
        for (let r=0; r<rows-1; r++){
          for (let c=0; c<cols-1; c++){
            const i0 = r*cols + c, i1 = r*cols + c+1, i2 = (r+1)*cols + c, i3 = (r+1)*cols + c+1;
            this.areaCons.push({ i0, i1: i2, i2: i1, A0: triA0(i0, i2, i1), alpha: 1/(k_area+1e-9), lambda: 0 });
            this.areaCons.push({ i0: i1, i1: i2, i2: i3, A0: triA0(i1, i2, i3), alpha: 1/(k_area+1e-9), lambda: 0 });
          }
        }
      }
      _buildChords(cols, rows, idx){
        const { chordCount, chordSlack, chordK, chordTmax, papillaryLeft, papillaryRight } = this.opts;
        this.chords = []; const picks = [];
        const jStart = Math.floor(rows*0.55), jEnd = Math.floor(rows*0.85);
        for (let k=0; k<chordCount; k++){
          const j = Math.floor(jStart + (k/(chordCount-1)) * (jEnd - jStart));
          const t = (k/(chordCount-1))*2 - 1;
          const i = Math.floor((cols/2) + t * (cols/2-2));
          picks.push(idx(i,j));
        }
        const toArr = (o)=> [o.x, o.y, o.z];
        const leftAnchor = toArr(papillaryLeft), rightAnchor = toArr(papillaryRight);
        picks.forEach((vi, k)=>{
          const anchor = (k < chordCount/2) ? leftAnchor : rightAnchor;
          const L0 = this._restLengthToAnchorFromRest(vi, anchor);
          this.chords.push({ i: vi, anchor, L0, slack: chordSlack, k: chordK, Tmax: chordTmax, lambda: 0, failed: false, tension: 0 });
        });
      }
      _buildFiberGizmos(){
        const { nx, ny } = this.opts; const cols = nx+1, rows = ny+1;
        const verts = [];
        for (let j=0; j<rows; j+=Math.max(1, Math.floor(rows/12))){
          for (let i=0; i<cols; i+=Math.max(1, Math.floor(cols/12))){
            const id = j*cols+i, off = id*3;
            const p = new THREE.Vector3(this.x[off], this.x[off+1], this.x[off+2]);
            const q = new THREE.Vector3(this.x[off]+0.02, this.x[off+1], this.x[off+2]);
            verts.push(p.x,p.y,p.z, q.x,q.y,q.z);
          }
        }
        const geo = new THREE.BufferGeometry();
        geo.setAttribute('position', new THREE.Float32BufferAttribute(new Float32Array(verts), 3));
        const mat = new THREE.LineBasicMaterial({ color: 0x4cc9f0, transparent: true, opacity: 0.7 });
        this.fiberLines = new THREE.LineSegments(geo, mat);
        this.scene.add(this.fiberLines);
      }
      _buildChordLines(){
        const verts = [];
        for (const ch of this.chords){
          const off = ch.i*3;
          verts.push(this.x[off], this.x[off+1], this.x[off+2], ch.anchor[0], ch.anchor[1], ch.anchor[2]);
        }
        const geo = new THREE.BufferGeometry();
        geo.setAttribute('position', new THREE.Float32BufferAttribute(new Float32Array(verts), 3));
        const mat = new THREE.LineBasicMaterial({ color: 0xffe08a, transparent: true, opacity: 0.9 });
        this.chordLines = new THREE.LineSegments(geo, mat);
        this.scene.add(this.chordLines);
      }
      _updateChordLines(){
        const attr = this.chordLines.geometry.getAttribute('position'); let k = 0;
        for (const ch of this.chords){
          const off = ch.i*3;
          attr.array[k++] = this.x[off]; attr.array[k++] = this.x[off+1]; attr.array[k++] = this.x[off+2];
          attr.array[k++] = ch.anchor[0]; attr.array[k++] = ch.anchor[1]; attr.array[k++] = ch.anchor[2];
        }
        attr.needsUpdate = true;
      }
      _restLengthFromRest(i, j){
        const ix=i*3, jx=j*3; const dx=this.xRest[ix]-this.xRest[jx], dy=this.xRest[ix+1]-this.xRest[jx+1], dz=this.xRest[ix+2]-this.xRest[jx+2];
        return Math.hypot(dx, dy, dz);
      }
      _restLengthToAnchorFromRest(i, anchor){
        const ix = i*3; const dx=this.xRest[ix]-anchor[0], dy=this.xRest[ix+1]-anchor[1], dz=this.xRest[ix+2]-anchor[2];
        return Math.hypot(dx, dy, dz);
      }
      _triAreaFromRest(i0,i1,i2){
        const a0=i0*3,a1=i1*3,a2=i2*3;
        const x0=this.xRest[a0],y0=this.xRest[a0+1],z0=this.xRest[a0+2];
        const x1=this.xRest[a1],y1=this.xRest[a1+1],z1=this.xRest[a1+2];
        const x2=this.xRest[a2],y2=this.xRest[a2+1],z2=this.xRest[a2+2];
        const ux=x1-x0, uy=y1-y0, uz=z1-z0;
        const vx=x2-x0, vy=y2-y0, vz=z2-z0;
        const cx=uy*vz-uz*vy, cy=uz*vx-ux*vz, cz=ux*vy-uy*vx;
        return 0.5*Math.hypot(cx,cy,cz);
      }
      _solveDistance(c, invMass, x, dt){
        const ix=c.i*3, jx=c.j*3;
        const dx=x[ix]-x[jx], dy=x[ix+1]-x[jx+1], dz=x[ix+2]-x[jx+2];
        const len=Math.hypot(dx,dy,dz); if (len<1e-7) return;
        const C=len-c.L0; const nx=dx/len, ny=dy/len, nz=dz/len;
        const wi=invMass[c.i], wj=invMass[c.j], w=wi+wj; const alpha=c.alpha/(dt*dt);
        const denom=w+alpha; if (denom<1e-9) return;
        const dlambda=-(C+alpha*(c.lambda||0))/denom; c.lambda=(c.lambda||0)+dlambda;
        const dxi=wi*dlambda, dxj=-wj*dlambda;
        x[ix]+=dxi*nx; x[ix+1]+=dxi*ny; x[ix+2]+=dxi*nz;
        x[jx]+=dxj*nx; x[jx+1]+=dxj*ny; x[jx+2]+=dxj*nz;
      }
      _solveArea(c, invMass, x, dt){
        const i0=c.i0,i1=c.i1,i2=c.i2; const a0=i0*3,a1=i1*3,a2=i2*3;
        const x0=new THREE.Vector3(x[a0],x[a0+1],x[a0+2]);
        const x1=new THREE.Vector3(x[a1],x[a1+1],x[a1+2]);
        const x2=new THREE.Vector3(x[a2],x[a2+1],x[a2+2]);
        const e1=new THREE.Vector3().subVectors(x1,x0);
        const e2=new THREE.Vector3().subVectors(x2,x0);
        const n=new THREE.Vector3().crossVectors(e1,e2);
        const len=n.length(); if (len<1e-10) return;
        const area=0.5*len; const nHat=n.multiplyScalar(1/len);
        const g0=new THREE.Vector3().crossVectors(new THREE.Vector3().subVectors(x2,x1), nHat).multiplyScalar(0.5);
        const g1=new THREE.Vector3().crossVectors(nHat, new THREE.Vector3().subVectors(x2,x0)).multiplyScalar(0.5);
        const g2=new THREE.Vector3().crossVectors(new THREE.Vector3().subVectors(x1,x0), nHat).multiplyScalar(0.5);
        const wi=invMass[i0], wj=invMass[i1], wk=invMass[i2];
        const w=wi*g0.lengthSq()+wj*g1.lengthSq()+wk*g2.lengthSq(); const alpha=c.alpha/(dt*dt);
        const C=area-c.A0; const denom=w+alpha; if (denom<1e-12) return;
        const dlambda=-(C+alpha*(c.lambda||0))/denom; c.lambda=(c.lambda||0)+dlambda;
        x[a0]+=wi*dlambda*g0.x; x[a0+1]+=wi*dlambda*g0.y; x[a0+2]+=wi*dlambda*g0.z;
        x[a1]+=wj*dlambda*g1.x; x[a1+1]+=wj*dlambda*g1.y; x[a1+2]+=wj*dlambda*g1.z;
        x[a2]+=wk*dlambda*g2.x; x[a2+1]+=wk*dlambda*g2.y; x[a2+2]+=wk*dlambda*g2.z;
      }
      _solveChord(ch, invMass, x, dt){
        if (ch.failed) return;
        const i = ch.i, ix = i*3;
        const ax = ch.anchor[0], ay = ch.anchor[1], az = ch.anchor[2];
        const dx = x[ix]-ax, dy = x[ix+1]-ay, dz = x[ix+2]-az;
        const len = Math.hypot(dx, dy, dz); if (len<1e-7) return;
        const L0 = ch.L0 + ch.slack; const C = len - L0;
        const nx=dx/len, ny=dy/len, nz=dz/len;
        const w = invMass[i]; const alpha=(1/(ch.k+1e-9))/(dt*dt); const denom=w+alpha;
        const dlambda=-(C+alpha*(ch.lambda||0))/(denom||1e-9); ch.lambda=(ch.lambda||0)+dlambda;
        const dxi=w*dlambda; x[ix]+=dxi*nx; x[ix+1]+=dxi*ny; x[ix+2]+=dxi*nz;
        const ext = Math.max(0, len - ch.L0); ch.tension = ch.k * ext;
        if (ch.tension > ch.Tmax) ch.failed = true;
      }
      _resetState(){
        this.v.fill(0);
        for (const c of this.distanceCons) c.lambda = 0;
        for (const c of this.areaCons)     c.lambda = 0;
        for (const c of this.bendCons)     c.lambda = 0;
        for (const ch of this.chords){ ch.lambda = 0; ch.failed = false; ch.tension = 0; }
      }
      onFixedUpdate(dt){
        const sub = Math.max(1, this.opts.substeps|0); const h = dt / sub;
        for (let s=0; s<sub; s++) this._step(h);
      }
      onBeforeRender(){
        this.posAttr.needsUpdate = true; this.geom.computeVertexNormals();
        if (this.fiberLines) this._updateFiberLines();
        if (this.chordLines) this._updateChordLines();
        if (this.opts.showStress){ this._updateColors(); this.colorAttr.needsUpdate = true; }
      }
      _step(dt){
        const n=this.vertexCount, invMass=this.invMass, x=this.x, v=this.v, xPrev=this.xPrev, damping=this.opts.damping;
        const gx=0, gy=-0.2, gz=0;
        for (let i=0; i<n; i++){
          const off=i*3;
          if (invMass[i]===0){ xPrev[off]=x[off]; xPrev[off+1]=x[off+1]; xPrev[off+2]=x[off+2]; v[off]=v[off+1]=v[off+2]=0; continue; }
          v[off]+=dt*gx; v[off+1]+=dt*gy; v[off+2]+=dt*gz;
          xPrev[off]=x[off]; xPrev[off+1]=x[off+1]; xPrev[off+2]=x[off+2];
          x[off]+=dt*v[off]; x[off+1]+=dt*v[off+1]; x[off+2]+=dt*v[off+2];
        }
        for (let iter=0; iter<this.opts.iterations; iter++){
          for (const c of this.distanceCons) this._solveDistance(c, invMass, x, dt);
          for (const c of this.bendCons)     this._solveDistance(c, invMass, x, dt);
          for (const c of this.areaCons)     this._solveArea(c, invMass, x, dt);
          for (const ch of this.chords)      this._solveChord(ch, invMass, x, dt);
        }
        for (let i=0; i<n; i++){
          const off=i*3;
          const vx=(x[off]-xPrev[off])/dt, vy=(x[off+1]-xPrev[off+1])/dt, vz=(x[off+2]-xPrev[off+2])/dt;
          v[off]=vx*(1-damping); v[off+1]=vy*(1-damping); v[off+2]=vz*(1-damping);
        }
      }
      _updateColors(){
        const cols=this.opts.nx+1, rows=this.opts.ny+1, n=this.vertexCount;
        const acc=new Float32Array(n), cnt=new Uint16Array(n);
        const idx=(i,j)=> j*cols+i;
        const L=(a,b)=>{ const ax=a*3,bx=b*3; const dx=this.x[ax]-this.x[bx],dy=this.x[ax+1]-this.x[bx+1],dz=this.x[ax+2]-this.x[bx+2]; return Math.hypot(dx,dy,dz); };
        const L0=(a,b)=> this._restLengthFromRest(a,b);
        for (let j=0; j<rows; j++){
          for (let i=0; i<cols; i++){
            const id=idx(i,j);
            if (i+1<cols){ const n1=idx(i+1,j); const s=Math.abs((L(id,n1)-L0(id,n1))/L0(id,n1)); acc[id]+=s; cnt[id]++; acc[n1]+=s; cnt[n1]++; }
            if (j+1<rows){ const n2=idx(i,j+1); const s=Math.abs((L(id,n2)-L0(id,n2))/L0(id,n2)); acc[id]+=s; cnt[id]++; acc[n2]+=s; cnt[n2]++; }
          }
        }
        let maxS=1e-6; for (let i=0;i<n;i++){ if (cnt[i]>0){ acc[i]/=cnt[i]; if (acc[i]>maxS) maxS=acc[i]; } }
        for (let i=0;i<n;i++){
          const s=Math.min(1,(acc[i]/maxS));
          const r=Math.min(1, Math.max(0, 2*s - 0.2));
          const g=Math.min(1, Math.max(0, 1.2 - Math.abs(2*s - 1.0)));
          const b=Math.min(1, Math.max(0, 1.2 - 2*s));
          this.colors[i*3]=r; this.colors[i*3+1]=g; this.colors[i*3+2]=b;
        }
      }
      _updateFiberLines(){
        const pos=this.fiberLines.geometry.getAttribute('position');
        for (let i=0; i<pos.array.length; i+=6){
          const x0=pos.array[i], y0=pos.array[i+1], z0=pos.array[i+2];
          const x1=x0+0.02, y1=y0, z1=z0;
          pos.array[i]=x0; pos.array[i+1]=y0; pos.array[i+2]=z0;
          pos.array[i+3]=x1; pos.array[i+4]=y1; pos.array[i+5]=z1;
        }
        pos.needsUpdate = true;
      }
    }

    // =============== Instrument: Needle Driver (both leaflets) ===============
    class NeedleDriverPlugin extends Plugin {
      constructor(opts = {}) {
        super();
        this.opts = Object.assign({
          shaftLength: 0.35, shaftRadius: 0.004,
          jawLength: 0.018, jawWidth: 0.006, jawOpenDeg: 22,
          tipContactRadius: 0.006, grabRadius: 0.006,
          friction: 0.35, moveSpeed: 1.0, rotateSpeed: 0.015
        }, opts);
      }
      onInit(engine) {
        this.engine = engine; this.scene = engine.scene; this.camera = engine.camera; this.canvas = engine.canvas;
        this._refreshLeaflets();
        this._buildInstrument();
        this.depth = 0.8; this.offsetX = 0; this.offsetY = 0;
        this.roll = 0; this.pitch = 0; this.yaw = 0;
        this.jawOpen = true; this.grab = { pluginIdx: -1, vert: -1 };
        this._updatePose(); this._bindInput();
        engine.eventBus.on('reset', () => {
          this.depth = 0.8; this.offsetX = 0; this.offsetY = 0;
          this.roll = this.pitch = this.yaw = 0; this.jawOpen = true; this.grab = { pluginIdx: -1, vert: -1 };
          this._updatePose(true);
        });
      }
      _refreshLeaflets(){
        this.leaflets = this.engine._plugins.filter(p => p && p.mesh && /Leaflet/i.test(p.constructor.name));
      }
      _buildInstrument() {
        const g = new THREE.Group(); g.name = 'NeedleDriver';
        const shaftGeo = new THREE.CylinderGeometry(this.opts.shaftRadius, this.opts.shaftRadius, this.opts.shaftLength, 24, 1, true);
        const metal = new THREE.MeshPhysicalMaterial({ color: 0xcad3df, roughness: 0.25, metalness: 0.8, clearcoat: 0.5 });
        const shaft = new THREE.Mesh(shaftGeo, metal);
        shaft.rotation.x = Math.PI/2; shaft.castShadow = true; shaft.receiveShadow = true;
        const jawGeo = new THREE.BoxGeometry(this.opts.jawWidth, this.opts.jawWidth*0.6, this.opts.jawLength);
        const jawMat = new THREE.MeshPhysicalMaterial({ color: 0xcfd9e6, roughness: 0.3, metalness: 0.6, clearcoat: 0.3 });
        const jawL = new THREE.Mesh(jawGeo, jawMat); const jawR = new THREE.Mesh(jawGeo, jawMat);
        const halfL = this.opts.shaftLength/2;
        jawL.position.set(-this.opts.jawWidth*0.5, 0, -halfL - this.opts.jawLength*0.5);
        jawR.position.set( this.opts.jawWidth*0.5, 0, -halfL - this.opts.jawLength*0.5);
        jawL.geometry.translate(0, 0, -this.opts.jawLength*0.5);
        jawR.geometry.translate(0, 0, -this.opts.jawLength*0.5);
        const tipSphere = new THREE.Mesh(
          new THREE.SphereGeometry(this.opts.tipContactRadius*0.5, 16, 12),
          new THREE.MeshStandardMaterial({ color: 0xffaf8f, emissive: 0x111111, roughness: 0.5, metalness: 0.2 })
        );
        tipSphere.position.set(0, 0, -halfL - this.opts.jawLength); tipSphere.castShadow = true;
        g.add(shaft, jawL, jawR, tipSphere);
        this.group = g; this.shaft = shaft; this.jawL = jawL; this.jawR = jawR; this.tipViz = tipSphere;
        this.scene.add(g);
      }
      _bindInput() {
        this.canvas.addEventListener('contextmenu', (e) => e.preventDefault());
        let dragging = false;
        this.canvas.addEventListener('mousedown', (e) => { if (e.button === 2) dragging = true; if (e.button === 0) this._toggleJaw(); });
        window.addEventListener('mouseup', () => dragging = false);
        window.addEventListener('mousemove', (e) => { if (!dragging) return; this.offsetX += e.movementX * this.opts.moveSpeed; this.offsetY += e.movementY * this.opts.moveSpeed; this._updatePose(); });
        this.canvas.addEventListener('wheel', (e) => {
          e.preventDefault(); const delta = Math.sign(e.deltaY);
          this.depth *= (1 + delta * 0.08); this.depth = Math.max(0.2, Math.min(2.5, this.depth)); this._updatePose();
        }, { passive: false });
        window.addEventListener('keydown', (e) => {
          if (e.repeat) return;
          if (e.key === 'q' || e.key === 'Q') this.roll -= this.opts.rotateSpeed;
          if (e.key === 'e' || e.key === 'E') this.roll += this.opts.rotateSpeed;
          if (e.key === 'w' || e.key === 'W') this.pitch += this.opts.rotateSpeed;
          if (e.key === 's' || e.key === 'S') this.pitch -= this.opts.rotateSpeed;
          if (e.key === 'a' || e.key === 'A') this.yaw   -= this.opts.rotateSpeed;
          if (e.key === 'd' || e.key === 'D') this.yaw   += this.opts.rotateSpeed;
          if (e.key === 'f' || e.key === 'F') this._toggleJaw();
          if (e.key === 'r' || e.key === 'R') { this.depth = 0.8; this.offsetX = 0; this.offsetY = 0; this.roll = this.pitch = this.yaw = 0; this.jawOpen = true; this.grab = { pluginIdx: -1, vert: -1 }; }
          this._updatePose();
        });
      }
      _toggleJaw(){ this.jawOpen = !this.jawOpen; if (!this.jawOpen) this._tryAutoGrab(); else this.grab = { pluginIdx: -1, vert: -1 }; }
      _tipWorld(){ const local = new THREE.Vector3(0, 0, -this.opts.shaftLength*0.5 - this.opts.jawLength); return this.group.localToWorld(local.clone()); }
      _tryAutoGrab(){
        this._refreshLeaflets();
        const tip = this._tipWorld();
        let best = { d: 1e9, pluginIdx: -1, vert: -1 };
        this.leaflets.forEach((L, idx) => {
          const n = L.vertexCount, x = L.x;
          for (let i=0;i<n;i++){
            if (L.invMass[i] === 0) continue;
            const off=i*3; const dx=x[off]-tip.x, dy=x[off+1]-tip.y, dz=x[off+2]-tip.z;
            const d=Math.hypot(dx,dy,dz); if (d < this.opts.grabRadius && d < best.d){ best = { d, pluginIdx: idx, vert: i }; }
          }
        });
        this.grab = best;
        if (best.pluginIdx >= 0) this.engine.toast('Vertex grabbed', 'ok'); else this.engine.toast('No tissue under jaws', 'warn');
      }
      _updatePose(force=false) {
        const cam=this.camera, h=this.canvas.clientHeight; const fov=cam.fov*Math.PI/180;
        const worldPerPixel=(2*this.depth*Math.tan(fov/2))/h;
        const forward=new THREE.Vector3(0,0,-1).applyQuaternion(cam.quaternion);
        const right=new THREE.Vector3(1,0,0).applyQuaternion(cam.quaternion);
        const up=new THREE.Vector3(0,1,0).applyQuaternion(cam.quaternion);
        const pos=new THREE.Vector3().copy(cam.position)
          .add(forward.clone().multiplyScalar(this.depth))
          .add(right.clone().multiplyScalar(this.offsetX*worldPerPixel))
          .add(up.clone().multiplyScalar(-this.offsetY*worldPerPixel));
        const baseQ=new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0,0,-1), forward.clone().negate());
        const qYaw=new THREE.Quaternion().setFromAxisAngle(up, this.yaw);
        const qPitch=new THREE.Quaternion().setFromAxisAngle(right, this.pitch);
        const qRoll=new THREE.Quaternion().setFromAxisAngle(forward, this.roll);
        const q=baseQ.clone().multiply(qYaw).multiply(qPitch).multiply(qRoll);
        this.group.position.copy(pos); this.group.quaternion.copy(q);
        const a=THREE.MathUtils.degToRad(this.opts.jawOpenDeg)*(this.jawOpen?1:0.05);
        this.jawL.rotation.y=a; this.jawR.rotation.y=-a;
        if (force) this.group.updateMatrixWorld(true);
      }
      onFixedUpdate(dt) {
        this._refreshLeaflets();
        const tip = this._tipWorld();
        const R2 = this.opts.tipContactRadius * this.opts.tipContactRadius;
        const friction = this.opts.friction;

        // Grabbed vertex follows tip
        if (!this.jawOpen && this.grab.pluginIdx >= 0) {
          const L = this.leaflets[this.grab.pluginIdx];
          if (L && L.invMass[this.grab.vert] > 0) {
            const off = this.grab.vert*3; L.x[off]=tip.x; L.x[off+1]=tip.y; L.x[off+2]=tip.z; L.v[off]=L.v[off+1]=L.v[off+2]=0;
          }
        }
        // Contact on all leaflets
        this.leaflets.forEach(L=>{
          const n=L.vertexCount, x=L.x, v=L.v, inv=L.invMass;
          for (let i=0;i<n;i++){
            if (inv[i]===0) continue;
            const off=i*3;
            const dx=x[off]-tip.x, dy=x[off+1]-tip.y, dz=x[off+2]-tip.z;
            const d2=dx*dx+dy*dy+dz*dz; if (d2<R2){
              const d=Math.sqrt(Math.max(d2,1e-9)), nx=dx/d, ny=dy/d, nz=dz/d, pen=(Math.sqrt(R2)-d), k=0.6;
              x[off]+=k*pen*nx; x[off+1]+=k*pen*ny; x[off+2]+=k*pen*nz;
              const vx=v[off], vy=v[off+1], vz=v[off+2]; const vn=vx*nx+vy*ny+vz*nz;
              const vnx=vn*nx, vny=vn*ny, vnz=vn*nz; const vtx=vx-vnx, vty=vy-vny, vtz=vz-vnz;
              v[off]=vnx+(1-friction)*vtx; v[off+1]=vny+(1-friction)*vty; v[off+2]=vnz+(1-friction)*vtz;
            }
          }
        });
      }
      onBeforeRender(){ this.group.updateMatrixWorld(); }
    }

    // =============== Anterior Leaflet (XPBD) + Coaptation ===============
    class AnteriorLeafletXPBDPlugin extends Plugin {
      constructor(opts={}){ 
        super();
        this.opts = Object.assign({
          width:0.36, height:0.26, ny:26, nx:36, saddleHeight:0.16, yOffset:0.12,
          massPerVertex:0.002, damping:0.02, substeps:1, iterations:10,
          k_par:2400, k_perp:700, k_shear:450, k_area:3200, k_bend:250,
          chordCount:8, chordSlack:0.002, chordK:1300, chordTmax:4.0,
          papillaryLeft:{x:-0.055,y:0.025,z:-0.115}, papillaryRight:{x:0.055,y:0.025,z:-0.115},
          gapTarget:0.0008, gapBias:0.0, color:0xf0b4a1, showFibers:true, showStress:true
        }, opts);
      }
      onInit(engine){
        this.engine=engine; this.scene=engine.scene;
        this.post = engine._plugins.find(p => p && p.constructor && p.constructor.name === 'LeafletXPBDPlugin');
        if (!this.post) console.warn('[AnteriorLeaflet] Posterior not found ‚Äî coaptation disabled.');
        this._buildMesh();
        this.geom=new THREE.BufferGeometry();
        this.posAttr=new THREE.BufferAttribute(this.x,3);
        this.geom.setAttribute('position', this.posAttr);
        this.geom.setIndex(this.indices); this.geom.computeVertexNormals();
        this.colors=new Float32Array(this.vertexCount*3);
        this.colorAttr=new THREE.BufferAttribute(this.colors,3);
        this.geom.setAttribute('color', this.colorAttr);
        const mat=new THREE.MeshPhysicalMaterial({
          color:this.opts.color, roughness:0.78, metalness:0.05, transmission:0.55, thickness:0.05, transparent:true, opacity:0.95,
          vertexColors:true, clearcoat:0.3, clearcoatRoughness:0.6
        });
        this.mesh=new THREE.Mesh(this.geom, mat); this.mesh.castShadow=true; this.mesh.receiveShadow=true; this.scene.add(this.mesh);
        if (this.opts.showFibers) this._buildFiberGizmos(); this._buildChordLines();
        engine.eventBus.on('reset', ()=> this._resetState());
      }
      _buildMesh(){
        const { nx, ny, width, height, saddleHeight, yOffset } = this.opts;
        const cols=nx+1, rows=ny+1, nVerts=cols*rows; this.vertexCount=nVerts;
        this.x=new Float32Array(nVerts*3); this.xPrev=new Float32Array(nVerts*3); this.xRest=new Float32Array(nVerts*3);
        this.v=new Float32Array(nVerts*3); this.invMass=new Float32Array(nVerts);
        const idx=(i,j)=> j*cols+i;
        const toXYZ=(i,j)=>{
          const u=(i/nx-0.5)*width; const v=(j/ny-0.5)*height;
          const r2=u*u+v*v; const tilt=-0.028*v; const y=saddleHeight*Math.exp(-r2/(2*0.12*0.12))+tilt+yOffset;
          return [u,y,v];
        };
        for (let j=0;j<=ny;j++){
          for (let i=0;i<=nx;i++){
            const id=idx(i,j), off=id*3; const [px,py,pz]=toXYZ(i,j);
            this.x[off]=this.xPrev[off]=this.xRest[off]=px; this.x[off+1]=this.xPrev[off+1]=this.xRest[off+1]=py; this.x[off+2]=this.xPrev[off+2]=this.xRest[off+2]=pz;
            this.v[off]=this.v[off+1]=this.v[off+2]=0; const boundary=(i===0||i===nx||j===0||j===ny); this.invMass[id]=boundary?0:1/this.opts.massPerVertex;
          }
        }
        const indices=[]; for (let j=0;j<ny;j++){ for (let i=0;i<nx;i++){ const i0=idx(i,j),i1=idx(i+1,j),i2=idx(i,j+1),i3=idx(i+1,j+1); indices.push(i0,i2,i1); indices.push(i1,i2,i3); } }
        this.indices=new Uint32Array(indices);
        this._buildConstraints(cols, rows, idx); this._buildChords(cols, rows, idx);
      }
      _buildConstraints(cols, rows, idx){
        const { k_par, k_perp, k_shear, k_area, k_bend } = this.opts;
        this.distanceCons=[]; this.areaCons=[]; this.bendCons=[];
        const addDist=(a,b,k)=>{ const L0=this._restLengthFromRest(a,b); this.distanceCons.push({i:a,j:b,L0,alpha:1/(k+1e-9),lambda:0}); };
        for (let r=0;r<rows;r++){
          for (let c=0;c<cols;c++){
            const id=r*cols+c;
            if (c+1<cols) addDist(id, id+1,       k_par);
            if (r+1<rows) addDist(id, id+cols,    k_perp);
            if (c+1<cols&&r+1<rows) addDist(id, id+cols+1, k_shear);
            if (c+1<cols&&r-1>=0)   addDist(id, id-cols+1, k_shear);
            if (c+2<cols) addDist(id, id+2,         k_bend);
            if (r+2<rows) addDist(id, id+2*cols,    k_bend);
          }
        }
        const triA0=(i0,i1,i2)=> this._triAreaFromRest(i0,i1,i2);
        for (let r=0;r<rows-1;r++){
          for (let c=0;c<cols-1;c++){
            const i0=r*cols+c, i1=r*cols+c+1, i2=(r+1)*cols+c, i3=(r+1)*cols+c+1;
            this.areaCons.push({ i0, i1: i2, i2: i1, A0: triA0(i0, i2, i1), alpha: 1/(k_area+1e-9), lambda: 0 });
            this.areaCons.push({ i0: i1, i1: i2, i2: i3, A0: triA0(i1, i2, i3), alpha: 1/(k_area+1e-9), lambda: 0 });
          }
        }
      }
      _buildChords(cols, rows, idx){
        const { chordCount, chordSlack, chordK, chordTmax, papillaryLeft, papillaryRight } = this.opts;
        this.chords=[]; const picks=[]; const jStart=Math.floor(rows*0.25), jEnd=Math.floor(rows*0.5);
        for (let k=0;k<chordCount;k++){
          const j=Math.floor(jStart+(k/(chordCount-1))*(jEnd-jStart));
          const t=(k/(chordCount-1))*2-1; const i=Math.floor((cols/2)+t*(cols/2-3)); picks.push(idx(i,j));
        }
        const toArr=o=>[o.x,o.y,o.z]; const left=toArr(papillaryLeft), right=toArr(papillaryRight);
        picks.forEach((vi,k)=>{ const anchor=(k<chordCount/2)?left:right; const L0=this._restLengthToAnchorFromRest(vi, anchor);
          this.chords.push({ i:vi, anchor, L0, slack:chordSlack, k:chordK, Tmax:chordTmax, lambda:0, failed:false, tension:0 }); });
      }
      _buildFiberGizmos(){
        const { nx, ny } = this.opts; const cols=nx+1, rows=ny+1; const verts=[];
        for (let j=0;j<rows;j+=Math.max(1,Math.floor(rows/12))){
          for (let i=0;i<cols;i+=Math.max(1,Math.floor(cols/12))){
            const id=j*cols+i, off=id*3; const p=new THREE.Vector3(this.x[off],this.x[off+1],this.x[off+2]);
            const q=new THREE.Vector3(this.x[off]+0.02,this.x[off+1],this.x[off+2]); verts.push(p.x,p.y,p.z, q.x,q.y,q.z);
          }
        }
        const geo=new THREE.BufferGeometry(); geo.setAttribute('position', new THREE.Float32BufferAttribute(new Float32Array(verts),3));
        const mat=new THREE.LineBasicMaterial({ color:0xf7a289, transparent:true, opacity:0.7 });
        this.fiberLines=new THREE.LineSegments(geo, mat); this.scene.add(this.fiberLines);
      }
      _buildChordLines(){
        const verts=[]; for (const ch of this.chords){ const off=ch.i*3; verts.push(this.x[off],this.x[off+1],this.x[off+2], ch.anchor[0],ch.anchor[1],ch.anchor[2]); }
        const geo=new THREE.BufferGeometry(); geo.setAttribute('position', new THREE.Float32BufferAttribute(new Float32Array(verts),3));
        const mat=new THREE.LineBasicMaterial({ color:0xffd39a, transparent:true, opacity:0.85 }); this.chordLines=new THREE.LineSegments(geo,mat); this.scene.add(this.chordLines);
      }
      _updateChordLines(){
        const attr=this.chordLines.geometry.getAttribute('position'); let k=0;
        for (const ch of this.chords){ const off=ch.i*3; attr.array[k++]=this.x[off]; attr.array[k++]=this.x[off+1]; attr.array[k++]=this.x[off+2]; attr.array[k++]=ch.anchor[0]; attr.array[k++]=ch.anchor[1]; attr.array[k++]=ch.anchor[2]; }
        attr.needsUpdate=true;
      }
      _restLengthFromRest(i, j){ const ix=i*3, jx=j*3; const dx=this.xRest[ix]-this.xRest[jx], dy=this.xRest[ix+1]-this.xRest[jx+1], dz=this.xRest[ix+2]-this.xRest[jx+2]; return Math.hypot(dx,dy,dz); }
      _restLengthToAnchorFromRest(i, anchor){ const ix=i*3; const dx=this.xRest[ix]-anchor[0], dy=this.xRest[ix+1]-anchor[1], dz=this.xRest[ix+2]-anchor[2]; return Math.hypot(dx,dy,dz); }
      _triAreaFromRest(i0,i1,i2){ const a0=i0*3,a1=i1*3,a2=i2*3;
        const x0=this.xRest[a0],y0=this.xRest[a0+1],z0=this.xRest[a0+2];
        const x1=this.xRest[a1],y1=this.xRest[a1+1],z1=this.xRest[a1+2];
        const x2=this.xRest[a2],y2=this.xRest[a2+1],z2=this.xRest[a2+2];
        const ux=x1-x0, uy=y1-y0, uz=z1-z0; const vx=x2-x0, vy=y2-y0, vz=z2-z0;
        const cx=uy*vz-uz*vy, cy=uz*vx-ux*vz, cz=ux*vy-uy*vx; return 0.5*Math.hypot(cx,cy,cz);
      }
      _solveDistance(c, invMass, x, dt){
        const ix=c.i*3, jx=c.j*3; const dx=x[ix]-x[jx], dy=x[ix+1]-x[jx+1], dz=x[ix+2]-x[jx+2];
        const len=Math.hypot(dx,dy,dz); if (len<1e-7) return;
        const C=len-c.L0; const nx=dx/len, ny=dy/len, nz=dz/len; const wi=invMass[c.i], wj=invMass[c.j], w=wi+wj; const alpha=c.alpha/(dt*dt);
        const denom=w+alpha; if (denom<1e-9) return; const dlambda=-(C+alpha*(c.lambda||0))/denom; c.lambda=(c.lambda||0)+dlambda;
        const dxi=wi*dlambda, dxj=-wj*dlambda; x[ix]+=dxi*nx; x[ix+1]+=dxi*ny; x[ix+2]+=dxi*nz; x[jx]+=dxj*nx; x[jx+1]+=dxj*ny; x[jx+2]+=dxj*nz;
      }
      _solveArea(c, invMass, x, dt){
        const i0=c.i0, i1=c.i1, i2=c.i2; const a0=i0*3,a1=i1*3,a2=i2*3;
        const x0=new THREE.Vector3(x[a0],x[a0+1],x[a0+2]);
        const x1=new THREE.Vector3(x[a1],x[a1+1],x[a1+2]);
        const x2=new THREE.Vector3(x[a2],x[a2+1],x[a2+2]);
        const e1=new THREE.Vector3().subVectors(x1,x0);
        const e2=new THREE.Vector3().subVectors(x2,x0);
        const n=new THREE.Vector3().crossVectors(e1,e2); const len=n.length(); if (len<1e-10) return;
        const area=0.5*len; const nHat=n.multiplyScalar(1/len);
        const g0=new THREE.Vector3().crossVectors(new THREE.Vector3().subVectors(x2,x1), nHat).multiplyScalar(0.5);
        const g1=new THREE.Vector3().crossVectors(nHat, new THREE.Vector3().subVectors(x2,x0)).multiplyScalar(0.5);
        const g2=new THREE.Vector3().crossVectors(new THREE.Vector3().subVectors(x1,x0), nHat).multiplyScalar(0.5);
        const wi=invMass[i0], wj=invMass[i1], wk=invMass[i2]; const w=wi*g0.lengthSq()+wj*g1.lengthSq()+wk*g2.lengthSq(); const alpha=c.alpha/(dt*dt);
        const C=area-c.A0; const denom=w+alpha; if (denom<1e-12) return; const dlambda=-(C+alpha*(c.lambda||0))/denom; c.lambda=(c.lambda||0)+dlambda;
        x[a0]+=wi*dlambda*g0.x; x[a0+1]+=wi*dlambda*g0.y; x[a0+2]+=wi*dlambda*g0.z;
        x[a1]+=wj*dlambda*g1.x; x[a1+1]+=wj*dlambda*g1.y; x[a1+2]+=wj*dlambda*g1.z;
        x[a2]+=wk*dlambda*g2.x; x[a2+1]+=wk*dlambda*g2.y; x[a2+2]+=wk*dlambda*g2.z;
      }
      _solveChord(ch, invMass, x, dt){
        if (ch.failed) return;
        const i=ch.i, ix=i*3; const ax=ch.anchor[0], ay=ch.anchor[1], az=ch.anchor[2];
        const dx=x[ix]-ax, dy=x[ix+1]-ay, dz=x[ix+2]-az; const len=Math.hypot(dx,dy,dz); if (len<1e-7) return;
        const L0=ch.L0+ch.slack; const C=len-L0; const nx=dx/len, ny=dy/len, nz=dz/len; const w=invMass[i]; const alpha=(1/(ch.k+1e-9))/(dt*dt);
        const denom=w+alpha; const dlambda=-(C+alpha*(ch.lambda||0))/(denom||1e-9); ch.lambda=(ch.lambda||0)+dlambda;
        const dxi=w*dlambda; x[ix]+=dxi*nx; x[ix+1]+=dxi*ny; x[ix+2]+=dxi*nz;
        const ext=Math.max(0,len-ch.L0); ch.tension=ch.k*ext; if (ch.tension>ch.Tmax) ch.failed=true;
      }
      _resetState(){
        this.v.fill(0);
        for (const c of this.distanceCons) c.lambda=0;
        for (const c of this.areaCons)     c.lambda=0;
        for (const c of this.bendCons)     c.lambda=0;
        for (const ch of this.chords){ ch.lambda=0; ch.failed=false; ch.tension=0; }
      }
      onFixedUpdate(dt){
        const sub=Math.max(1,this.opts.substeps|0); const h=dt/sub; for (let s=0;s<sub;s++) this._step(h);
        if (this.post) this._solveCoaptation(dt);
      }
      onBeforeRender(){ this.posAttr.needsUpdate=true; this.geom.computeVertexNormals(); if (this.fiberLines) this._updateFiberLines(); if (this.chordLines) this._updateChordLines(); if (this.opts.showStress){ this._updateColors(); this.colorAttr.needsUpdate=true; } }
      _step(dt){
        const n=this.vertexCount, inv=this.invMass, x=this.x, v=this.v, xPrev=this.xPrev, damping=this.opts.damping;
        const gx=0, gy=-0.2, gz=0;
        for (let i=0;i<n;i++){
          const off=i*3;
          if (inv[i]===0){ xPrev[off]=x[off]; xPrev[off+1]=x[off+1]; xPrev[off+2]=x[off+2]; v[off]=v[off+1]=v[off+2]=0; continue; }
          v[off]+=dt*gx; v[off+1]+=dt*gy; v[off+2]+=dt*gz;
          xPrev[off]=x[off]; xPrev[off+1]=x[off+1]; xPrev[off+2]=x[off+2];
          x[off]+=dt*v[off]; x[off+1]+=dt*v[off+1]; x[off+2]+=dt*v[off+2];
        }
        for (let it=0; it<this.opts.iterations; it++){
          for (const c of this.distanceCons) this._solveDistance(c, inv, x, dt);
          for (const c of this.bendCons)     this._solveDistance(c, inv, x, dt);
          for (const c of this.areaCons)     this._solveArea(c, inv, x, dt);
          for (const ch of this.chords)      this._solveChord(ch, inv, x, dt);
        }
        for (let i=0;i<n;i++){
          const off=i*3; const vx=(x[off]-xPrev[off])/dt, vy=(x[off+1]-xPrev[off+1])/dt, vz=(x[off+2]-xPrev[off+2])/dt;
          v[off]=vx*(1-damping); v[off+1]=vy*(1-damping); v[off+2]=vz*(1-damping);
        }
      }
      _solveCoaptation(dt){
        const nx=this.opts.nx, ny=this.opts.ny; const cols=nx+1, rows=ny+1, gap=this.opts.gapTarget;
        const xA=this.x, xP=this.post.x, invA=this.invMass, invP=this.post.invMass;
        for (let j=0;j<rows;j++){
          for (let i=0;i<cols;i++){
            const id=j*cols+i; const a=id*3; const p=id*3; const C=(xA[a+1]-xP[p+1])-gap;
            if (C<0){
              const wi=invA[id], wj=invP[id], w=wi+wj; if (w>0){ const dl=-C/w; if (wi>0) xA[a+1]+=wi*dl; if (wj>0) xP[p+1]-=wj*dl; }
            } else if (this.opts.gapBias>0 && C>0 && C<0.004){
              const wi=invA[id], wj=invP[id], w=wi+wj; if (w>0){ const dl=-Math.min(C,0.001)*this.opts.gapBias/w; if (wi>0) xA[a+1]+=wi*dl; if (wj>0) xP[p+1]-=wj*dl; }
            }
          }
        }
      }
      _updateColors(){
        const cols=this.opts.nx+1, rows=this.opts.ny+1, n=this.vertexCount;
        const acc=new Float32Array(n), cnt=new Uint16Array(n);
        const idx=(i,j)=> j*cols+i;
        const L=(a,b)=>{ const ax=a*3,bx=b*3; const dx=this.x[ax]-this.x[bx],dy=this.x[ax+1]-this.x[bx+1],dz=this.x[ax+2]-this.x[bx+2]; return Math.hypot(dx,dy,dz); };
        const L0=(a,b)=> this._restLengthFromRest(a,b);
        for (let j=0;j<rows;j++){
          for (let i=0;i<cols;i++){
            const id=idx(i,j);
            if (i+1<cols){ const n1=idx(i+1,j); const s=Math.abs((L(id,n1)-L0(id,n1))/L0(id,n1)); acc[id]+=s; cnt[id]++; acc[n1]+=s; cnt[n1]++; }
            if (j+1<rows){ const n2=idx(i,j+1); const s=Math.abs((L(id,n2)-L0(id,n2))/L0(id,n2)); acc[id]+=s; cnt[id]++; acc[n2]+=s; cnt[n2]++; }
          }
        }
        let maxS=1e-6; for (let i=0;i<n;i++){ if (cnt[i]>0){ acc[i]/=cnt[i]; if (acc[i]>maxS) maxS=acc[i]; } }
        for (let i=0;i<n;i++){
          const s=Math.min(1,acc[i]/maxS);
          const r=Math.min(1,Math.max(0,2*s-0.1));
          const g=Math.min(1,Math.max(0,1.15-Math.abs(2*s-1.0)));
          const b=Math.min(1,Math.max(0,1.1-2*s));
          this.colors[i*3]=r; this.colors[i*3+1]=g; this.colors[i*3+2]=b;
        }
      }
      _updateFiberLines(){
        const pos=this.fiberLines.geometry.getAttribute('position');
        for (let i=0;i<pos.array.length;i+=6){
          const x0=pos.array[i], y0=pos.array[i+1], z0=pos.array[i+2];
          const x1=x0+0.02, y1=y0, z1=z0;
          pos.array[i]=x0; pos.array[i+1]=y0; pos.array[i+2]=z0;
          pos.array[i+3]=x1; pos.array[i+4]=y1; pos.array[i+5]=z1;
        }
        pos.needsUpdate=true;
      }
    }

    // =============== Hemodynamics (EOA + gradient, both leaflets) ===============
    class HemodynamicsPlugin extends Plugin {
      constructor(opts = {}) {
        super();
        this.opts = Object.assign({
          planeY: 0.12, Rx: 0.18, Rz: 0.13,
          samplesX: 28, samplesZ: 20, rayHeight: 0.28,
          Cd: 0.85, rho: 1060, defaultFlowLpm: 5.0, updateEveryNFrames: 5
        }, opts);
      }
      onInit(engine) {
        this.engine = engine; this.scene = engine.scene;
        this._collectMeshes();
        this.ray = new THREE.Raycaster(); this.ray.firstHitOnly = true;
        this._buildSamplingGrid(); this._buildAperturePoints();
        this.flowLpm = this.opts.defaultFlowLpm; this._buildPanel();
        this.EOA_m2 = 0; this.grad_mmHg = 0; this._frame = 0;
      }
      _collectMeshes(){
        this.valveMeshes = this.engine._plugins.filter(p => p && p.mesh && /Leaflet/i.test(p.constructor.name)).map(p=>p.mesh);
      }
      _buildSamplingGrid(){
        const { samplesX, samplesZ, Rx, Rz } = this.opts; const pts=[];
        for (let iz=0; iz<samplesZ; iz++){
          const vz=(iz+0.5)/samplesZ*2-1;
          for (let ix=0; ix<samplesX; ix++){
            const vx=(ix+0.5)/samplesX*2-1; const x=vx*Rx, z=vz*Rz;
            if ((x*x)/(Rx*Rx)+(z*z)/(Rz*Rz) <= 1.0) pts.push({x,z,open:true});
          }
        }
        this.samples=pts; this.annulusArea_m2=Math.PI*Rx*Rz;
      }
      _buildAperturePoints(){
        const positions=new Float32Array(this.samples.length*3);
        const colors=new Float32Array(this.samples.length*3);
        const y=this.opts.planeY+0.001;
        for (let i=0;i<this.samples.length;i++){
          positions[i*3]=this.samples[i].x; positions[i*3+1]=y; positions[i*3+2]=this.samples[i].z;
          colors[i*3]=0.2; colors[i*3+1]=0.95; colors[i*3+2]=0.4;
        }
        const geo=new THREE.BufferGeometry();
        geo.setAttribute('position', new THREE.BufferAttribute(positions,3));
        geo.setAttribute('color', new THREE.BufferAttribute(colors,3));
        const mat=new THREE.PointsMaterial({ size:0.008, sizeAttenuation:true, vertexColors:true, transparent:true, opacity:0.9 });
        this.aperturePoints=new THREE.Points(geo, mat); this.aperturePoints.renderOrder=2; this.scene.add(this.aperturePoints);
      }
      _buildPanel(){
        const hud=document.querySelector('.hud'); const panel=document.createElement('div');
        panel.className='panel'; panel.style.right='12px'; panel.style.bottom='12px'; panel.style.minWidth='320px'; panel.id='hemo-panel';
        panel.innerHTML = `
          <h3>Hemodynamics</h3>
          <div class="body" style="display:grid; gap:10px;">
            <div class="kv">
              <div class="k">EOA</div><div class="v"><span id="hemo-eoa">‚Äî</span> cm¬≤</div>
              <div class="k">Mean ŒîP</div><div class="v"><span id="hemo-grad">‚Äî</span> mmHg</div>
            </div>
            <div>
              <label for="hemo-flow">Flow (L/min): </label>
              <input id="hemo-flow" type="range" min="2" max="8" step="0.1" value="${this.opts.defaultFlowLpm}" style="width:160px; vertical-align:middle;">
              <span id="hemo-flow-val" style="font-variant-numeric: tabular-nums;">${this.opts.defaultFlowLpm.toFixed(1)}</span>
            </div>
            <div style="opacity:.75; font-size:12px;">EOA via annular-plane aperture; Cd=0.85, œÅ=1060 kg/m¬≥.</div>
          </div>
        `;
        hud.appendChild(panel);
        const slider=panel.querySelector('#hemo-flow');
        slider.addEventListener('input',(e)=>{ this.flowLpm=parseFloat(e.target.value); panel.querySelector('#hemo-flow-val').textContent=this.flowLpm.toFixed(1); this._frame=0; });
        this._panelEOA=panel.querySelector('#hemo-eoa'); this._panelGrad=panel.querySelector('#hemo-grad');
      }
      _evaluateAperture(){
        this._collectMeshes();
        const y0=this.opts.planeY; const dirDown=new THREE.Vector3(0,-1,0); const origin=new THREE.Vector3();
        const posAttr=this.aperturePoints.geometry.getAttribute('position'); const colAttr=this.aperturePoints.geometry.getAttribute('color');
        let openCount=0, total=this.samples.length;
        for (let i=0;i<total;i++){
          const sx=this.samples[i].x, sz=this.samples[i].z; origin.set(sx, y0+this.opts.rayHeight, sz); this.ray.set(origin, dirDown);
          const isects=this.ray.intersectObjects(this.valveMeshes||[], true); let blocked=false;
          if (isects.length>0){ const yhit=isects[0].point.y; if (yhit>=y0-0.0005) blocked=true; }
          if (!blocked) openCount++;
          const r=blocked?0.95:0.2, g=blocked?0.25:0.95, b=blocked?0.3:0.4;
          colAttr.array[i*3]=r; colAttr.array[i*3+1]=g; colAttr.array[i*3+2]=b;
          posAttr.array[i*3+1]=y0+0.001;
        }
        colAttr.needsUpdate=true; posAttr.needsUpdate=true;
        const openFrac=openCount/total; const EOA_m2=openFrac*this.annulusArea_m2; return { EOA_m2, openFrac };
      }
      _computeGradient(EOA_m2){
        const Cd=this.opts.Cd, rho=this.opts.rho; const Q=(this.flowLpm/60.0)*1e-3; const A=Math.max(EOA_m2,1e-6);
        const v=Q/Math.max(Cd*A,1e-9); const dP_Pa=0.5*rho*v*v; return dP_Pa/133.322;
      }
      onBeforeRender(){
        this._frame=(this._frame+1)%this.opts.updateEveryNFrames; if (this._frame!==0) return;
        const { EOA_m2 }=this._evaluateAperture(); this.EOA_m2=EOA_m2; this.grad_mmHg=this._computeGradient(EOA_m2);
        if (this._panelEOA) this._panelEOA.textContent=(EOA_m2*1e4).toFixed(2);
        if (this._panelGrad) this._panelGrad.textContent=this.grad_mmHg.toFixed(2);
      }
      onAfterRender(){ this.aperturePoints.position.y=0; }
    }

    // =============== Bootstrap ===============
    (async function main(){
      try {
        const canvas = document.getElementById('sim');
        const engine = new Engine({ canvas, useWebGPU: false, fixedHz: 120 });        
        engine.addPlugin(new SurgicalShellPlugin());
        engine.addPlugin(new LeafletXPBDPlugin());            // posterior
        engine.addPlugin(new NeedleDriverPlugin());           // tool
        engine.addPlugin(new AnteriorLeafletXPBDPlugin());    // anterior + coaptation
        engine.addPlugin(new HemodynamicsPlugin());           // EOA + gradient
        engine.start();
      } catch (err) {
        console.error(err);
        const box = document.getElementById('error');
        document.getElementById('error-log').textContent = String(err?.stack || err);
        box.style.display = 'block';
      }
    })();
  </script>
</body>
</html>
