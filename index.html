<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Mitral Valve Suturing — Single-File Simulator</title>
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1">
<style>
  html, body { height:100%; margin:0; background:#0b0f12; color:#e9eef2; font-family: system-ui, -apple-system, Segoe UI, Roboto, Inter, sans-serif; }
  #wrap { position:fixed; inset:0; }
  #gl { width:100%; height:100%; display:block; }
  .ui { position:fixed; inset:0; pointer-events:none; }
  .panel { pointer-events:auto; background:rgba(12,16,20,.64); border:1px solid rgba(255,255,255,.08); border-radius:12px; padding:10px 12px; backdrop-filter: blur(8px); }
  .top-left { position:absolute; top:10px; left:10px; max-width:380px; }
  .top-right { position:absolute; top:10px; right:10px; max-width:380px; }
  .bottom-right { position:absolute; bottom:10px; right:10px; max-width:360px; }
  .btn { padding:8px 12px; border-radius:8px; border:1px solid #2a3947; background:#12202b; color:#cde0f0; cursor:pointer; }
  .btn:hover { filter:brightness(1.2); }
  .badge { display:inline-block; padding:2px 6px; border-radius:6px; border:1px solid #2b3b49; background:#10191f; font-size:12px; color:#9ec5ff; }
  .meter { height:8px; background:#0f1a21; border:1px solid #2a3845; border-radius:999px; overflow:hidden; }
  .meter>i { display:block; height:100%; background:linear-gradient(90deg,#3bb273,#5cd1a6); width:0%; }
  ul { margin:6px 0; padding-left:18px; }
  a { color:#7fc6ff; }
  canvas#radar { width:220px; height:120px; background:rgba(255,255,255,0.03); border-radius:8px; display:block; }
</style>
</head>
<body>
<div id="wrap">
  <canvas id="gl"></canvas>
  <div class="ui">
    <div class="panel top-left">
      <h3 style="margin:6px 0 8px">Mitral Valve Suturing — <span id="modeLabel">TUTORIAL</span></h3>
      <div style="display:flex; gap:8px; flex-wrap:wrap">
        <button class="btn" id="btnTutorial">Tutorial</button>
        <button class="btn" id="btnPractice">Practice</button>
        <button class="btn" id="btnExam">Exam</button>
        <button class="btn" id="btnReset">Reset</button>
      </div>
      <p style="opacity:.8;margin-top:8px">Left-move: move driver • Right-drag: rotate • Space: clamp • Enter: take stitch</p>
      <div style="display:grid; grid-template-columns:auto auto; gap:6px 12px; align-items:center">
        <span class="badge">Bite depth</span><strong id="hudDepth">—</strong>
        <span class="badge">Entry angle</span><strong id="hudAngle">—</strong>
        <span class="badge">Tension</span><strong id="hudTension">—</strong>
      </div>
      <div class="meter" style="margin-top:8px"><i id="tensionBar" style="width:0%"></i></div>
    </div>
    <div class="panel top-right">
      <h4 style="margin:6px 0">AI Co-Pilot</h4>
      <ul id="adviceList"><li style="opacity:.7">Take a stitch (Enter) to receive feedback.</li></ul>
      <p style="opacity:.6;font-size:12px;margin-top:8px">Tips appear after each stitch. In Exam mode, only safety alerts.</p>
    </div>
    <div class="panel bottom-right">
      <h4 style="margin:6px 0">Performance</h4>
      <canvas id="radar" width="220" height="120"></canvas>
      <div style="display:flex; gap:12px; margin-top:8px">
        <div><div class="badge">Stitches</div><div id="sumStitches" style="margin-top:4px;font-weight:700">0</div></div>
        <div><div class="badge">Score</div><div id="sumScore" style="margin-top:4px;font-weight:700">—</div></div>
      </div>
      <p style="opacity:.7; font-size:12px; margin-top:8px">Radar = normalized deviations from targets.</p>
    </div>
  </div>
</div>

<script>
/* ===== Tiny linear algebra (vec3/mat4) ===== */
const v3 = {
  create: (x=0,y=0,z=0)=>new Float32Array([x,y,z]),
  set: (o,x,y,z)=>{o[0]=x;o[1]=y;o[2]=z;return o;},
  add:(o,a,b)=>{o[0]=a[0]+b[0];o[1]=a[1]+b[1];o[2]=a[2]+b[2];return o;},
  sub:(o,a,b)=>{o[0]=a[0]-b[0];o[1]=a[1]-b[1];o[2]=a[2]-b[2];return o;},
  scale:(o,a,s)=>{o[0]=a[0]*s;o[1]=a[1]*s;o[2]=a[2]*s;return o;},
  cross:(o,a,b)=>{const ax=a[0],ay=a[1],az=a[2],bx=b[0],by=b[1],bz=b[2];o[0]=ay*bz-az*by;o[1]=az*bx-ax*bz;o[2]=ax*by-ay*bx;return o;},
  dot:(a,b)=>a[0]*b[0]+a[1]*b[1]+a[2]*b[2],
  len:(a)=>Math.hypot(a[0],a[1],a[2]),
  norm:(o,a)=>{const L=v3.len(a)||1;return v3.scale(o,a,1/L);}
};
const m4 = {
  create:()=>new Float32Array([1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1]),
  mul:(o,a,b)=>{const r=new Float32Array(16);
    for(let i=0;i<4;i++){for(let j=0;j<4;j++){r[i*4+j]=a[i*4+0]*b[0*4+j]+a[i*4+1]*b[1*4+j]+a[i*4+2]*b[2*4+j]+a[i*4+3]*b[3*4+j];}}
    o.set(r);return o;},
  translate:(o,a,x,y,z)=>{o.set(a);o[12]+=x;o[13]+=y;o[14]+=z;return o;},
  rotX:(o,a,rad)=>{const c=Math.cos(rad),s=Math.sin(rad);const r=m4.create();
    r[5]=c;r[6]=s;r[9]=-s;r[10]=c;return m4.mul(o,a,r);},
  rotY:(o,a,rad)=>{const c=Math.cos(rad),s=Math.sin(rad);const r=m4.create();
    r[0]=c;r[2]=-s;r[8]=s;r[10]=c;return m4.mul(o,a,r);},
  scale:(o,a,x,y,z)=>{const r=m4.create();r[0]=x;r[5]=y;r[10]=z;return m4.mul(o,a,r);},
  perspective:(o,fovy,aspect,near,far)=>{const f=1/Math.tan(fovy/2);o.fill(0);
    o[0]=f/aspect;o[5]=f;o[10]=(far+near)/(near-far);o[11]=-1;o[14]=(2*far*near)/(near-far);return o;},
  lookAt:(o,eye,center,up)=>{
    const z=v3.create(); v3.sub(z,eye,center); v3.norm(z,z);
    const x=v3.create(); v3.cross(x,up,z); v3.norm(x,x);
    const y=v3.create(); v3.cross(y,z,x);
    o.set([x[0],y[0],z[0],0, x[1],y[1],z[1],0, x[2],y[2],z[2],0, -v3.dot(x,eye),-v3.dot(y,eye),-v3.dot(z,eye),1]); return o;
  }
};
function mulPos(m, x,y,z){ const w= m[3]*x+m[7]*y+m[11]*z+m[15]; return [
  (m[0]*x+m[4]*y+m[8]*z+m[12])/(w||1),
  (m[1]*x+m[5]*y+m[9]*z+m[13])/(w||1),
  (m[2]*x+m[6]*y+m[10]*z+m[14])/(w||1)
];}
function deg(rad){return rad*180/Math.PI;}
function rad(deg){return deg*Math.PI/180;}
/* ===== WebGL helpers ===== */
const vsTri = `
precision highp float;
attribute vec3 aPos, aNorm;
uniform mat4 uModel, uView, uProj;
varying vec3 vN, vW;
void main(){
  vec4 wpos = uModel * vec4(aPos,1.0);
  vW = wpos.xyz;
  vN = mat3(uModel) * aNorm;
  gl_Position = uProj * uView * wpos;
}`;
const fsTri = `
precision highp float;
varying vec3 vN, vW;
uniform vec3 uEye;
uniform vec3 uColor;
uniform vec3 uHemiSky, uHemiGround;
uniform vec3 uDirL; uniform float uDirI;
void main(){
  vec3 N = normalize(vN);
  float hemi = 0.5 + 0.5*N.y;
  vec3 hemiCol = mix(uHemiGround, uHemiSky, hemi);
  float ndl = max(dot(N, normalize(uDirL)), 0.0);
  vec3 L = hemiCol*0.6 + uDirI*ndl*vec3(1.0);
  vec3 base = uColor;
  vec3 V = normalize(uEye - vW);
  vec3 H = normalize(normalize(uDirL)+V);
  float spec = pow(max(dot(N,H),0.0), 32.0)*0.25;
  gl_FragColor = vec4(base*L + spec, 1.0);
}`;
const vsLine = `
precision highp float;
attribute vec3 aPos;
uniform mat4 uModel, uView, uProj;
void main(){ gl_Position = uProj * uView * uModel * vec4(aPos,1.0); }`;
const fsLine = `precision highp float; uniform vec3 uColor; void main(){ gl_FragColor=vec4(uColor,1.0); }`;

function makeProgram(gl, vs, fs){
  function compile(type, src){ const s = gl.createShader(type); gl.shaderSource(s, src); gl.compileShader(s);
    if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) throw new Error(gl.getShaderInfoLog(s)); return s;}
  const p = gl.createProgram();
  const v = compile(gl.VERTEX_SHADER, vs), f = compile(gl.FRAGMENT_SHADER, fs);
  gl.attachShader(p,v); gl.attachShader(p,f); gl.linkProgram(p);
  if (!gl.getProgramParameter(p, gl.LINK_STATUS)) throw new Error(gl.getProgramInfoLog(p));
  return p;
}
function makeMesh(gl, positions, normals, triProg){
  const vao = {}; // simple holder
  vao.vb = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, vao.vb); gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);
  vao.nb = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, vao.nb); gl.bufferData(gl.ARRAY_BUFFER, normals, gl.STATIC_DRAW);
  vao.count = positions.length/3;
  vao.draw = (model, color)=>{
    gl.useProgram(triProg);
    // pos
    gl.bindBuffer(gl.ARRAY_BUFFER, vao.vb);
    const locPos = gl.getAttribLocation(triProg, 'aPos'); gl.enableVertexAttribArray(locPos); gl.vertexAttribPointer(locPos,3,gl.FLOAT,false,0,0);
    // norm
    gl.bindBuffer(gl.ARRAY_BUFFER, vao.nb);
    const locN = gl.getAttribLocation(triProg, 'aNorm'); gl.enableVertexAttribArray(locN); gl.vertexAttribPointer(locN,3,gl.FLOAT,false,0,0);
    // uniforms
    gl.uniformMatrix4fv(gl.getUniformLocation(triProg,'uModel'),false,model);
    gl.uniform3fv(gl.getUniformLocation(triProg,'uColor'),color);
    gl.drawArrays(gl.TRIANGLES, 0, vao.count);
  };
  return vao;
}
function makeLines(gl, positions, lineProg, dynamic=false){
  const vbo = gl.createBuffer();
  const data = positions instanceof Float32Array ? positions : new Float32Array(positions);
  gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
  gl.bufferData(gl.ARRAY_BUFFER, data, dynamic? gl.DYNAMIC_DRAW: gl.STATIC_DRAW);
  const obj = { vbo, count: data.length/3, data };
  obj.draw = (model, color)=>{
    gl.useProgram(lineProg);
    gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
    const loc = gl.getAttribLocation(lineProg,'aPos'); gl.enableVertexAttribArray(loc); gl.vertexAttribPointer(loc,3,gl.FLOAT,false,0,0);
    gl.uniformMatrix4fv(gl.getUniformLocation(lineProg,'uModel'), false, model);
    gl.uniform3fv(gl.getUniformLocation(lineProg,'uColor'), color);
    gl.drawArrays(gl.LINE_STRIP, 0, obj.count);
  };
  obj.update = ()=>{ gl.bindBuffer(gl.ARRAY_BUFFER, vbo); gl.bufferSubData(gl.ARRAY_BUFFER, 0, obj.data); };
  return obj;
}

/* ===== Scene setup ===== */
const canvas = document.getElementById('gl');
const gl = canvas.getContext('webgl', {antialias:true, alpha:false});
if(!gl){ alert('WebGL not available'); throw new Error('WebGL not available'); }

let W=0,H=0, aspect=1;
function resize(){
  const dpr = Math.min(devicePixelRatio||1, 2);
  const w = canvas.clientWidth, h = canvas.clientHeight;
  if (w!==W || h!==H){
    W=w; H=h; aspect = w/h;
    canvas.width = Math.max(1, (w*dpr)|0);
    canvas.height= Math.max(1, (h*dpr)|0);
    gl.viewport(0,0,canvas.width, canvas.height);
  }
}
window.addEventListener('resize', resize); resize();

const progTri = makeProgram(gl, vsTri, fsTri);
const progLine= makeProgram(gl, vsLine, fsLine);
gl.enable(gl.DEPTH_TEST);

/* Global uniforms (set once per frame) */
const U = {
  view: m4.create(), proj: m4.create(),
  eye: v3.create(0,140,280),
  sky: new Float32Array([0.8,0.9,1.0]),
  ground: new Float32Array([0.12,0.16,0.2]),
  dirL: new Float32Array([0.6,1.0,0.5]), dirI: 1.0
};
function setFrameUniforms(){
  gl.useProgram(progTri);
  gl.uniformMatrix4fv(gl.getUniformLocation(progTri,'uView'), false, U.view);
  gl.uniformMatrix4fv(gl.getUniformLocation(progTri,'uProj'), false, U.proj);
  gl.uniform3fv(gl.getUniformLocation(progTri,'uEye'), U.eye);
  gl.uniform3fv(gl.getUniformLocation(progTri,'uHemiSky'), U.sky);
  gl.uniform3fv(gl.getUniformLocation(progTri,'uHemiGround'), U.ground);
  gl.uniform3fv(gl.getUniformLocation(progTri,'uDirL'), U.dirL);
  gl.uniform1f(gl.getUniformLocation(progTri,'uDirI'), U.dirI);

  gl.useProgram(progLine);
  gl.uniformMatrix4fv(gl.getUniformLocation(progLine,'uView'), false, U.view);
  gl.uniformMatrix4fv(gl.getUniformLocation(progLine,'uProj'), false, U.proj);
}

/* Camera control (simple orbit on right-drag) */
const cam = { rx: rad(-10), ry: 0, dist: 320, target: v3.create(0,0,0) };
let rotating=false;
canvas.addEventListener('pointerdown',(e)=>{ if(e.button===2) rotating=true; });
window.addEventListener('pointerup',()=>rotating=false);
window.addEventListener('contextmenu',e=>e.preventDefault());
canvas.addEventListener('pointermove',(e)=>{
  if(rotating){ cam.ry += e.movementX*0.005; cam.rx += e.movementY*0.005; cam.rx = Math.max(rad(-80), Math.min(rad(10), cam.rx)); }
});
function updateCamera(){
  const cx = cam.target[0] + cam.dist*Math.cos(cam.rx)*Math.sin(cam.ry);
  const cy = cam.target[1] + cam.dist*Math.sin(cam.rx);
  const cz = cam.target[2] + cam.dist*Math.cos(cam.rx)*Math.cos(cam.ry);
  v3.set(U.eye, cx,cy,cz);
  m4.lookAt(U.view, U.eye, cam.target, v3.create(0,1,0));
  m4.perspective(U.proj, rad(45), aspect, 0.1, 4000);
}

/* ===== Geometry builders ===== */
function buildPosteriorLeaflet(width=80, depth=24, segX=40, segZ=12){
  // Make a curved ribbon (saddle-ish), y is up.
  const vx = segX+1, vz = segZ+1;
  const positions = [];
  for(let iz=0; iz<vz; iz++){
    const tz = iz/segZ, z = (tz-0.5)*depth;
    for(let ix=0; ix<vx; ix++){
      const tx = ix/segX, x = (tx-0.5)*width;
      const y = -0.12*(z*z)/(depth*0.5) + 0.06*(x*x)/(width*0.5);
      positions.push(x,y,z);
    }
  }
  const tris = [];
  function idx(ix,iz){ return iz*vx + ix; }
  for(let iz=0; iz<segZ; iz++){
    for(let ix=0; ix<segX; ix++){
      const a=idx(ix,iz), b=idx(ix+1,iz), c=idx(ix,iz+1), d=idx(ix+1,iz+1);
      tris.push(a,b,c,  b,d,c);
    }
  }
  // positions & normals
  const P = new Float32Array(tris.length*3);
  const N = new Float32Array(tris.length*3);
  const tempA=v3.create(), tempB=v3.create(), tempC=v3.create(), n=v3.create();
  for(let i=0;i<tris.length;i+=3){
    const ia=tris[i]*3, ib=tris[i+1]*3, ic=tris[i+2]*3;
    v3.set(tempA, positions[ia], positions[ia+1], positions[ia+2]);
    v3.set(tempB, positions[ib], positions[ib+1], positions[ib+2]);
    v3.set(tempC, positions[ic], positions[ic+1], positions[ic+2]);
    const e1=v3.create(), e2=v3.create(); v3.sub(e1,tempB,tempA); v3.sub(e2,tempC,tempA);
    v3.cross(n,e1,e2); v3.norm(n,n);
    P.set(tempA, (i+0)*3); P.set(tempB, (i+1)*3); P.set(tempC, (i+2)*3);
    N.set(n, (i+0)*3); N.set(n, (i+1)*3); N.set(n, (i+2)*3);
  }
  return { P, N, width, depth };
}
function buildBox(w,h,d){
  const x=w/2,y=h/2,z=d/2;
  const p=[ // 12 tris
    // +X
    x,-y,-z,  x,y,-z,  x,y,z,   x,-y,-z,  x,y,z,  x,-y,z,
    // -X
    -x,-y,-z, -x,-y,z, -x,y,z,  -x,-y,-z, -x,y,z, -x,y,-z,
    // +Y
    -x,y,-z,  -x,y,z,  x,y,z,   -x,y,-z,  x,y,z,  x,y,-z,
    // -Y
    -x,-y,-z, x,-y,-z, x,-y,z,  -x,-y,-z, x,-y,z, -x,-y,z,
    // +Z
    -x,-y,z,  x,-y,z,  x,y,z,   -x,-y,z,  x,y,z,  -x,y,z,
    // -Z
    -x,-y,-z, -x,y,-z, x,y,-z,  -x,-y,-z, x,y,-z, x,-y,-z
  ];
  const n=[ // per-face normals
    1,0,0, 1,0,0, 1,0,0,  1,0,0, 1,0,0, 1,0,0,
    -1,0,0,-1,0,0,-1,0,0, -1,0,0,-1,0,0,-1,0,0,
    0,1,0, 0,1,0, 0,1,0,  0,1,0, 0,1,0, 0,1,0,
    0,-1,0,0,-1,0,0,-1,0, 0,-1,0,0,-1,0,0,-1,0,
    0,0,1, 0,0,1, 0,0,1,  0,0,1, 0,0,1, 0,0,1,
    0,0,-1,0,0,-1,0,0,-1, 0,0,-1,0,0,-1,0,0,-1
  ];
  return {P:new Float32Array(p), N:new Float32Array(n)};
}
function buildArcTube(radius=10, arcDeg=135, tubeR=0.8, seg=64, ring=6){
  // Thin tube along arc for needle
  const P=[], N=[];
  for(let i=0;i<seg;i++){
    const t0=i/seg, t1=(i+1)/seg;
    const a0=rad(-arcDeg/2 + t0*arcDeg), a1=rad(-arcDeg/2 + t1*arcDeg);
    const c0=[radius*Math.cos(a0), 0, radius*Math.sin(a0)];
    const c1=[radius*Math.cos(a1), 0, radius*Math.sin(a1)];
    for(let j=0;j<ring;j++){
      const th0=j/ring*Math.PI*2, th1=(j+1)/ring*Math.PI*2;
      const n0=[Math.cos(th0), Math.sin(th0), 0], n1=[Math.cos(th1), Math.sin(th1), 0];
      const p00=[c0[0]+n0[0]*tubeR, n0[1]*tubeR, c0[2]+n0[2]*tubeR];
      const p01=[c0[0]+n1[0]*tubeR, n1[1]*tubeR, c0[2]+n1[2]*tubeR];
      const p10=[c1[0]+n0[0]*tubeR, n0[1]*tubeR, c1[2]+n0[2]*tubeR];
      const p11=[c1[0]+n1[0]*tubeR, n1[1]*tubeR, c1[2]+n1[2]*tubeR];
      // two tris
      P.push(...p00,...p10,...p11,  ...p00,...p11,...p01);
      N.push(...n0,...n0,...n1,     ...n0,...n1,...n1);
    }
  }
  return {P:new Float32Array(P), N:new Float32Array(N)};
}
function buildLineLoopEllipse(rx, rz, steps=128){
  const pts=[];
  for(let i=0;i<=steps;i++){
    const a=i/steps*Math.PI*2;
    pts.push(rx*Math.cos(a), 0, rz*Math.sin(a));
  }
  return new Float32Array(pts);
}

/* ===== Leaflet + annulus ===== */
const leaflet = buildPosteriorLeaflet(80,24,40,12);
const meshLeaflet = makeMesh(gl, leaflet.P, leaflet.N, progTri);
const annulus = makeLines(gl, buildLineLoopEllipse(80*0.6, 24*0.8, 160), progLine, false);
const edge = makeLines(gl, new Float32Array([-leaflet.width/2,0,-leaflet.depth/2,  leaflet.width/2,0,-leaflet.depth/2]), progLine, false);

/* ===== Instrument (needle driver + needle) ===== */
const handleBox = buildBox(40, 4, 4);
const jawBox = buildBox(8, 2, 14);
const meshHandle = makeMesh(gl, handleBox.P, handleBox.N, progTri);
const meshJawL = makeMesh(gl, jawBox.P, jawBox.N, progTri);
const meshJawR = makeMesh(gl, jawBox.P, jawBox.N, progTri);
const needleGeo = buildArcTube(10,135,0.8,70,8);
const meshNeedle = makeMesh(gl, needleGeo.P, needleGeo.N, progTri);
const tool = {
  pos: v3.create(0,40,120),
  rx: 0, ry: 0,
  clamped: false,
  needleLocal: m4.create(), jawL: m4.create(), jawR: m4.create(), handle: m4.create(),
  group: m4.create(),
  rotate(dx,dy){ this.ry += dx*0.01; this.rx += dy*0.01; },
  setClamp(b){ this.clamped=b; }
};
function composeTool(){
  const G = m4.create(); m4.translate(G,G,tool.pos[0],tool.pos[1],tool.pos[2]); m4.rotY(G,G,tool.ry); m4.rotX(G,G,tool.rx);
  tool.group.set(G);
  // handle
  const H = m4.create(); H.set(G); m4.rotZ&&(m4.rotZ); // (no rotZ helper; not needed)
  m4.scale(H,H, 1,1,1); // center
  m4.translate(H,H, 0, 0, 0);
  tool.handle.set(H);
  // jaws
  const JL = m4.create(); JL.set(G);
  m4.translate(JL,JL, 0, 0, 10);
  m4.rotY(JL,JL, tool.clamped? 0.2 : 0.8);
  tool.jawL.set(JL);
  const JR = m4.create(); JR.set(G);
  m4.translate(JR,JR, 0, 0, -10);
  m4.rotY(JR,JR, tool.clamped? -0.2 : -0.8);
  tool.jawR.set(JR);
  // needle (centered at group origin)
  const N = m4.create(); N.set(G);
  tool.needleLocal.set(N);
}
tool.handle = m4.create(); tool.jawL = m4.create(); tool.jawR = m4.create(); tool.needleLocal = m4.create(); composeTool();

/* ===== Suture rope (PBD) ===== */
const rope = {
  count: 60,
  p: new Float32Array(60*3),
  q: new Float32Array(60*3),
  inv: new Float32Array(60).fill(1),
  segLen: 2.0
};
function ropeSet(i,x,y,z){ rope.p[i*3]=x; rope.p[i*3+1]=y; rope.p[i*3+2]=z; }
function ropeInit(){
  const tip = needleTipWorld();
  for(let i=0;i<rope.count;i++){ ropeSet(i, tip[0], tip[1]-i*rope.segLen, tip[2]); rope.q.set(rope.p); }
  rope.inv[0]=0;
}
ropeInit();
const ropeLines = makeLines(gl, rope.p, progLine, true);
function ropeIntegrate(dt){
  for(let i=0;i<rope.count;i++){
    const idx=i*3, inv=rope.inv[i]; if(inv===0) continue;
    const x=rope.p[idx], y=rope.p[idx+1], z=rope.p[idx+2];
    const px=rope.q[idx], py=rope.q[idx+1], pz=rope.q[idx+2];
    const vx=x-px, vy=y-py, vz=z-pz;
    rope.q[idx]=x; rope.q[idx+1]=y; rope.q[idx+2]=z;
    const gx=0, gy=-9.81, gz=0;
    rope.p[idx]=x+vx+gx*dt*dt; rope.p[idx+1]=y+vy+gy*dt*dt; rope.p[idx+2]=z+vz+gz*dt*dt;
  }
}
function ropeProject(iter=6){
  for(let k=0;k<iter;k++){
    for(let i=0;i<rope.count-1;i++){
      const a=i,b=i+1, ia=a*3, ib=b*3;
      let dx=rope.p[ib]-rope.p[ia], dy=rope.p[ib+1]-rope.p[ia+1], dz=rope.p[ib+2]-rope.p[ia+2];
      const L=Math.hypot(dx,dy,dz)||1; const w1=rope.inv[a], w2=rope.inv[b], wsum=w1+w2||1e-6;
      const corr=(L-rope.segLen)/wsum; dx/=L; dy/=L; dz/=L;
      if(w1>0){ rope.p[ia]+=dx*corr*w1; rope.p[ia+1]+=dy*corr*w1; rope.p[ia+2]+=dz*corr*w1; }
      if(w2>0){ rope.p[ib]-=dx*corr*w2; rope.p[ib+1]-=dy*corr*w2; rope.p[ib+2]-=dz*corr*w2; }
    }
  }
}

/* ===== Targets, scoring, copilot ===== */
const cfg = {
  weights: { biteDepth:.18, spacing:.18, entryAngle:.12, exitAngle:.08, symmetry:.08, tensionSafety:.16, chordaeAvoidance:.10, efficiency:.10 },
  targets: { biteDepthMM:[2,3], spacingMM:[2,3], entryAngleDeg:[60,90], exitAngleDeg:[60,90], tensionMaxN:1.0 }
};
let mode = 'tutorial'; // tutorial | practice | exam
const state = {
  liveDepth: 0, liveAngle: 0, liveTension: 0,
  stitches: [],
  nextTargetX: -leaflet.width*0.45,
  targetSpacing: (cfg.targets.spacingMM[0]+cfg.targets.spacingMM[1])/2,
};
function bandScore(x,[lo,hi],tol=0.7){ if(x>=lo&&x<=hi) return 1; const d=(x<lo)?lo-x:x-hi; return Math.max(0,1-d/tol); }
function scoreStitch(m){
  const s = {
    biteDepth: bandScore(m.biteDepthMM, cfg.targets.biteDepthMM),
    spacing:   bandScore(m.spacingMM, cfg.targets.spacingMM),
    entryAngle:bandScore(m.entryAngleDeg, cfg.targets.entryAngleDeg,12),
    exitAngle: bandScore(m.exitAngleDeg, cfg.targets.exitAngleDeg,12),
    symmetry:  Math.max(0,1-m.symmetryMM/1.0),
    tensionSafety: Math.max(0,1-Math.max(0,m.tensionMaxN-cfg.targets.tensionMaxN)/0.5),
    chordaeAvoidance: Math.min(1,m.distNoGoMM/3.0),
    efficiency: Math.max(0,1-(m.timeS-10)/10)
  };
  const w=cfg.weights; const total = s.biteDepth*w.biteDepth + s.spacing*w.spacing + s.entryAngle*w.entryAngle + s.exitAngle*w.exitAngle +
                                   s.symmetry*w.symmetry + s.tensionSafety*w.tensionSafety + s.chordaeAvoidance*w.chordaeAvoidance + s.efficiency*w.efficiency;
  const wsum = Object.values(w).reduce((a,b)=>a+b,0);
  return 100*total/wsum;
}
function copilot(m){
  const out=[];
  const [bdLo,bdHi]=cfg.targets.biteDepthMM, [aLo,aHi]=cfg.targets.entryAngleDeg;
  if(m.biteDepthMM<bdLo) out.push({level:'warn', msg:`Bite too shallow (${m.biteDepthMM.toFixed(1)} mm). Aim ${bdLo}–${bdHi} mm.`});
  if(m.biteDepthMM>bdHi) out.push({level:'warn', msg:`Bite too deep (${m.biteDepthMM.toFixed(1)} mm). Keep ${bdLo}–${bdHi} mm from free edge.`});
  if(m.entryAngleDeg<aLo) out.push({level:'warn', msg:`Entry angle shallow (${Math.round(m.entryAngleDeg)}°). Rotate toward perpendicular (${aLo}–${aHi}°).`});
  if(m.tensionMaxN>cfg.targets.tensionMaxN) out.push({level:'danger', msg:`Tension high. Ease traction to avoid leaflet tear.`});
  if(m.distNoGoMM<1.5) out.push({level:'danger', msg:`Near chordae zone. Shift laterally ≥ 1.5 mm.`});
  if(out.length===0 && mode!=='exam') out.push({level:'info', msg:'Good bite. Maintain depth and perpendicular entry.'});
  if(mode==='exam') return out.filter(a=>a.level!=='info'); // safety only
  return out;
}

/* ===== Targets visualization ===== */
const targetModel = m4.create(); m4.translate(targetModel,targetModel, state.nextTargetX, 0.6, -leaflet.depth/2);
const targetLine = makeLines(gl, new Float32Array([0,0,0, 0,6,0]), progLine, false);
function advanceTarget(){
  state.nextTargetX += state.targetSpacing;
  if(state.nextTargetX>leaflet.width*0.45) state.nextTargetX = -leaflet.width*0.45;
  m4.translate(targetModel, m4.create(), state.nextTargetX, 0.6, -leaflet.depth/2);
}

/* ===== UI wires ===== */
const hudDepth = document.getElementById('hudDepth');
const hudAngle = document.getElementById('hudAngle');
const hudTension = document.getElementById('hudTension');
const tensionBar = document.getElementById('tensionBar');
const adviceList = document.getElementById('adviceList');
const modeLabel = document.getElementById('modeLabel');
const sumStitches = document.getElementById('sumStitches');
const sumScore = document.getElementById('sumScore');
document.getElementById('btnTutorial').onclick=()=>{ mode='tutorial'; modeLabel.textContent='TUTORIAL'; resetAttempt(); };
document.getElementById('btnPractice').onclick=()=>{ mode='practice'; modeLabel.textContent='PRACTICE'; resetAttempt(); };
document.getElementById('btnExam').onclick=()=>{ mode='exam'; modeLabel.textContent='EXAM'; resetAttempt(); };
document.getElementById('btnReset').onclick=()=> resetAttempt();

function setAdvice(items){
  adviceList.innerHTML='';
  if(!items || !items.length){ adviceList.innerHTML='<li style="opacity:.7">No advice.</li>'; return; }
  for(const a of items){
    const li=document.createElement('li');
    li.textContent=a.msg;
    li.style.color = a.level==='info' ? '#a7e3b8' : a.level==='warn' ? '#ffde84' : '#ff968a';
    adviceList.appendChild(li);
  }
}
function updateHUD(){
  hudDepth.textContent = state.liveDepth? state.liveDepth.toFixed(1)+' mm' : '—';
  hudAngle.textContent = state.liveAngle? Math.round(state.liveAngle)+'°' : '—';
  hudTension.textContent= state.liveTension? state.liveTension.toFixed(2)+' N' : '—';
  const pct = Math.max(0, Math.min(1, (state.liveTension||0)/1.2))*100;
  tensionBar.style.width = pct.toFixed(0)+'%';
}
function drawRadar(biteDepthMM, spacingMM, entryAngleDeg, tensionMaxN, score){
  const c=document.getElementById('radar'); const ctx=c.getContext('2d');
  ctx.clearRect(0,0,c.width,c.height);
  const cx=140, cy=70, r=42;
  const labels=['depth','spacing','angle','tension'];
  function norm(k,v){
    if(v==null) return 0;
    if(k==='depth'||k==='spacing'){ const [lo,hi]=cfg.targets[k+'MM']; if(v>=lo&&v<=hi) return 1; const d = (v<lo)?lo-v:v-hi; return Math.max(0,1-d/1.0); }
    if(k==='angle'){ const [lo,hi]=cfg.targets.entryAngleDeg; if(v>=lo&&v<=hi) return 1; const d=(v<lo)?lo-v:v-hi; return Math.max(0,1-d/12); }
    if(k==='tension'){ const lim=cfg.targets.tensionMaxN; return Math.max(0, 1-(Math.max(0,v-lim)/0.5)); }
    return 0;
  }
  const vals=[
    norm('depth', biteDepthMM),
    norm('spacing', spacingMM),
    norm('angle', entryAngleDeg),
    norm('tension', tensionMaxN)
  ];
  // grid
  ctx.strokeStyle='#33506b'; ctx.fillStyle='rgba(127,198,255,0.15)'; ctx.lineWidth=1;
  for(let ring=1; ring<=3; ring++){
    ctx.beginPath();
    for(let i=0;i<labels.length;i++){
      const a=i/labels.length*Math.PI*2 - Math.PI/2;
      const rr = r*ring/3, x=Math.cos(a)*rr, y=Math.sin(a)*rr;
      if(i===0) ctx.moveTo(cx+x,cy+y); else ctx.lineTo(cx+x,cy+y);
    }
    ctx.closePath(); ctx.stroke();
  }
  // polygon
  ctx.beginPath();
  for(let i=0;i<labels.length;i++){
    const a=i/labels.length*Math.PI*2 - Math.PI/2;
    const rr = r*vals[i], x=Math.cos(a)*rr, y=Math.sin(a)*rr;
    if(i===0) ctx.moveTo(cx+x,cy+y); else ctx.lineTo(cx+x,cy+y);
  }
  ctx.closePath(); ctx.fill(); ctx.stroke();
  // labels
  ctx.fillStyle='#9ec5ff'; ctx.font='12px system-ui';
  for(let i=0;i<labels.length;i++){
    const a=i/labels.length*Math.PI*2 - Math.PI/2; const x=Math.cos(a)*(r+10), y=Math.sin(a)*(r+10);
    ctx.fillText(labels[i], cx+x-18, cy+y+4);
  }
  // score
  ctx.font='bold 28px system-ui'; ctx.fillStyle='#a7e3b8';
  ctx.fillText(isFinite(score)? String(Math.round(score)) : '—', 12, 48);
}

/* ===== Input: move tool on left move; rotate on right drag; keys ===== */
let leftActive=true; // follow pointer on plane if not rotating
canvas.addEventListener('pointermove',(e)=>{
  if(!rotating){
    const p = intersectWorkplane(e.clientX, e.clientY, 0); // y=0
    // smooth lerp
    const alpha=0.35; tool.pos[0]=tool.pos[0]*(1-alpha)+p[0]*alpha; tool.pos[2]=tool.pos[2]*(1-alpha)+p[2]*alpha;
  }
});
window.addEventListener('keydown',(e)=>{
  if(e.code==='Space'){ tool.setClamp(!tool.clamped); }
  if(e.code==='Enter'){ takeStitch(); }
});
function intersectWorkplane(clientX, clientY, y=0){
  const rect = canvas.getBoundingClientRect();
  const nx = ((clientX-rect.left)/rect.width)*2-1;
  const ny = -(((clientY-rect.top)/rect.height)*2-1);
  // ray from camera through NDC
  const invViewProj = inv4(m4.mul(new Float32Array(16), U.proj, U.view)); // we need inverse; implement a tiny inv
  // Instead of general inverse, compute ray in view-space: simpler
  // We'll compute world ray manually:
  const cx=U.eye[0], cy=U.eye[1], cz=U.eye[2];
  // build camera basis from view matrix columns (inverse of view upper 3x3)
  // From lookAt, view = [x0 y0 z0 0; x1 y1 z1 0; x2 y2 z2 0; ...]
  const X=[U.view[0],U.view[1],U.view[2]], Y=[U.view[4],U.view[5],U.view[6]], Z=[U.view[8],U.view[9],U.view[10]];
  // Reconstruct forward = -Z, right = X, up = Y
  const right = v3.create(...X), up=v3.create(...Y), fwd=v3.create(-Z[0],-Z[1],-Z[2]);
  const tanFov = Math.tan(rad(45)/2);
  const dir = v3.create();
  const vx = nx * tanFov * aspect, vy = ny * tanFov;
  // Ray in camera space: normalize(fwd + vx*right + vy*up)
  v3.set(dir, fwd[0]+vx*right[0]+vy*up[0], fwd[1]+vx*right[1]+vy*up[1], fwd[2]+vx*right[2]+vy*up[2]); v3.norm(dir,dir);
  // Intersect with plane y=const
  const t = (y - cy) / (dir[1]||1e-6);
  return [cx + dir[0]*t, y, cz + dir[2]*t];
}
function inv4(m){ // minimal Gauss-Jordan for 4x4 (used rarely here); from small template
  const inv=new Float32Array(16), a=new Float32Array(m); inv.set([1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1]);
  for(let i=0;i<4;i++){
    // pivot
    let p=i; for(let r=i+1;r<4;r++) if(Math.abs(a[r*4+i])>Math.abs(a[p*4+i])) p=r;
    if(p!==i){ for(let c=0;c<4;c++){ const t=a[i*4+c]; a[i*4+c]=a[p*4+c]; a[p*4+c]=t; const u=inv[i*4+c]; inv[i*4+c]=inv[p*4+c]; inv[p*4+c]=u; } }
    const f=a[i*4+i]||1e-9; for(let c=0;c<4;c++){ a[i*4+c]/=f; inv[i*4+c]/=f; }
    for(let r=0;r<4;r++){ if(r===i) continue; const g=a[r*4+i]; for(let c=0;c<4;c++){ a[r*4+c]-=g*a[i*4+c]; inv[r*4+c]-=g*inv[i*4+c]; } }
  }
  return inv;
}

/* ===== Stitch metrics ===== */
function needleTipWorld(){
  // tip at arc start in needle local space: (radius,0,0) with our arc builder
  const R=10; const local=[R*Math.cos(rad(-135/2)),0,R*Math.sin(rad(-135/2))];
  const M = tool.needleLocal;
  return mulPos(M, local[0], local[1], local[2]);
}
function needleForwardWorld(){
  // forward vector ~ local +Z negative (down arc normal); we’ll use world up comparison for entry angle proxy
  const M=tool.needleLocal;
  const p0=mulPos(M, 0,0,0), p1=mulPos(M, 0,0,-1);
  return v3.norm(v3.create(), v3.sub(v3.create(), p1, p0));
}
function nearestEdgePoint(p){
  const x = Math.max(-leaflet.width/2, Math.min(leaflet.width/2, p[0]));
  return [x, 0, -leaflet.depth/2];
}
function takeStitch(){
  composeTool();
  const tip = needleTipWorld();
  const edgePt = nearestEdgePoint(tip);
  const depth = Math.hypot(tip[0]-edgePt[0], tip[1]-edgePt[1], tip[2]-edgePt[2]);
  const fwd = needleForwardWorld();
  const entryAngle = deg(Math.acos(Math.max(-1, Math.min(1, fwd[1])))); // angle to +Y
  const spacing = Math.abs(tip[0]-state.nextTargetX);
  const distNoGo = Math.max(0, 6 - Math.abs(tip[2] + leaflet.depth/2)); // crude proxy
  const tension = state.liveTension;
  const stitch = {
    biteDepthMM: depth, spacingMM: spacing,
    entryAngleDeg: entryAngle, exitAngleDeg: entryAngle,
    symmetryMM: 0, tensionMaxN: tension, distNoGoMM: distNoGo,
    timeS: 10, regrips: 0, crossings: 0
  };
  // advice + score
  const adv = copilot(stitch); setAdvice(adv);
  const score = scoreStitch(stitch);
  state.stitches.push(stitch);
  // move target
  advanceTarget();
  // summarize every 3 stitches
  if(state.stitches.length % 3 === 0){
    const last3 = state.stitches.slice(-3);
    const avg = last3.reduce((s,m)=>s+scoreStitch(m),0)/3;
    sumStitches.textContent = String(state.stitches.length);
    sumScore.textContent = String(Math.round(avg));
    drawRadar(stitch.biteDepthMM, stitch.spacingMM, stitch.entryAngleDeg, stitch.tensionMaxN, avg);
  }
}

/* ===== Frame loop ===== */
let tPrev=performance.now();
function frame(){
  resize();
  const now=performance.now(), dt=Math.min(0.05, (now-tPrev)/1000); tPrev=now;
  updateCamera();
  setFrameUniforms();

  // update tool transform from input state
  composeTool();

  // Pin rope head to needle tip
  const tip = needleTipWorld();
  rope.p[0]=tip[0]; rope.p[1]=tip[1]; rope.p[2]=tip[2];

  // integrate/project rope
  ropeIntegrate(dt); ropeProject(6); ropeLines.update();

  // tension proxy
  const headHome=[0,60,120];
  state.liveTension = Math.hypot(rope.p[0]-headHome[0], rope.p[1]-headHome[1], rope.p[2]-headHome[2])*0.03;

  // live HUD probes
  const edgePt = nearestEdgePoint(tip);
  state.liveDepth = Math.hypot(tip[0]-edgePt[0], tip[1]-edgePt[1], tip[2]-edgePt[2]);
  const fwd = needleForwardWorld();
  state.liveAngle = deg(Math.acos(Math.max(-1, Math.min(1, fwd[1]))));
  updateHUD();

  // Clear & draw
  gl.clearColor(0.05,0.07,0.09,1);
  gl.clear(gl.COLOR_BUFFER_BIT|gl.DEPTH_BUFFER_BIT);

  // Ground grid (faint)
  // (simple two lines as reference)
  edge.draw(m4.create(), new Float32Array([0.3,0.4,0.5]));

  // Leaflet
  const Mleaf=m4.create(); meshLeaflet.draw(Mleaf, new Float32Array([1.0,0.95,0.95]));

  // Annulus
  annulus.draw(m4.create(), new Float32Array([0.54,0.76,1.0]));

  // Target marker line
  targetLine.draw(targetModel, new Float32Array([0.4,1.0,0.7]));

  // Tool (handle + jaws + needle)
  meshHandle.draw(tool.handle, new Float32Array([0.22,0.28,0.31]));
  meshJawL.draw(tool.jawL, new Float32Array([0.56,0.74,0.84]));
  meshJawR.draw(tool.jawR, new Float32Array([0.56,0.74,0.84]));
  meshNeedle.draw(tool.needleLocal, new Float32Array([0.69,0.75,0.77]));

  // Rope
  ropeLines.draw(m4.create(), new Float32Array([1,1,1]));

  requestAnimationFrame(frame);
}
requestAnimationFrame(frame);

/* ===== Reset ===== */
function resetAttempt(){
  state.stitches.length=0;
  sumStitches.textContent='0';
  sumScore.textContent='—';
  setAdvice([{level:'info', msg:'Session reset. Take a stitch to begin.'}]);
  state.nextTargetX = -leaflet.width*0.45;
  m4.translate(targetModel, m4.create(), state.nextTargetX, 0.6, -leaflet.depth/2);
  tool.pos.set([0,40,120]); tool.rx=0; tool.ry=0; tool.clamped=false;
  ropeInit();
  drawRadar(NaN,NaN,NaN,NaN,NaN);
}
resetAttempt();
</script>
</body>
</html>
