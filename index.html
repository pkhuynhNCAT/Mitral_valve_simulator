<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Mitral Valve Surgical Simulator • Web</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
  <meta name="description" content="Web-based mitral valve repair & replacement simulator for training and education."/>
  <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
  <!-- Three.js (global build) + OrbitControls (non-module) + lil-gui -->
  <script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
  <script src="https://unpkg.com/three@0.160.0/examples/js/controls/OrbitControls.js"></script>
  <script src="https://unpkg.com/lil-gui@0.19/dist/lil-gui.umd.min.js"></script>
  <style>
    :root{
      --bg:#0b0f14;
      --bg2:#0e141b;
      --panel:#111822;
      --ink:#e9eef6;
      --muted:#9bb2ca;
      --accent:#47d4a1;
      --danger:#ff6b6b;
      --warning:#f6c945;
      --ok:#8bffb3;
      --shadow: 0 10px 30px rgba(0,0,0,.35);
      --radius: 14px;
    }
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;background:radial-gradient(1200px 900px at 70% 10%, #0f1621 0%, var(--bg) 70%);}
    body{font:14px/1.2 Inter,system-ui,Segoe UI,Roboto,Arial,sans-serif;color:var(--ink);overscroll-behavior:none;}
    #app{position:fixed; inset:0; display:grid; grid-template-rows:auto 1fr auto; grid-template-columns:260px 1fr 320px; grid-template-areas:
      "header header header"
      "left   main   right"
      "footer footer footer"; gap:10px; padding:10px;}
    header,aside,main,footer{background:linear-gradient(180deg,var(--panel),#0b121a); border:1px solid #1b2a3a; border-radius:var(--radius); box-shadow:var(--shadow);}
    header{grid-area:header; display:flex; align-items:center; justify-content:space-between; padding:10px 14px;}
    #brand{display:flex; align-items:center; gap:12px;}
    #brand .dot{width:14px; height:14px; border-radius:50%; background:conic-gradient(#ff4d6d, #c9184a, #ff758f);}
    #brand h1{font-size:16px; margin:0; letter-spacing:.3px}
    #simCanvas{display:block; width:100%; height:100%; border-radius:12px;}
    main{grid-area:main; position:relative; overflow:hidden; padding:6px;}
    .scopeVignette{
      pointer-events:none; position:absolute; inset:6px; border-radius:12px;
      background: radial-gradient(ellipse at center, rgba(0,0,0,0) 60%, rgba(0,0,0,.22) 75%, rgba(0,0,0,.55) 100%);
      mix-blend-mode:multiply; opacity:.85;
    }
    .hud{position:absolute; left:12px; bottom:12px; display:flex; flex-wrap:wrap; gap:8px;}
    .pill{background:#112131; border:1px solid #22384f; padding:8px 10px; border-radius:999px; color:var(--muted);}
    .pill b{color:var(--ink)}
    .kbd{display:inline-flex; align-items:center; justify-content:center; min-width:20px; padding:0 6px; height:20px; border-radius:5px; background:#0d1520; border:1px solid #2a3e55; color:#d0e1f7; font-weight:600; font-size:12px; margin:0 2px;}
    aside{padding:12px; overflow:auto}
    aside h2{font-size:13px; letter-spacing:.2px; text-transform:uppercase; color:#c8d7e8; margin:2px 0 10px;}
    .card{background:#0e1622; border:1px solid #203149; border-radius:12px; padding:10px; margin-bottom:10px;}
    .row{display:flex; gap:8px; flex-wrap:wrap;}
    .btn{appearance:none; border:none; background:#12304b; border:1px solid #224765; color:#e6f1fb; padding:10px 12px; border-radius:10px; cursor:pointer;}
    .btn:hover{filter:brightness(1.08)}
    .btn:active{transform:translateY(1px)}
    .btn.alt{background:#193346; border-color:#2a5a7c}
    .btn.green{background:#0f3b2f;border-color:#2d7c6a}
    .btn.red{background:#3b1020;border-color:#7c2d55}
    .grid2{display:grid; grid-template-columns:1fr 1fr; gap:8px;}
    .kpi{background:#0b1420; border:1px solid #1c2c42; border-radius:10px; padding:10px; }
    .kpi h3{margin:0 0 6px 0; font-size:12px; text-transform:uppercase; color:#b8cde4; letter-spacing:.2px;}
    .kpi .val{font-size:18px; font-weight:700}
    .kpi small{color:#9fb3c9}
    #teeWrap{position:absolute; top:10px; right:10px; width:240px; height:180px; background:#0c1219; border:1px solid #22364a; border-radius:10px; overflow:hidden; display:none;}
    #teeTitle{position:absolute; top:8px; left:10px; font-size:12px; color:#cbe2ff; z-index:3; text-shadow:0 2px 6px rgba(0,0,0,.6)}
    #tee{width:100%; height:100%; display:block;}
    #overlayMsg{position:absolute; inset:0; display:flex; align-items:center; justify-content:center; padding:40px; text-align:center; background:rgba(10,14,20,.5); backdrop-filter: blur(6px); }
    #overlayMsg .bubble{max-width:820px; background:#0e1624; border:1px solid #23405d; border-radius:16px; padding:18px; box-shadow:var(--shadow);}
    #overlayMsg h3{margin:0 0 10px 0;}
    #overlayMsg .grid3{display:grid; grid-template-columns:repeat(3,1fr); gap:10px}
    #overlayMsg .li{background:#0c1320; border:1px solid #1b2b40; padding:10px; border-radius:12px;}
    footer{grid-area:footer; display:flex; align-items:center; justify-content:space-between; padding:8px 12px; font-size:12px; color:#b7ccdf}
    .link{color:#bfe3ff; text-decoration:underline; cursor:pointer}
    .switch{display:inline-flex; align-items:center; gap:8px}
    .switch input{accent-color:var(--accent); transform:scale(1.1)}
    .legend{font-size:12px; color:#9db2c9}
    .warn{color:var(--warning)}
    .ok{color:var(--ok)}
    .danger{color:var(--danger)}
    .sep{height:1px;background:#1b2b3f;margin:10px 0}
    /* Error overlay */
    #err{position:fixed; left:10px; top:58px; z-index:9999; background:#2a0e12; border:1px solid #ff7b7b; color:#ffe7e7; padding:10px 12px; border-radius:10px; box-shadow:var(--shadow); display:none; max-width:640px; white-space:pre-wrap; font-family:ui-monospace, Menlo, Consolas, monospace;}
    /* Small screens */
    @media (max-width:1100px){
      #app{grid-template-columns:1fr; grid-template-rows:auto 1fr auto auto; grid-template-areas:
        "header" "main" "left" "right" "footer"}
      aside{max-height:45vh}
      #teeWrap{width:180px;height:140px}
    }
  </style>
</head>
<body>
<div id="err"></div>
<div id="app">
  <header>
    <div id="brand">
      <div class="dot"></div>
      <h1>Mitral Valve Surgical Simulator • Web</h1>
    </div>
    <div class="row">
      <button class="btn green" id="btnStart">Start Simulation</button>
      <button class="btn alt" id="btnReset">Reset</button>
      <button class="btn" id="btnRecord">Record</button>
      <button class="btn" id="btnExport">Export</button>
      <button class="btn" id="btnHelp">Help</button>
    </div>
  </header>

  <aside style="grid-area:left">
    <h2>Scenario</h2>
    <div class="card">
      <label>Procedure:</label>
      <div class="row" style="margin-top:6px">
        <button class="btn" data-scn="repair-annuloplasty">Repair: Annuloplasty + Neo-Chordae</button>
        <button class="btn" data-scn="repair-resection">Repair: Posterior Resection + Ring</button>
        <button class="btn" data-scn="replacement">Replacement: Bioprosthetic</button>
      </div>
      <div class="sep"></div>
      <div class="legend">
        <div><span class="kbd">1</span> Forceps • <span class="kbd">2</span> Needle/Suture •
        <span class="kbd">3</span> Scissors • <span class="kbd">4</span> Ring Sizer •
        <span class="kbd">5</span> Ring Inserter • <span class="kbd">6</span> Valve Prosthesis</div>
        <div><span class="kbd">Ctrl</span>+Click = place suture; <span class="kbd">Shift</span> = precision</div>
        <div>Orbit: LMB rotate • RMB pan • Wheel zoom</div>
      </div>
    </div>

    <h2>Checklist</h2>
    <div class="card" id="checklist"></div>

    <h2>Settings</h2>
    <div class="card">
      <div class="row">
        <label class="switch"><input id="toggleVignette" type="checkbox" checked> Endoscopic Vignette</label>
        <label class="switch"><input id="toggleTEE" type="checkbox"> TEE Overlay</label>
        <label class="switch"><input id="toggleBeat" type="checkbox" checked> Heartbeat</label>
        <label class="switch"><input id="toggleCollisions" type="checkbox" checked> Tissue Collisions</label>
      </div>
      <div class="sep"></div>
      <div class="row">
        <button class="btn" id="btnLighting">Cinematic Lighting</button>
        <button class="btn" id="btnScope">Scope Cam</button>
        <button class="btn" id="btnTop">Top Cam</button>
      </div>
    </div>
  </aside>

  <main>
    <canvas id="simCanvas"></canvas>
    <div class="scopeVignette" id="vignette"></div>

    <div id="teeWrap">
      <div id="teeTitle">TEE (Simulated)</div>
      <canvas id="tee"></canvas>
    </div>

    <div class="hud" id="hud">
      <div class="pill"><b>Tool</b>: <span id="toolName">Forceps</span></div>
      <div class="pill"><b>Scenario</b>: <span id="scnName">Repair: Annuloplasty + Neo-Chordae</span></div>
      <div class="pill"><b>Tension</b>: <span id="tension">0.0</span> N</div>
      <div class="pill"><b>Tissue Trauma</b>: <span id="trauma" class="ok">OK</span></div>
    </div>

    <div id="overlayMsg" style="display:none">
      <div class="bubble">
        <h3>Welcome — Mitral Valve Training Simulator</h3>
        <p>This simulator provides an endoscopic view of the mitral valve for <b>repair</b> (annuloplasty, neo-chordae, posterior resection) and <b>replacement</b>. It models an annulus, anterior/posterior leaflets, papillary muscles, chordae, ring sizing/insertion, basic tissue collision/tearing, suturing, coaptation metrics, and a simulated TEE panel.</p>
        <div class="grid3" style="margin-top:8px">
          <div class="li"><b>Controls</b><br>
            Orbit: LMB rotate • RMB pan • Wheel zoom<br>
            <span class="kbd">1</span> Forceps • <span class="kbd">2</span> Needle • <span class="kbd">3</span> Scissors •
            <span class="kbd">4</span> Sizer • <span class="kbd">5</span> Ring • <span class="kbd">6</span> Prosthesis<br>
            <span class="kbd">Ctrl</span>+Click = place suture • <span class="kbd">Shift</span> = precision
          </div>
          <div class="li"><b>Assessment</b><br>
            Coaptation area, annular dimensions, suture count/placement, ring size match, chordal tension, tissue trauma, time.</div>
          <div class="li"><b>Notes</b><br>
            Educational use only. No clinical decisions. Data export and video recording built-in.</div>
        </div>
        <div class="row" style="margin-top:10px; justify-content:flex-end">
          <button class="btn green" id="btnGo">Got it — Start</button>
        </div>
      </div>
    </div>

  </main>

  <aside style="grid-area:right">
    <h2>Instruments</h2>
    <div class="card">
      <div class="row">
        <button class="btn" data-tool="forceps">Forceps (1)</button>
        <button class="btn" data-tool="needle">Needle/Suture (2)</button>
        <button class="btn" data-tool="scissors">Scissors (3)</button>
        <button class="btn" data-tool="sizer">Ring Sizer (4)</button>
        <button class="btn" data-tool="ring">Annuloplasty Ring (5)</button>
        <button class="btn" data-tool="prosthesis">Valve Prosthesis (6)</button>
      </div>
      <div class="sep"></div>
      <div class="grid2">
        <div class="kpi">
          <h3>Annulus (AP × ML)</h3>
          <div class="val"><span id="ap">0</span> × <span id="ml">0</span> mm</div>
          <small>Auto-updates with beat</small>
        </div>
        <div class="kpi">
          <h3>Coaptation Area</h3>
          <div class="val"><span id="coa">0</span> mm²</div>
          <small>Higher is better (repair)</small>
        </div>
        <div class="kpi">
          <h3>Ring Size Suggest</h3>
          <div class="val"><span id="ringSize">—</span></div>
          <small>Based on AP/ML</small>
        </div>
        <div class="kpi">
          <h3>Score</h3>
          <div class="val"><span id="score">0</span></div>
          <small>− trauma, + coaptation & sizing</small>
        </div>
      </div>
    </div>

    <h2>Procedure Log</h2>
    <div class="card" style="max-height:40vh; overflow:auto" id="log"></div>
  </aside>

  <footer>
    <div>© <span id="year"></span> ValveSim — Training & Education Only • <span class="warn">Not a medical device</span></div>
    <div>Trouble deploying? Ensure this file is named <b>index.html</b> at the repo root and GitHub Pages is enabled for the <b>main</b> branch.</div>
  </footer>
</div>

<script>
(() => {
  const $ = sel => document.querySelector(sel);
  const errEl = $("#err");
  function showErr(e){
    errEl.style.display = "block";
    errEl.textContent = (e && (e.stack || e.message || e.toString())) || "Unknown error";
    console.error(e);
  }
  try {

  // ---------- DOM ----------
  const logEl = $("#log");
  const checklistEl = $("#checklist");
  const simCanvas = $("#simCanvas");
  const teeCanvas = $("#tee");
  const teeWrap = $("#teeWrap");
  const vignette = $("#vignette");
  const toolName = $("#toolName");
  const scnName = $("#scnName");
  const apEl = $("#ap"), mlEl = $("#ml"), coaEl = $("#coa"), scoreEl = $("#score");
  const tensionEl = $("#tension"), traumaEl = $("#trauma");
  const yearEl = $("#year"); yearEl.textContent = new Date().getFullYear();

  // ---------- UI State ----------
  const state = {
    scenario: "repair-annuloplasty",
    tool: "forceps",
    running: false,
    heartbeat: true,
    collisions: true,
    vignette: true,
    tee: false,
    cinematic: false,
    camMode: "scope",
    timeStart: 0,
    sessionLog: [],
    trauma: 0,
    score: 0,
    sutures: [],
    chordae: [],
    grabbed: null,
    placingSuture: null,
    recorder: null,
    mediaChunks: [],
    annulus: {AP: 28, ML: 32}, // mm nominal
  };

  function log(msg){
    const t = (performance.now() / 1000).toFixed(1);
    const line = document.createElement("div");
    line.textContent = "["+t+"s] " + msg;
    logEl.prepend(line);
    state.sessionLog.push({t: +t, msg});
  }

  function setChecklist(items){
    checklistEl.innerHTML = "";
    items.forEach((it, i)=>{
      const row = document.createElement("div");
      row.style.display="flex"; row.style.gap="8px"; row.style.alignItems="center";
      row.style.margin="6px 0";
      const box = document.createElement("input");
      box.type="checkbox"; box.id="cl_"+i;
      box.addEventListener("change",()=>{
        log((box.checked?"Completed":"Unchecked")+": "+it);
        if(box.checked) bumpScore(5); else bumpScore(-5);
      });
      const label = document.createElement("label");
      label.htmlFor="cl_"+i; label.textContent = it;
      row.append(box,label);
      checklistEl.append(row);
    });
  }

  function bumpScore(delta){
    state.score = Math.max(0, state.score + delta);
    scoreEl.textContent = state.score.toFixed(0);
  }

  function setScenario(id){
    state.scenario = id;
    scnName.textContent = {
      "repair-annuloplasty":"Repair: Annuloplasty + Neo-Chordae",
      "repair-resection":"Repair: Posterior Resection + Ring",
      "replacement":"Replacement: Bioprosthetic"
    }[id] || id;
    log("Scenario set: "+scnName.textContent);

    if(id==="repair-annuloplasty"){
      setChecklist([
        "Evaluate leaflets & annulus",
        "Measure AP/ML; choose ring size",
        "Place neo-chordae to prolapsing segment",
        "Annuloplasty ring sutures (8–12 evenly)",
        "Seat and tie ring",
        "Verify coaptation (>5 mm)",
      ]);
    } else if(id==="repair-resection"){
      setChecklist([
        "Identify P2/P3 prolapse",
        "Mark resection area",
        "Resect posterior wedge (virtual)",
        "Approximate leaflet edges (sutures)",
        "Ring sutures evenly spaced",
        "Seat ring; confirm coaptation",
      ]);
    } else {
      setChecklist([
        "Excise native leaflets (virtual)",
        "Measure annulus AP/ML",
        "Select prosthesis size",
        "Place sutures evenly (12)",
        "Seat prosthesis; verify motion",
        "TEE: gradients & opening",
      ]);
    }
    state.sutures = [];
    updateRingSuggestion();
  }

  // ---------- THREE Scene ----------
  let renderer, scene, camera, controls, clock, scopeCam, topCam, teeCam;
  let heartGroup, annulusMesh, leafletA, leafletP, papillaryL, papillaryR, chordaeGroup, toolGroup, ringSizer, ringMesh, prosthesis;
  let raycaster, mouseNDC = new THREE.Vector2(), pickables = [];
  const tmpV = new THREE.Vector3();

  function safeColor(hex){ try{ return new THREE.Color(hex);}catch(e){ return new THREE.Color(0xffffff);} }

  function init3D(){
    renderer = new THREE.WebGLRenderer({canvas: simCanvas, antialias: true, alpha: true, powerPreference:"high-performance"});
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    renderer.setSize(simCanvas.clientWidth || 800, simCanvas.clientHeight || 600, false);
    renderer.setClearColor(0x000000, 0); // transparent to show vignette shading

    scene = new THREE.Scene();

    camera = new THREE.PerspectiveCamera(50, (simCanvas.clientWidth||800)/(simCanvas.clientHeight||600), 0.02, 10);
    camera.position.set(0.10, 0.07, 0.32);
    camera.lookAt(0,0,0);

    controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.target.set(0,0,0);
    controls.enableDamping = true;
    controls.update();

    clock = new THREE.Clock();

    // Lights — bright and forgiving
    const hemi = new THREE.HemisphereLight(0xbfd7ff, 0x203040, 1.0);
    scene.add(hemi);
    const key = new THREE.SpotLight(0xffffff, 3.0, 5.0, Math.PI/6, 0.3, 1.0);
    key.position.set(0.3,0.4,0.3);
    scene.add(key);
    const fill = new THREE.DirectionalLight(0xaad4ff, 1.2);
    fill.position.set(-0.4,0.2,-0.2);
    scene.add(fill);

    // Ground faint disc
    const floorGeo = new THREE.CircleGeometry(1,64);
    const floorMat = new THREE.MeshPhongMaterial({color:0x0b1622, shininess: 30, specular:0x224466, transparent:true, opacity:0.45});
    const floor = new THREE.Mesh(floorGeo, floorMat);
    floor.rotation.x = -Math.PI/2;
    floor.position.y = -0.12;
    scene.add(floor);

    // Valve assembly
    heartGroup = new THREE.Group();
    scene.add(heartGroup);

    // ANNULUS — robust: circular torus scaled to ellipse
    const torus = new THREE.TorusGeometry(0.015, 0.0023, 28, 200); // 30mm outer-diam class
    torus.scale(0.93, 1.0, 1.07); // create ellipse (AP < ML)
    const annMat = new THREE.MeshStandardMaterial({color:0xc1445b, roughness:0.45, metalness:0.08, emissive:safeColor(0x18060a), emissiveIntensity:0.2});
    annulusMesh = new THREE.Mesh(torus, annMat);
    annulusMesh.name = "Annulus";
    heartGroup.add(annulusMesh);
    pickables.push(annulusMesh);

    // LEAFLETS — safe parametric curved planes
    leafletA = makeLeaflet({name:"Anterior", color:0xe36c7d, span:Math.PI*0.65, height:0.010, thickness:0.0016, offset:0.0008, hingeStart:-Math.PI*0.32, hingeEnd:Math.PI*0.32});
    leafletP = makeLeaflet({name:"Posterior", color:0xd4576b, span:Math.PI*0.78, height:0.006, thickness:0.0014, offset:-0.0004, hingeStart:Math.PI*0.32, hingeEnd:Math.PI*1.22});
    heartGroup.add(leafletA.mesh, leafletP.mesh);
    pickables.push(leafletA.mesh, leafletP.mesh);

    // PAPILLARY muscles
    papillaryL = makePapillary(new THREE.Vector3(-0.008,-0.030, 0.008));
    papillaryR = makePapillary(new THREE.Vector3( 0.010,-0.030,-0.006));
    heartGroup.add(papillaryL, papillaryR);

    // CHORDAE
    chordaeGroup = new THREE.Group();
    heartGroup.add(chordaeGroup);
    createChordae();

    // RING SIZER & RING & PROSTHESIS
    ringSizer = makeRingSizer(30); // 30 mm default
    ringSizer.visible = false;
    heartGroup.add(ringSizer);

    ringMesh = makeAnnuloplastyRing(30);
    ringMesh.visible = false;
    heartGroup.add(ringMesh);

    prosthesis = makeProsthesis(30);
    prosthesis.visible = false;
    heartGroup.add(prosthesis);

    // TOOL
    toolGroup = makeTool();
    scene.add(toolGroup);

    // CAMERAS
    scopeCam = camera;
    topCam = new THREE.PerspectiveCamera(40, 1, 0.02, 10);
    topCam.position.set(0,0.18,0.001); topCam.lookAt(0,0,0);
    teeCam = new THREE.PerspectiveCamera(28, 1, 0.02, 10);
    teeCam.position.set(0,-0.05,0); teeCam.lookAt(0,0,0);

    // RAYCASTER
    raycaster = new THREE.Raycaster();

    // Initial metrics
    updateAnnulusMetrics();
    updateRingSuggestion();

    // Loop
    animate();
    onResize();
    window.addEventListener("resize", onResize);
    renderer.domElement.addEventListener("pointermove", onPointerMove);
    renderer.domElement.addEventListener("pointerdown", onPointerDown);
    document.addEventListener("keydown", onKey);

    // Safety console marker
    console.log("ValveSim initialized.");
  }

  // ----- Geometry helpers (robust) -----
  function makeLeaflet({name,color,span,height,thickness,offset,hingeStart,hingeEnd}){
    const segmentsU=64, segmentsV=16;
    const geo = new THREE.PlaneGeometry(1,1,segmentsU,segmentsV);
    const pos = geo.attributes.position;
    const annAP = 0.0145, annML=0.0167; // half-axes (meters) to sit just inside torus
    for(let i=0;i<pos.count;i++){
      const uu = pos.getX(i)+0.5; // 0..1
      const vv = pos.getY(i)+0.5; // 0..1
      const theta = hingeStart + uu*(hingeEnd-hingeStart);
      const annX = annAP*Math.cos(theta);
      const annZ = annML*Math.sin(theta);
      const nn = new THREE.Vector3(Math.cos(theta),0,Math.sin(theta));
      const y = -vv*height + offset;
      const outward = nn.clone().multiplyScalar((vv*vv)*0.0038);
      const x = annX + outward.x;
      const z = annZ + outward.z;
      pos.setXYZ(i, x, y, z);
    }
    geo.computeVertexNormals();
    const mat = new THREE.MeshStandardMaterial({
      color, roughness:0.62, metalness:0.03, side:THREE.DoubleSide,
      polygonOffset:true, polygonOffsetFactor:1, polygonOffsetUnits:1,
      transparent:true, opacity:0.98
    });
    const mesh = new THREE.Mesh(geo, mat);
    mesh.name = name+" Leaflet";

    // small rim curve along hinge
    const rimPts = [];
    for(let k=0;k<=140;k++){
      const u = k/140;
      const th = hingeStart + u*(hingeEnd-hingeStart);
      rimPts.push(new THREE.Vector3(annAP*Math.cos(th), 0, annML*Math.sin(th)));
    }
    const rimGeo = new THREE.TubeGeometry(new THREE.CatmullRomCurve3(rimPts), 140, thickness*0.35, 8, false);
    const rimMat = new THREE.MeshStandardMaterial({color:0xa83d4e, roughness:.5, metalness:.05});
    const rim = new THREE.Mesh(rimGeo, rimMat);
    mesh.add(rim);

    return {mesh, start:hingeStart, end:hingeEnd};
  }

  function makePapillary(pos){
    const geo = new THREE.ConeGeometry(0.004, 0.018, 24);
    const mat = new THREE.MeshStandardMaterial({color:0x6c8599, roughness:.8, metalness:.1});
    const m = new THREE.Mesh(geo, mat);
    m.position.copy(pos);
    m.rotation.x = Math.PI;
    m.name = "Papillary";
    return m;
  }

  function createChordae(){
    chordaeGroup.clear();
    state.chordae = [];
    const leaflets = [leafletA, leafletP];
    const paps = [papillaryL.position, papillaryR.position];
    for(const L of leaflets){
      const edgePoints = [];
      const n = 16;
      for(let i=0;i<=n;i++){
        const th = L.start + (i/n)*(L.end-L.start);
        edgePoints.push(new THREE.Vector3(0.0145*Math.cos(th), 0, 0.0167*Math.sin(th)));
      }
      edgePoints.forEach((p,i)=>{
        const toPap = i%2===0 ? paps[0] : paps[1];
        const line = new THREE.Line(
          new THREE.BufferGeometry().setFromPoints([p, toPap]),
          new THREE.LineBasicMaterial({color:0xd7eaff, linewidth:1}));
        chordaeGroup.add(line);
        state.chordae.push({line, intact:true});
      });
    }
  }

  function makeRingSizer(diamMM){
    const r = (diamMM/1000)/2;
    const geo = new THREE.TorusGeometry(r, 0.0009, 16, 120);
    const mat = new THREE.MeshStandardMaterial({color:0x7fd2ff, transparent:true, opacity:.35});
    const m = new THREE.Mesh(geo, mat);
    m.name = "Ring Sizer";
    return m;
  }

  function makeAnnuloplastyRing(diamMM){
    const r = (diamMM/1000)/2;
    const geo = new THREE.TorusGeometry(r*0.96, 0.0016, 18, 200);
    const mat = new THREE.MeshStandardMaterial({color:0x3bd69f, roughness:.5, metalness:.2});
    const m = new THREE.Mesh(geo, mat);
    m.name = "Annuloplasty Ring";
    return m;
  }

  function makeProsthesis(diamMM){
    const g = new THREE.Group();
    const r = (diamMM/1000)/2;
    const seat = new THREE.Mesh(new THREE.TorusGeometry(r*0.95, 0.0019, 18, 200),
      new THREE.MeshStandardMaterial({color:0x6ee7b7, roughness:.5, metalness:.2}));
    g.add(seat);
    for(let i=0;i<3;i++){
      const leaf = new THREE.Mesh(new THREE.CylinderGeometry(0.0005, r*0.8, 0.0008, 24,1,true),
        new THREE.MeshStandardMaterial({color:0xf1f5f9, roughness:.6, metalness:.05, side:THREE.DoubleSide}));
      leaf.rotation.z = Math.PI/2;
      leaf.rotation.y = i*(2*Math.PI/3);
      g.add(leaf);
    }
    g.name = "Prosthesis";
    return g;
  }

  function makeTool(){
    const g = new THREE.Group();
    const shaft = new THREE.Mesh(new THREE.CylinderGeometry(0.001,0.001,0.22,16),
      new THREE.MeshStandardMaterial({color:0x8099b0, roughness:.6}));
    shaft.position.y = 0.08;
    const tip = new THREE.Mesh(new THREE.ConeGeometry(0.0012,0.008,16),
      new THREE.MeshStandardMaterial({color:0xcbd5e1, roughness:.3, metalness:.5}));
    tip.rotation.x = -Math.PI/2;
    tip.position.set(0, -0.02, 0);
    g.add(shaft, tip);
    g.position.set(0,0.06,0.18);
    g.name = "Tool";
    g.tip = tip;
    return g;
  }

  // ---------- Simulation Loop ----------
  function animate(){
    try {
      const dt = clock.getDelta();
      requestAnimationFrame(animate);

      // Heartbeat
      if(state.heartbeat){
        const t = performance.now()/1000;
        const bpm = 72;
        const w = (bpm/60)*2*Math.PI;
        const phase = Math.sin(w*t)*0.5+0.5;
        const scale = 1 + (phase*0.02);
        heartGroup.scale.setScalar(scale);
        // leaflets pseudo-opening
        const openA = 0.25 + 0.35*phase;
        const openP = 0.32 + 0.28*phase;
        leafletA.mesh.rotation.x = -openA;
        leafletP.mesh.rotation.x =  openP;
        updateAnnulusMetrics();
        updateTEE();
      }

      // Tool subtle sway
      toolGroup.rotation.z = Math.sin(performance.now()/700)*0.03;

      // Camera
      controls.update();
      const cam = (state.camMode==="top" ? topCam : scopeCam);
      renderer.render(scene, cam);
    } catch (e) {
      showErr(e);
    }
  }

  function onResize(){
    const w = simCanvas.clientWidth || 800;
    const h = simCanvas.clientHeight || 600;
    renderer.setSize(w,h,false);
    scopeCam.aspect = w/h;
    scopeCam.updateProjectionMatrix();
    if(state.tee) updateTEE();
  }

  // ---------- Interaction ----------
  function onPointerMove(e){
    const rect = renderer.domElement.getBoundingClientRect();
    mouseNDC.set((e.clientX-rect.left)/rect.width*2-1, -(e.clientY-rect.top)/rect.height*2+1);
    // Move tool toward mouse (projected at plane near valve)
    const plane = new THREE.Plane(new THREE.Vector3(0,0,-1), 0.0);
    raycaster.setFromCamera(mouseNDC, scopeCam);
    const pt = raycaster.ray.intersectPlane(plane, tmpV);
    if(!pt) return;
    toolGroup.position.lerp(new THREE.Vector3(pt.x, pt.y+0.02, pt.z+0.15), 0.25);
    toolGroup.lookAt(0,0,0);

    if(state.grabbed){
      const d = state.grabbed.position.distanceTo(toolGroup.tip.getWorldPosition(tmpV));
      updateTension(d*120);
    } else {
      updateTension(0);
    }
  }

  function onPointerDown(e){
    const isCtrl = e.ctrlKey || e.metaKey;
    raycaster.setFromCamera(mouseNDC, scopeCam);
    const hit = raycaster.intersectObjects(pickables, true)[0];
    if(!hit){ return; }

    if(isCtrl && state.tool==="needle"){
      if(!state.placingSuture){
        state.placingSuture = {from: hit.point.clone()};
        flash("Suture entry marked");
      } else {
        state.placingSuture.to = hit.point.clone();
        placeSuture(state.placingSuture.from, state.placingSuture.to);
        state.placingSuture = null;
      }
      return;
    }

    if(state.tool==="scissors"){
      let cut=false;
      for(const ch of state.chordae){
        if(!ch.intact) continue;
        const a = ch.line.geometry.attributes.position;
        const p0 = new THREE.Vector3(a.getX(0),a.getY(0),a.getZ(0));
        const p1 = new THREE.Vector3(a.getX(1),a.getY(1),a.getZ(1));
        const d = distPointToSegment(hit.point, p0, p1);
        if(d<0.0025){
          ch.intact=false;
          ch.line.material.color.setHex(0x999999);
          log("Chordae cut");
          bumpScore(-8);
          trauma(3);
          cut=true; break;
        }
      }
      if(!cut) flash("No chordae at cursor", 900);
      return;
    }

    if(state.tool==="sizer"){
      ringSizer.visible = true;
      ringSizer.position.set(0,0,0);
      flash("Ring sizer placed");
      return;
    }

    if(state.tool==="ring"){
      ringMesh.visible = true;
      ringMesh.position.set(0,0,0);
      flash("Annuloplasty ring inserted (position & seat)");
      bumpScore(5);
      return;
    }

    if(state.tool==="prosthesis"){
      prosthesis.visible = true;
      prosthesis.position.set(0,0,0);
      flash("Prosthesis inserted (position & seat)");
      bumpScore(5);
      return;
    }

    if(state.tool==="forceps" || state.tool==="needle"){
      state.grabbed = hit.object;
      flash(state.tool==="forceps"?"Grasp tissue":"Needle engaged");
      document.addEventListener("pointerup", onPointerUp, {once:true});
    }
  }

  function onPointerUp(){
    if(state.grabbed){
      flash("Release");
      state.grabbed = null;
      updateTension(0);
    }
  }

  function onKey(e){
    if(e.repeat) return;
    const map = {
      "1":"forceps", "2":"needle", "3":"scissors", "4":"sizer", "5":"ring", "6":"prosthesis"
    };
    if(map[e.key]) setTool(map[e.key]);
    if(e.key==="h"||e.key==="H"){ $("#overlayMsg").style.display = "flex"; }
  }

  function setTool(name){
    state.tool = name;
    toolName.textContent = {
      forceps:"Forceps", needle:"Needle/Suture", scissors:"Scissors",
      sizer:"Ring Sizer", ring:"Annuloplasty Ring", prosthesis:"Valve Prosthesis"
    }[name] || name;
    log("Tool: "+toolName.textContent);
  }

  function updateTension(val){
    tensionEl.textContent = val.toFixed(1);
    if(val>8){ trauma( (val-8)*0.02 ); }
  }

  function placeSuture(a,b){
    const curve = new THREE.QuadraticBezierCurve3(a, a.clone().add(b).multiplyScalar(0.5).add(new THREE.Vector3(0,0.004,0)), b);
    const tube = new THREE.TubeGeometry(curve, 20, 0.0005, 6, false);
    const mat = new THREE.MeshStandardMaterial({color:0xeff6ff, roughness:.6, metalness:.05});
    const suture = new THREE.Mesh(tube, mat);
    heartGroup.add(suture);
    state.sutures.push(suture);
    log("Suture placed");
    bumpScore(2);
    updateCoaptation();
  }

  function trauma(amount){
    state.trauma += amount;
    const t = Math.min(100, state.trauma);
    traumaEl.textContent = t.toFixed(0);
    traumaEl.className = (t>10 ? "danger" : "ok");
    bumpScore(-Math.ceil(amount));
  }

  function updateAnnulusMetrics(){
    const s = heartGroup.scale.x || 1;
    const AP = (0.028*s*1000).toFixed(0);
    const ML = (0.032*s*1000).toFixed(0);
    apEl.textContent = AP; mlEl.textContent = ML;
    state.annulus.AP = +AP; state.annulus.ML = +ML;
  }

  function updateRingSuggestion(){
    const mean = (state.annulus.AP + state.annulus.ML)/2;
    const options = [26,28,30,32,34];
    const pick = options.reduce((p,c)=> Math.abs(c-mean)<Math.abs(p-mean)?c:p, options[0]);
    $("#ringSize").textContent = pick+" mm";
    // Update sizes
    ringSizer.geometry.dispose(); ringSizer.geometry = new THREE.TorusGeometry( (pick/1000)/2, 0.0009, 16, 120);
    ringMesh.geometry.dispose(); ringMesh.geometry = new THREE.TorusGeometry( (pick/1000)/2*0.96, 0.0016, 18, 200);
    prosthesis.children[0].geometry.dispose(); prosthesis.children[0].geometry = new THREE.TorusGeometry((pick/1000)/2*0.95, 0.0019, 18, 200);
  }

  function updateCoaptation(){
    const mid = new THREE.Vector3(0,0,0);
    const a = leafletA.mesh.localToWorld(new THREE.Vector3(0, -0.004, 0)).distanceTo(mid);
    const p = leafletP.mesh.localToWorld(new THREE.Vector3(0,  0.004, 0)).distanceTo(mid);
    const area = Math.max(0, (0.008 - (a+p))*100000);
    coaEl.textContent = area.toFixed(0);
    bumpScore(area>100 ? 1 : 0);
  }

  function updateTEE(){
    if(!state.tee) return;
    const ctx = teeCanvas.getContext("2d");
    const w = teeCanvas.width = teeWrap.clientWidth;
    const h = teeCanvas.height = teeWrap.clientHeight;
    ctx.fillStyle = "#0a0f16"; ctx.fillRect(0,0,w,h);
    const grd = ctx.createRadialGradient(w/2,h/2,h*0.1, w/2,h/2,h*0.52);
    grd.addColorStop(0,"#d6e8ff"); grd.addColorStop(0.45,"#7ea5cc"); grd.addColorStop(1,"#0a0f16");
    ctx.globalAlpha = 0.24; ctx.fillStyle = grd; ctx.beginPath(); ctx.arc(w/2,h/2,h*0.54,0,Math.PI*2); ctx.fill(); ctx.globalAlpha=1;
    const t = performance.now()/1000;
    const y = h/2 + Math.sin(t*3.4)*6;
    ctx.strokeStyle="#e8f3ff"; ctx.lineWidth=2; ctx.beginPath(); ctx.moveTo(w*0.2,y); ctx.lineTo(w*0.8,y); ctx.stroke();
    const img = ctx.createImageData(w,h);
    for(let i=0;i<img.data.length;i+=4){
      const n = Math.random()*30;
      img.data[i]=img.data[i+1]=img.data[i+2]=n; img.data[i+3]=60;
    }
    ctx.putImageData(img,0,0);
  }

  function distPointToSegment(p, a, b){
    const ab = b.clone().sub(a);
    const t = Math.max(0, Math.min(1, p.clone().sub(a).dot(ab)/ab.lengthSq()));
    const proj = a.clone().add(ab.multiplyScalar(t));
    return proj.distanceTo(p);
  }

  // ---------- UI wiring ----------
  $("#btnStart").onclick = start;
  $("#btnGo").onclick = start;
  $("#btnReset").onclick = () => { location.reload(); };
  $("#btnHelp").onclick = () => { $("#overlayMsg").style.display = "flex"; };
  $("#btnLighting").onclick = () => {
    state.cinematic = !state.cinematic;
    scene.traverse(o=>{
      if(o.isLight && o.type!=="HemisphereLight"){
        o.intensity = state.cinematic ? o.intensity*1.3 : o.intensity/1.3;
      }
    });
  };
  $("#btnScope").onclick = () => { state.camMode="scope"; };
  $("#btnTop").onclick = () => { state.camMode="top"; controls.target.set(0,0,0); };

  $("#toggleVignette").onchange = e => { vignette.style.display = e.target.checked?"block":"none"; };
  $("#toggleTEE").onchange = e => { state.tee = e.target.checked; teeWrap.style.display = state.tee?"block":"none"; updateTEE(); };
  $("#toggleBeat").onchange = e => { state.heartbeat = e.target.checked; };
  $("#toggleCollisions").onchange = e => { state.collisions = e.target.checked; };

  $("#btnRecord").onclick = () => {
    if(state.recorder){
      state.recorder.stop();
      return;
    }
    const stream = simCanvas.captureStream(30);
    let rec;
    try{
      rec = new MediaRecorder(stream, {mimeType: "video/webm;codecs=vp9"});
    } catch(e){
      rec = new MediaRecorder(stream);
    }
    state.mediaChunks = [];
    rec.ondataavailable = e => { if(e.data && e.data.size>0) state.mediaChunks.push(e.data); };
    rec.onstop = ()=>{
      const blob = new Blob(state.mediaChunks, {type:"video/webm"});
      const a = document.createElement("a");
      a.href = URL.createObjectURL(blob);
      a.download = "valvesim_session.webm";
      a.click();
      state.recorder = null;
      $("#btnRecord").textContent = "Record";
    };
    rec.start();
    state.recorder = rec;
    $("#btnRecord").textContent = "Stop Recording";
    flash("Recording started");
  };

  $("#btnExport").onclick = ()=>{
    const data = {
      scenario: state.scenario,
      score: state.score,
      trauma: state.trauma,
      annulus: state.annulus,
      sutures: state.sutures.length,
      log: state.sessionLog,
      ts: new Date().toISOString()
    };
    const blob = new Blob([JSON.stringify(data,null,2)], {type:"application/json"});
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = "valvesim_session.json";
    a.click();
  };

  document.querySelectorAll("[data-scn]").forEach(b=>{
    b.onclick = ()=> setScenario(b.getAttribute("data-scn"));
  });

  document.querySelectorAll("[data-tool]").forEach(b=>{
    b.onclick = ()=> setTool(b.getAttribute("data-tool"));
  });

  function start(){
    $("#overlayMsg").style.display = "none";
    if(!state.running){
      state.running = true;
      state.timeStart = performance.now();
      log("Simulation started");
    }
  }

  function flash(msg, ms=1200){
    const el = document.createElement("div");
    el.textContent = msg;
    el.style.position="absolute"; el.style.right="12px"; el.style.bottom="12px";
    el.style.background="#0c1622"; el.style.border="1px solid #23405b"; el.style.padding="8px 12px";
    el.style.borderRadius="10px"; el.style.boxShadow="var(--shadow)";
    document.body.appendChild(el);
    setTimeout(()=> el.remove(), ms);
  }

  // ---------- Boot ----------
  setScenario(state.scenario);
  setTool(state.tool);
  init3D();

  } catch (e) {
    showErr(e);
  }
})();
</script>
</body>
</html>
