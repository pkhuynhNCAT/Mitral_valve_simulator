<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Module 1 — Anatomical Mastery (Mitral Anatomy Recognition)</title>
  <link rel="stylesheet" href="../assets/css/style.css"/>
  <meta name="description" content="MitralSim Pro — Module 1: Anatomical Mastery. Interactive 3D mitral apparatus exploration with AI copilot, variations, and scoring."/>
  <!-- Three.js + Controls (CDN) -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/examples/js/controls/OrbitControls.js"></script>
  <style>
    /* Module-specific tasteful accents */
    .pill { display:inline-flex; align-items:center; gap:8px; padding:6px 10px; border:1px solid var(--outline); border-radius:999px; font-size:12px; color:var(--muted) }
    .kbd-row { display:flex; gap:8px; flex-wrap:wrap }
    .switch { display:inline-flex; align-items:center; gap:8px; cursor:pointer; }
    .switch input{ width:18px; height:18px }
    .panel .row.wrap { flex-wrap:wrap }
    .tile { background:var(--panel); border:1px solid var(--outline); border-radius:10px; padding:8px 10px; font-size:12px; color:var(--muted) }
    .tile b { color:var(--ink) }
    .scorebox { display:grid; grid-template-columns: repeat(2,1fr); gap:8px }
    .scorebox .kpi { text-align:center }
    .overlay-label { position:absolute; transform:translate(-50%,-100%); background:rgba(15,18,24,.92); border:1px solid var(--outline); padding:4px 8px; border-radius:8px; font-size:12px; pointer-events:none }
    .hot { border-color:#ff6b6b !important; box-shadow:0 0 0 2px rgba(255,107,107,.2) inset }
  </style>
</head>
<body>
  <div class="topbar">
    <div class="inner">
      <a class="btn secondary" href="../index.html">← Back</a>
      <div class="logo">Module 1 — Anatomical Mastery</div>
      <span class="badge">Anatomy Recognition</span>
      <div style="flex:1"></div>
      <span class="badge">Educational prototype · Not a medical device</span>
    </div>
  </div>

  <div class="container page">
    <!-- Left sidebar -->
    <aside class="sidebar">
      <div class="panel">
        <h4>Mode</h4>
        <div class="row">
          <button id="btnModeTraining" class="btn secondary">Training</button>
          <button id="btnModePractice" class="btn secondary">Practice</button>
          <button id="btnModeQuiz" class="btn secondary">Quiz</button>
        </div>
        <div class="small">Training = guided lessons with hotspots. Practice = prompts to identify structures. Quiz = timed 10‑question assessment.</div>
      </div>

      <div class="panel">
        <h4>Legend</h4>
        <div class="legend">
          <span class="tag">Red: LV myocardium</span>
          <span class="tag">Teal: LA</span>
          <span class="tag">Green: Mitral annulus</span>
          <span class="tag">Light green: Leaflets (A/P)</span>
          <span class="tag">Yellow: Chordae</span>
          <span class="tag">Purple: Papillary muscles</span>
          <span class="tag">Blue: Targets/Segments</span>
          <span class="tag">Red band: Danger zone</span>
          <span class="tag">Green band: Safe zone</span>
        </div>
      </div>

      <div class="panel">
        <h4>Map Layers</h4>
        <div class="list small" id="layerList">
          <label class="switch"><input type="checkbox" data-layer="leaflets" checked> Leaflets (A/P)</label>
          <label class="switch"><input type="checkbox" data-layer="annulus" checked> Mitral Annulus</label>
          <label class="switch"><input type="checkbox" data-layer="lvot" checked> LVOT & AMC markers</label>
          <label class="switch"><input type="checkbox" data-layer="papillary" checked> Papillary Muscles</label>
          <label class="switch"><input type="checkbox" data-layer="chordae" checked> Chordae Tendineae</label>
          <label class="switch"><input type="checkbox" data-layer="segments" checked> A1–A3 / P1–P3 Hit‑pads</label>
          <label class="switch"><input type="checkbox" data-layer="zones" checked> Safe / Danger Zones</label>
          <label class="switch"><input type="checkbox" data-layer="coronaries" checked> Coronary Surrogates</label>
          <label class="switch"><input type="checkbox" data-layer="labels" checked> Floating Labels</label>
        </div>
      </div>

      <div class="panel">
        <h4>Anatomical Variations</h4>
        <div class="list">
          <select id="variationSel" style="width:100%; padding:8px; border-radius:8px; border:1px solid var(--outline); background:#0d1117; color:var(--ink)">
            <option value="normal">Normal Adult</option>
            <option value="annular_dilation">Annular Dilatation</option>
            <option value="posterior_p2_prolapse">Posterior P2 Prolapse</option>
            <option value="barlow_bileaflet">Barlow‑type Bileaflet Prolapse</option>
            <option value="annular_calcification">Annular Calcification (posterior)</option>
            <option value="cleft_a2">Anterior Leaflet Cleft (A2)</option>
            <option value="short_chordae">Shortened Primary Chordae</option>
          </select>
          <div class="row" style="margin-top:8px">
            <button id="btnApplyVar" class="btn secondary">Apply Variation</button>
            <button id="btnResetVar" class="btn secondary">Reset</button>
          </div>
          <div class="small" id="variationNote">Tip: switch modes after applying a variation to re‑test recognition under different anatomy.</div>
        </div>
      </div>

      <div class="panel">
        <h4>AI Copilot</h4>
        <div id="coachUI" class="list small"></div>
        <div class="row" style="margin-top:8px">
          <button id="btnPrev" class="btn secondary">◀ Prev</button>
          <button id="btnNext" class="btn secondary">Next ▶</button>
        </div>
      </div>

      <div class="panel">
        <h4>Quick Camera</h4>
        <div class="row wrap">
          <button class="btn secondary" data-focus="annulus">Focus Annulus</button>
          <button class="btn secondary" data-focus="aorta">Focus LVOT/AMC</button>
          <button class="btn secondary" data-focus="pap_al">Focus Pap AL</button>
          <button class="btn secondary" data-focus="pap_pm">Focus Pap PM</button>
          <button class="btn secondary" data-focus="reset">Reset View</button>
        </div>
        <div class="kbd-row small" style="margin-top:8px">
          <span class="pill"><b>Orbit</b> drag</span>
          <span class="pill"><b>Pan</b> shift+drag</span>
          <span class="pill"><b>Zoom</b> wheel</span>
          <span class="pill"><b>Hotkeys</b> <kbd>F</kbd> focus, <kbd>L</kbd> labels, <kbd>V</kbd> variations</span>
        </div>
      </div>

      <div class="panel">
        <h4>Metrics & Scoring</h4>
        <div class="scorebox">
          <div class="kpi">
            <div class="label">Accuracy</div>
            <div id="kpiAcc" class="value">0%</div>
          </div>
          <div class="kpi">
            <div class="label">Avg. Response</div>
            <div id="kpiRT" class="value">— s</div>
          </div>
          <div class="kpi">
            <div class="label">Streak</div>
            <div id="kpiStreak" class="value">0</div>
          </div>
          <div class="kpi">
            <div class="label">Score</div>
            <div id="kpiScore" class="value">0</div>
          </div>
        </div>
        <div class="small" style="margin-top:8px">Practice/Quiz: score = correctness, speed, difficulty. Training: ungraded.</div>
      </div>

      <div class="panel">
        <h4>Finish</h4>
        <div class="list small">
          <button id="btnFinish" class="btn">Save to Dashboard</button>
          <div id="finishNote" class="small">Status: <b>Not saved</b></div>
        </div>
      </div>
    </aside>

    <!-- Right main -->
    <main>
      <div id="canvasWrap" class="canvas-wrap">
        <div id="overlay"></div>
      </div>
      <div class="row" style="margin-top:10px; gap:10px">
        <div class="chip"><b>Task:</b> <span id="taskText" class="small">—</span></div>
        <div class="chip"><b>Feedback:</b> <span id="feedbackText" class="small">—</span></div>
      </div>
    </main>
  </div>

  <div class="footer small">© 2025 MitralSim Pro — Module 1. Educational prototype. No clinical use.</div>

  <!-- Module script -->
  <script type="module">
    import {Bus, Util, Overlay, Voice, Progress} from '../assets/js/core/common.js';
    import {Renderer3D} from '../assets/js/core/renderer3d.js';
    import {StepEngine} from '../assets/js/core/coach.js';

    // ---------- State ----------
    const state = {
      mode: 'training',           // 'training' | 'practice' | 'quiz'
      renderer: null,
      groups: {
        core: null,               // entire heart root
        lv: null, la: null,       // myocardium
        annulus: null,            // mitral ring
        leaflets: { A: null, P: null },
        segments: [],             // A1-A3, P1-P3 hitpads
        chordae: null,            // chordae bundle
        pap: { AL: null, PM: null },
        coronaries: { LAD: null, Cx: null },
        aorta: null,              // aortic root surrogate
        zones: { safe: [], danger: [] },
        labels: []                // floating label anchors
      },
      variation: 'normal',
      task: null,                 // current practice/quiz task
      expectKey: null,            // structure key expected
      labelVisible: true,
      quiz: { total: 10, asked: 0, correct: 0, rt: [], score: 0 },
      practice: { asked: 0, correct: 0, streak: 0, rt: [], score: 0 },
      timers: { t0: 0 },
      metricsEls: {
        acc: document.getElementById('kpiAcc'),
        rt: document.getElementById('kpiRT'),
        streak: document.getElementById('kpiStreak'),
        score: document.getElementById('kpiScore')
      },
      ui: {
        task: document.getElementById('taskText'),
        feedback: document.getElementById('feedbackText'),
        finishNote: document.getElementById('finishNote')
      }
    };

    // ---------- UI bindings ----------
    Overlay.init(document.getElementById('canvasWrap'));
    document.getElementById('btnModeTraining').onclick = () => setMode('training');
    document.getElementById('btnModePractice').onclick = () => setMode('practice');
    document.getElementById('btnModeQuiz').onclick = () => setMode('quiz');
    document.getElementById('btnApplyVar').onclick = () => applyVariation(document.getElementById('variationSel').value);
    document.getElementById('btnResetVar').onclick = () => applyVariation('normal');
    document.getElementById('btnPrev').onclick = () => engine.prev();
    document.getElementById('btnNext').onclick = () => engine.next();
    document.getElementById('btnFinish').onclick = saveProgress;

    // Layer toggles
    document.getElementById('layerList').addEventListener('change', (e) => {
      if(!(e.target instanceof HTMLInputElement)) return;
      toggleLayer(e.target.dataset.layer, e.target.checked);
    });

    // Quick camera focus
    document.querySelectorAll('[data-focus]').forEach(btn => {
      btn.addEventListener('click', () => focusView(btn.dataset.focus));
    });

    // Hotkeys
    window.addEventListener('keydown', (e) => {
      if(e.key === 'f' || e.key === 'F') focusView('annulus');
      if(e.key === 'l' || e.key === 'L') { state.labelVisible = !state.labelVisible; updateLabelVisibility(); }
      if(e.key === 'v' || e.key === 'V') cycleVariation();
    });

    // ---------- Renderer ----------
    state.renderer = new Renderer3D(document.getElementById('canvasWrap'));
    state.renderer.animate();

    // ---------- Build anatomy ----------
    buildMitralAnatomy();

    // ---------- Picking & interactions ----------
    const pickables = new Set();      // objects that can be clicked / quizzed
    // will be filled while building

    state.renderer.renderer.domElement.addEventListener('click', onClick);

    function onClick(ev){
      const dom = state.renderer.renderer.domElement;
      const hits = state.renderer.pick(ev.clientX, ev.clientY, Array.from(pickables));
      if(!hits.length) return;

      // Prefer segment pads > key landmarks > surfaces
      const hit = hits.sort((a,b)=>{
        const ap = (a.object.userData.kind==='segment')?0: (a.object.userData.kind==='landmark'?1:2);
        const bp = (b.object.userData.kind==='segment')?0: (b.object.userData.kind==='landmark'?1:2);
        return ap-bp;
      })[0];

      const obj = hit.object;
      const key = obj.userData.key;
      const label = obj.userData.label || obj.name || key;
      showFloatingLabel(hit.point, label);

      if(state.mode === 'training'){
        // In training, step goals will check specific keys
        lastClickKey = key;
        engine.check();
        feedback(`Selected: ${label}`);
      } else {
        evaluateSelection(key, label);
      }
    }

    function showFloatingLabel(worldPoint, text){
      if(!state.labelVisible) return;
      const {x,y} = state.renderer.worldToScreen(worldPoint);
      const d = document.createElement('div');
      d.className = 'overlay-label';
      d.textContent = text;
      d.style.left = (x|0)+'px';
      d.style.top  = (y|0)+'px';
      Overlay.el.appendChild(d);
      setTimeout(()=>d.remove(), 1500);
    }

    // ---------- Anatomy construction ----------
    function buildMitralAnatomy(){
      const scene = state.renderer.scene;
      const root = new THREE.Group(); root.name='HeartRoot'; scene.add(root);
      state.groups.core = root;

      // Lighting tweak (already in renderer) — add subtle rim
      const rim = new THREE.DirectionalLight(0x88aaff, 0.25); rim.position.set(-3, 2, -4); scene.add(rim);

      // Left Ventricle (LV) — ellipsoid
      const lvGeo = new THREE.SphereGeometry(0.95, 40, 32);
      const lvMat = new THREE.MeshStandardMaterial({ color:0x8b2b2b, roughness:0.9, metalness:0.05 });
      const lv = new THREE.Mesh(lvGeo, lvMat);
      lv.scale.set(0.85, 1.15, 0.85);
      lv.position.set(0, -0.15, 0);
      lv.name = 'LV';
      root.add(lv);
      state.groups.lv = lv;

      // Left Atrium (LA) — smaller ellipsoid
      const laGeo = new THREE.SphereGeometry(0.55, 36, 28);
      const laMat = new THREE.MeshStandardMaterial({ color:0x2c8b8b, roughness:0.95, metalness:0.02 });
      const la = new THREE.Mesh(laGeo, laMat);
      la.scale.set(0.9, 0.7, 0.9);
      la.position.set(0, 0.55, -0.05);
      la.name = 'LA';
      root.add(la);
      state.groups.la = la;

      // Mitral Annulus — torus scaled elliptical
      const annGeo = new THREE.TorusGeometry(0.65, 0.045, 28, 180);
      const annMat = new THREE.MeshStandardMaterial({ color:0x2b7a3f, roughness:0.8, metalness:0.1, emissive:0x001a00 });
      const ann = new THREE.Mesh(annGeo, annMat);
      ann.rotation.x = Math.PI/2;
      ann.scale.set(1.15, 1.0, 0.95);  // ellipse-ish
      ann.position.set(0, 0.22, 0);
      ann.name = 'Mitral Annulus';
      root.add(ann);
      state.groups.annulus = ann;
      pickables.add(ann);
      ann.userData = { key:'annulus', label:'Mitral Annulus', kind:'landmark' };

      // Aortic root & LVOT surrogate
      const aorta = new THREE.Mesh(
        new THREE.TorusGeometry(0.35, 0.05, 24, 120),
        new THREE.MeshStandardMaterial({ color:0x7da0ff, roughness:0.8, metalness:0.1 })
      );
      aorta.rotation.set(Math.PI/2.2, 0.0, 0.45);
      aorta.position.set(0.35, 0.34, 0.1);
      aorta.name='Aortic Root';
      root.add(aorta);
      state.groups.aorta = aorta;
      pickables.add(aorta);
      aorta.userData = { key:'aorta', label:'Aortic Root', kind:'landmark' };

      // LVOT point & AMC marker (as tiny spheres)
      const lvot = new THREE.Mesh(new THREE.SphereGeometry(0.02, 12, 12), new THREE.MeshBasicMaterial({color:0x40a9ff}));
      lvot.position.set(0.15, 0.28, 0.08); lvot.name='LVOT';
      root.add(lvot); pickables.add(lvot);
      lvot.userData = { key:'lvot', label:'LVOT', kind:'landmark' };

      const amc = new THREE.Mesh(new THREE.SphereGeometry(0.022, 12, 12), new THREE.MeshBasicMaterial({color:0x40a9ff}));
      amc.position.set(0.12, 0.23, 0.0); amc.name='Aorto‑Mitral Continuity';
      root.add(amc); pickables.add(amc);
      amc.userData = { key:'amc', label:'Aorto‑Mitral Continuity (AMC)', kind:'landmark' };

      // Leaflets: anterior (A) & posterior (P) — curved planes
      const leafA = makeLeaflet(+1, 0x6dad8f, 'Anterior Leaflet (A)');
      const leafP = makeLeaflet(-1, 0x7ca38c, 'Posterior Leaflet (P)');
      root.add(leafA, leafP);
      state.groups.leaflets.A = leafA; state.groups.leaflets.P = leafP;
      pickables.add(leafA); leafA.userData = { key:'leaflet_A', label:'Anterior Leaflet', kind:'landmark' };
      pickables.add(leafP); leafP.userData = { key:'leaflet_P', label:'Posterior Leaflet', kind:'landmark' };

      // Leaflet segment hitpads A1-A3 / P1-P3 (blue invisible circles)
      state.groups.segments = [];
      const segSpec = [
        {key:'A1', theta: -0.8}, {key:'A2', theta: 0.0}, {key:'A3', theta: +0.8},
        {key:'P1', theta: -0.8+Math.PI}, {key:'P2', theta: Math.PI}, {key:'P3', theta: +0.8+Math.PI}
      ];
      const segGroup = new THREE.Group(); segGroup.name='Segments'; root.add(segGroup);
      segSpec.forEach(s => {
        const r = 0.64;
        const pad = new THREE.Mesh(
          new THREE.CylinderGeometry(0.06,0.06, 0.003, 24),
          new THREE.MeshBasicMaterial({ color:0x40a9ff, transparent:true, opacity:0.15 })
        );
        const x = Math.cos(s.theta)*r, z = Math.sin(s.theta)*r;
        pad.position.set(x, 0.23, z);
        pad.rotation.x = Math.PI/2;
        pad.name = s.key;
        segGroup.add(pad);
        state.groups.segments.push(pad);
        pickables.add(pad);
        pad.userData = { key: s.key.toLowerCase(), label: s.key, kind:'segment' };
      });

      // Papillary muscles (AL/PM) — purple cones inside LV
      const papAL = makePapillary(new THREE.Color(0x7c4dff)); papAL.position.set(+0.25, -0.25, +0.12); papAL.name='Papillary (AL)';
      const papPM = makePapillary(new THREE.Color(0x8a4dff)); papPM.position.set(-0.22, -0.27, -0.18); papPM.name='Papillary (PM)';
      root.add(papAL, papPM);
      state.groups.pap.AL = papAL; state.groups.pap.PM = papPM;
      pickables.add(papAL); papAL.userData = { key:'pap_al', label:'Anterolateral Papillary Muscle', kind:'landmark' };
      pickables.add(papPM); papPM.userData = { key:'pap_pm', label:'Posteromedial Papillary Muscle', kind:'landmark' };

      // Chordae tendineae — yellow tubes from pap tips to leaflet underside (few strands)
      const chordae = new THREE.Group(); chordae.name='Chordae';
      root.add(chordae); state.groups.chordae = chordae;
      const chordMat = new THREE.MeshStandardMaterial({ color:0xe6cf57, roughness:0.5, metalness:0.2 });
      function strand(from, to){
        const curve = new THREE.CatmullRomCurve3([from, from.clone().lerp(to,0.4).add(new THREE.Vector3(0,0.06,0)), to]);
        const geo = new THREE.TubeGeometry(curve, 32, 0.008, 8, false);
        const m = new THREE.Mesh(geo, chordMat);
        chordae.add(m); pickables.add(m);
        m.userData = { key:'chordae', label:'Chordae Tendineae', kind:'landmark' };
        return m;
      }
      const papALTip = new THREE.Vector3().copy(papAL.position).add(new THREE.Vector3(0,0.14,0));
      const papPMTip = new THREE.Vector3().copy(papPM.position).add(new THREE.Vector3(0,0.14,0));
      // a few attachments to leaflet underside near A2/P2
      [ new THREE.Vector3(0.1,0.22, 0.03), new THREE.Vector3(0.0,0.22, 0.07), new THREE.Vector3(-0.1,0.22, 0.02) ].forEach(p=> strand(papALTip, p));
      [ new THREE.Vector3(0.1,0.22,-0.04), new THREE.Vector3(0.0,0.22,-0.09), new THREE.Vector3(-0.1,0.22,-0.06) ].forEach(p=> strand(papPMTip, p));

      // Coronary surrogates (simplified): LAD on anterior surface, Cx near posterior annulus
      const coronaries = new THREE.Group(); coronaries.name='Coronaries'; root.add(coronaries);
      const vesselMat = new THREE.MeshStandardMaterial({ color:0xff6666, roughness:0.4, metalness:0.3 });
      const lad = vesselTube([ [0.05,0.35,0.15], [0.00,0.25,0.18], [-0.02,0.15,0.15], [-0.05,0.0,0.1] ], 0.012, vesselMat);
      const cx  = vesselTube([ [-0.42,0.22,-0.05], [-0.55,0.22,0.0], [-0.65,0.22,0.05] ], 0.012, vesselMat);
      coronaries.add(lad, cx);
      state.groups.coronaries.LAD = lad; state.groups.coronaries.Cx = cx;
      pickables.add(lad); lad.userData = { key:'lad', label:'LAD (surrogate)', kind:'landmark' };
      pickables.add(cx);  cx.userData  = { key:'cx',  label:'Circumflex (surrogate)', kind:'landmark' };

      // Safe/Danger annular sectors (LVOT/conduction hazard; posterior Cx proximity)
      const zonesGroup = new THREE.Group(); zonesGroup.name='Zones'; root.add(zonesGroup);
      const safe1 = arcSector(0.65, 0.11, Math.PI*0.05, Math.PI*0.35, 0x00ff88);
      const danger1 = arcSector(0.65, 0.11, Math.PI*0.4, Math.PI*0.55, 0xff3366); // conduction area surrogate
      const danger2 = arcSector(0.65, 0.11, Math.PI*1.15, Math.PI*1.35, 0xff5c7a); // Cx proximity
      zonesGroup.add(safe1, danger1, danger2);
      zonesGroup.position.set(0,0.22,0);
      zonesGroup.rotation.x = Math.PI/2;
      state.groups.zones.safe = [safe1];
      state.groups.zones.danger = [danger1, danger2];

      // Floating labels (initial)
      addLabelAnchor(ann.position.clone().add(new THREE.Vector3(0.0, 0.15, 0.0)), 'Annulus');
      addLabelAnchor(new THREE.Vector3(0.12,0.23,0), 'AMC');
      addLabelAnchor(new THREE.Vector3(0.15,0.28,0.08), 'LVOT');
      addLabelAnchor(papAL.position.clone().add(new THREE.Vector3(0,0.22,0)), 'Pap AL');
      addLabelAnchor(papPM.position.clone().add(new THREE.Vector3(0,0.22,0)), 'Pap PM');

      // Helper functions
      function makeLeaflet(sign=+1, color=0x6dad8f, name='Leaflet'){
        const w=1.2, h=0.45, segX=48, segY=16;
        const geo = new THREE.PlaneGeometry(w, h, segX, segY);
        geo.rotateX(-Math.PI/2);
        geo.translate(0, 0.22+sign*0.07, 0);
        const pos = geo.attributes.position;
        for(let i=0;i<pos.count;i++){
          const x = pos.getX(i), z = pos.getZ(i);
          const bulge = Math.exp(-Math.abs(x))*0.09 * sign;
          const scallop = Math.sin(x*1.7)*0.03 * sign;
          pos.setY(i, pos.getY(i) + bulge + scallop);
        }
        pos.needsUpdate = true;
        const m = new THREE.MeshStandardMaterial({ color, metalness:0.05, roughness:0.92, side:THREE.DoubleSide });
        const mesh = new THREE.Mesh(geo, m); mesh.name=name; return mesh;
      }

      function makePapillary(color){
        const cone = new THREE.Mesh(
          new THREE.ConeGeometry(0.08, 0.24, 24),
          new THREE.MeshStandardMaterial({ color, roughness:0.6, metalness:0.2 })
        );
        cone.rotation.x = -0.4;
        return cone;
      }

      function vesselTube(points, r, mat){
        const pts = points.map(p=> new THREE.Vector3(p[0],p[1],p[2]));
        const curve = new THREE.CatmullRomCurve3(pts);
        const geo = new THREE.TubeGeometry(curve, 64, r, 10, false);
        return new THREE.Mesh(geo, mat);
      }

      function arcSector(r=0.65, tube=0.12, start=0, end=Math.PI/3, color=0x0a8f4b){
        const shape = new THREE.Shape();
        shape.absarc(0,0,r+tube, start, end, false);
        const inner = new THREE.Path();
        inner.absarc(0,0,r-tube, end, start, true);
        shape.holes.push(inner);
        const geo = new THREE.ShapeGeometry(shape, 40);
        const mat = new THREE.MeshBasicMaterial({ color, transparent:true, opacity:0.24, side:THREE.DoubleSide });
        return new THREE.Mesh(geo, mat);
      }

      function addLabelAnchor(vec3, text){
        const dot = new THREE.Mesh(new THREE.SphereGeometry(0.01,10,10), new THREE.MeshBasicMaterial({color:0xffffff, transparent:true, opacity:0.0}));
        dot.position.copy(vec3); dot.userData = { label: text };
        root.add(dot); state.groups.labels.push(dot);
      }
    }

    // ---------- Variations ----------
    function applyVariation(kind='normal'){
      state.variation = kind;
      const g = state.groups;

      // Reset transforms
      g.annulus.scale.set(1.15, 1.0, 0.95);
      g.leaflets.A.position.y = 0.29; g.leaflets.P.position.y = 0.15;
      g.leaflets.A.geometry.attributes.position.needsUpdate = true;
      g.leaflets.P.geometry.attributes.position.needsUpdate = true;

      // remove calcification artifacts if any
      if(g.annulus.userData.calcMeshes){
        g.annulus.userData.calcMeshes.forEach(m=> g.annulus.remove(m));
        g.annulus.userData.calcMeshes = [];
      }

      switch(kind){
        case 'annular_dilation':
          g.annulus.scale.set(1.35, 1.0, 1.10);
          Voice.speak('Variation applied: Annular dilatation.');
          break;
        case 'posterior_p2_prolapse':
          pushLeafletBulge(g.leaflets.P, +0.06, -0.1, 'P2');
          Voice.speak('Variation applied: posterior P2 prolapse.');
          break;
        case 'barlow_bileaflet':
          pushLeafletBulge(g.leaflets.A, +0.07, 0, 'A2');
          pushLeafletBulge(g.leaflets.P, +0.07, 0, 'P2');
          Voice.speak('Variation applied: Barlow-type bileaflet prolapse.');
          break;
        case 'annular_calcification':
          addAnnularCalcificationSegment();
          Voice.speak('Variation applied: annular calcification on posterior arc.');
          break;
        case 'cleft_a2':
          carveLeafletCleft(g.leaflets.A, 0.0 /* A2 center */);
          Voice.speak('Variation applied: cleft at A2.');
          break;
        case 'short_chordae':
          shortenChordae(0.85);
          Voice.speak('Variation applied: shortened primary chordae.');
          break;
        default:
          Voice.speak('Variation reset to normal.');
      }

      // light visual cue on annulus
      pulseMaterial(g.annulus.material);

      function pushLeafletBulge(leaf, amp=0.06, xCenter=0.0, tag=''){
        const pos = leaf.geometry.attributes.position;
        for(let i=0;i<pos.count;i++){
          const x = pos.getX(i), z = pos.getZ(i);
          const near = Math.exp(-Math.pow((x-xCenter)/0.25,2));
          const lift = amp * near;
          pos.setY(i, pos.getY(i) + lift);
        }
        pos.needsUpdate = true;
      }

      function carveLeafletCleft(leaf, xCenter=0.0){
        const pos = leaf.geometry.attributes.position;
        for(let i=0;i<pos.count;i++){
          const x = pos.getX(i);
          const d = Math.abs(x-xCenter);
          if(d < 0.08){
            pos.setY(i, pos.getY(i) - (0.05 - d*0.5));
          }
        }
        pos.needsUpdate = true;
      }

      function addAnnularCalcificationSegment(){
        const seg = new THREE.Mesh(
          new THREE.TorusGeometry(0.65, 0.055, 22, 80, Math.PI*0.35),
          new THREE.MeshStandardMaterial({ color:0xdddddd, roughness:0.6, metalness:0.3, emissive:0x111111 })
        );
        seg.rotation.x = Math.PI/2;
        seg.rotation.z = Math.PI*1.1;
        seg.position.copy(g.annulus.position);
        g.annulus.add(seg);
        g.annulus.userData.calcMeshes = (g.annulus.userData.calcMeshes||[]).concat(seg);
      }

      function shortenChordae(factor){
        state.groups.chordae.children.forEach(mesh=>{
          mesh.scale.y = factor;
          mesh.updateMatrix(); mesh.updateMatrixWorld();
        });
      }

      function pulseMaterial(mat){
        const base = mat.emissive.clone();
        let t=0; const off = state.renderer.addTicker(dt=>{
          t += dt; const k = Math.sin(t*6)*0.5+0.5;
          mat.emissive.lerpColors(base, new THREE.Color(0x112200), k*0.25);
          if(t>0.8){ state.renderer._tickers.delete(off); mat.emissive.copy(base); }
        });
      }
    }

    function cycleVariation(){
      const sel = document.getElementById('variationSel');
      const idx = sel.selectedIndex;
      const next = (idx+1) % sel.options.length;
      sel.selectedIndex = next;
      applyVariation(sel.value);
    }

    // ---------- Layers ----------
    function toggleLayer(layer, visible){
      const g = state.groups;
      const setVis = (obj, v)=>{ if(!obj) return; obj.visible = v; if(obj.children) obj.children.forEach(c=>setVis(c,v)); };

      switch(layer){
        case 'leaflets': setVis(g.leaflets.A, visible); setVis(g.leaflets.P, visible); break;
        case 'annulus': setVis(g.annulus, visible); break;
        case 'papillary': setVis(g.pap.AL, visible); setVis(g.pap.PM, visible); break;
        case 'chordae': setVis(g.chordae, visible); break;
        case 'segments': g.segments.forEach(s=> setVis(s, visible)); break;
        case 'zones': g.zones.safe.forEach(z=> setVis(z, visible)); g.zones.danger.forEach(z=> setVis(z, visible)); break;
        case 'coronaries': setVis(state.groups.coronaries.LAD, visible); setVis(state.groups.coronaries.Cx, visible); break;
        case 'lvot': setVis(state.groups.aorta, visible); break;
        case 'labels': state.labelVisible = visible; updateLabelVisibility(); break;
      }
    }

    function updateLabelVisibility(){
      const any = state.labelVisible;
      if(!Overlay.el) return;
      Overlay.clear();
      // Re-render static anchors only when visible (dynamic click labels spawn on click regardless)
      if(!any) return;
      state.groups.labels.forEach(dot=>{
        const {x,y} = state.renderer.worldToScreen(dot.position);
        const d = document.createElement('div');
        d.className = 'overlay-label';
        d.textContent = dot.userData.label;
        d.style.left = (x|0)+'px';
        d.style.top  = (y|0)+'px';
        Overlay.el.appendChild(d);
      });
    }

    // ---------- Camera focuses ----------
    function focusView(where){
      const cam = state.renderer.camera;
      const ctr = state.renderer.controls;
      const tween = (from, to, dur=0.45)=> {
        let t=0; const start=from.clone();
        const off = state.renderer.addTicker(dt=>{
          t += dt; const k = Math.min(1, t/dur);
          from.lerpVectors(start, to, k);
          if(k>=1){ state.renderer._tickers.delete(off); }
        });
      };
      const focus = {
        annulus: new THREE.Vector3(0,0.22,0),
        aorta:   new THREE.Vector3(0.15,0.27,0.06),
        pap_al:  state.groups.pap.AL.position.clone(),
        pap_pm:  state.groups.pap.PM.position.clone(),
        reset:   new THREE.Vector3(0,0,0)
      }[where] || new THREE.Vector3(0,0,0);

      tween(ctr.target, focus, 0.4);
      if(where==='reset'){
        tween(cam.position, new THREE.Vector3(0.8,0.9,3.2), 0.6);
      }else{
        const dir = focus.clone().add(new THREE.Vector3(0.6,0.5,1.2));
        tween(cam.position, dir, 0.6);
      }
    }

    // ---------- AI Copilot (Training steps) ----------
    let engine = null; let lastClickKey = null;
    function setMode(m){
      state.mode = m;
      Util.toast('Mode: ' + m);
      Overlay.clear();
      if(m==='training'){ setupTraining(); state.ui.task.textContent = 'Follow copilot instructions'; }
      if(m==='practice'){ startPracticeRound(); }
      if(m==='quiz'){ startQuiz(); }
    }

    function setupTraining(){
      engine = new StepEngine([
        {
          id:'orient', title:'Orientation',
          details:'Orbit around the heart. Press F to focus on the annulus.',
          goal: () => true,
          onEnter: () => { Voice.speak('Welcome to Anatomical Mastery. Orbit to orient yourself. Press F to focus on the annulus.'); hintAnnulus(); }
        },
        {
          id:'annulus', title:'Identify the Mitral Annulus',
          details:'Click the green ring (mitral annulus).',
          goal: () => lastClickKey === 'annulus',
          onEnter: () => { Voice.speak('Click on the mitral annulus.'); highlightObject(state.groups.annulus); }
        },
        {
          id:'leaflet_a', title:'Identify Anterior Leaflet',
          details:'Click the anterior leaflet (toward LVOT/AMC).',
          goal: () => lastClickKey === 'leaflet_A',
          onEnter: () => { Voice.speak('Identify the anterior leaflet near the LVOT and AMC.'); highlightObject(state.groups.leaflets.A); }
        },
        {
          id:'leaflet_p', title:'Identify Posterior Leaflet',
          details:'Click the posterior leaflet (scalloped, near circumflex).',
          goal: () => lastClickKey === 'leaflet_P',
          onEnter: () => { Voice.speak('Identify the posterior leaflet.'); highlightObject(state.groups.leaflets.P); }
        },
        {
          id:'segments', title:'Segments A2 and P2',
          details:'Click A2, then P2 segment pads.',
          goal: () => lastClickKey === 'p2', // step advances after P2
          onEnter: () => { Voice.speak('Click A2 first, then P2.'); pulseSegment('A2'); },
          onExit: () => clearSegmentPulse()
        },
        {
          id:'pap', title:'Papillary Muscles',
          details:'Click Anterolateral (AL), then Posteromedial (PM) papillary muscles.',
          goal: () => lastClickKey === 'pap_pm',
          onEnter: () => { Voice.speak('Click anterolateral, then posteromedial papillary muscles.'); highlightObject(state.groups.pap.AL); },
        },
        {
          id:'chordae', title:'Chordae Tendineae',
          details:'Click a yellow chordae strand.',
          goal: () => lastClickKey === 'chordae',
          onEnter: () => { Voice.speak('Click on the chordae.'); }
        },
        {
          id:'conduction', title:'Conduction Proximity',
          details:'Toggle Zones layer ON and click the AMC marker.',
          goal: () => lastClickKey === 'amc',
          onEnter: () => { Voice.speak('Toggle zones. Be aware of conduction tissue near the aorto-mitral continuity. Click AMC.'); ensureZonesOn(); }
        },
        {
          id:'variation', title:'Variation Drill',
          details:'Apply Annular Dilatation variation, then click the annulus again.',
          goal: () => lastClickKey === 'annulus',
          onEnter: () => { Voice.speak('Apply annular dilatation, then re-identify the annulus.'); document.getElementById('variationSel').value='annular_dilation'; }
        }
      ], state);

      engine._enter();
      Bus.on('coach:enter', ({step}) => renderCoach(step));
    }

    function hintAnnulus(){
      const ann = state.groups.annulus;
      const p = state.renderer.worldToScreen(ann.position.clone().add(new THREE.Vector3(0,0.16,0)));
      Overlay.addHint(p.x, p.y, 'Mitral Annulus');
    }

    function highlightObject(obj){
      if(!obj || !obj.material) return;
      const mat = obj.material;
      const base = mat.emissive ? mat.emissive.clone() : new THREE.Color(0,0,0);
      let t=0; const off = state.renderer.addTicker(dt=>{
        t += dt; const k = Math.sin(t*6)*0.5+0.5;
        if(mat.emissive) mat.emissive.setRGB(0.05 + 0.15*k, 0.08 + 0.1*k, 0.05);
        if(t>1.2){ state.renderer._tickers.delete(off); if(mat.emissive) mat.emissive.copy(base); }
      });
    }

    let segPulse = null;
    function pulseSegment(name='A2'){
      const pad = state.groups.segments.find(x => x.name===name);
      if(!pad) return;
      pad.material.opacity = 0.45; pad.material.needsUpdate = true;
      segPulse = pad;
    }
    function clearSegmentPulse(){ if(segPulse){ segPulse.material.opacity=0.15; segPulse=null; } }
    function ensureZonesOn(){
      const zonesBox = document.querySelector('input[data-layer="zones"]');
      if(zonesBox && !zonesBox.checked){ zonesBox.checked = true; toggleLayer('zones', true); }
    }

    function renderCoach(step){
      const el = document.getElementById('coachUI');
      el.innerHTML = '';
      const h = document.createElement('div'); h.textContent = step.title; el.appendChild(h);
      const d = document.createElement('div'); d.textContent = step.details; d.className = 'small'; el.appendChild(d);
    }

    // ---------- Practice / Quiz ----------
    const ALL_TASKS = [
      { key:'annulus', text:'Click the Mitral Annulus' },
      { key:'leaflet_A', text:'Click the Anterior Leaflet' },
      { key:'leaflet_P', text:'Click the Posterior Leaflet' },
      { key:'aorta', text:'Click the Aortic Root (LVOT vicinity)' },
      { key:'lvot', text:'Click the LVOT marker' },
      { key:'amc', text:'Click the Aorto‑Mitral Continuity (AMC)' },
      { key:'pap_al', text:'Click the Anterolateral Papillary Muscle' },
      { key:'pap_pm', text:'Click the Posteromedial Papillary Muscle' },
      { key:'chordae', text:'Click a Chordae strand' },
      { key:'a1', text:'Click segment A1' },
      { key:'a2', text:'Click segment A2' },
      { key:'a3', text:'Click segment A3' },
      { key:'p1', text:'Click segment P1' },
      { key:'p2', text:'Click segment P2' },
      { key:'p3', text:'Click segment P3' },
      { key:'lad', text:'Click the LAD (surrogate)' },
      { key:'cx', text:'Click the Circumflex (surrogate)' }
    ];

    function startPracticeRound(){
      state.practice = { asked:0, correct:0, streak:0, rt:[], score:0 };
      nextTask();
    }

    function startQuiz(){
      state.quiz = { total:10, asked:0, correct:0, rt:[], score:0 };
      nextTask(true);
    }

    function nextTask(quiz=false){
      const choices = ALL_TASKS;
      const t = choices[Math.floor(Math.random()*choices.length)];
      state.task = t; state.expectKey = t.key;
      state.ui.task.textContent = t.text;
      state.ui.feedback.textContent = '—';
      state.timers.t0 = performance.now();
      if(quiz){
        state.quiz.asked++;
      }else{
        state.practice.asked++;
      }
    }

    function evaluateSelection(key, label){
      const dt = (performance.now() - state.timers.t0)/1000;
      const quiz = (state.mode==='quiz');
      const correct = (key === state.expectKey);
      const ctx = quiz ? state.quiz : state.practice;

      if(correct){
        ctx.correct++; ctx.streak = (ctx.streak||0) + 1;
        state.ui.feedback.textContent = 'Correct: ' + (label || key);
        state.ui.feedback.classList.remove('score-bad'); state.ui.feedback.classList.add('score-good');
        Voice.speak('Correct');
      }else{
        ctx.streak = 0;
        state.ui.feedback.textContent = 'Incorrect (selected ' + (label||key) + '). Expected ' + state.task.text.replace('Click ','');
        state.ui.feedback.classList.remove('score-good'); state.ui.feedback.classList.add('score-bad');
        Voice.speak('Incorrect');
      }

      // Scoring model: base 10 per question; speed bonus up to +3; wrong −5
      let delta = correct ? 10 : -5;
      const speedBonus = Math.max(0, 3 - Math.min(3, dt)); // up to 3 points if <1s
      if(correct) delta += speedBonus;
      ctx.score = Math.max(0, (ctx.score||0) + delta);
      ctx.rt = ctx.rt || []; ctx.rt.push(dt);

      updateKPIs();

      // Continue
      if(quiz){
        if(state.quiz.asked >= state.quiz.total){
          finishQuiz();
        }else{
          nextTask(true);
        }
      }else{
        nextTask(false);
      }
    }

    function updateKPIs(){
      const quiz = (state.mode==='quiz');
      const ctx = quiz ? state.quiz : state.practice;
      const acc = (ctx.correct / Math.max(1, ctx.asked)) * 100;
      const avg = (ctx.rt.length ? ctx.rt.reduce((a,b)=>a+b,0)/ctx.rt.length : 0);
      state.metricsEls.acc.textContent   = (acc||0).toFixed(0) + '%';
      state.metricsEls.rt.textContent    = (avg?avg.toFixed(2)+' s':'— s');
      state.metricsEls.streak.textContent= (ctx.streak||0);
      state.metricsEls.score.textContent = (ctx.score||0).toFixed(0);
      // colorize score
      const cls = (acc>=90)?'score-good':(acc>=70)?'score-warn':'score-bad';
      state.metricsEls.acc.className = 'value ' + cls;
    }

    function finishQuiz(){
      const acc = (state.quiz.correct / Math.max(1, state.quiz.asked)) * 100;
      const score = state.quiz.score;
      const grade = letterFor(score, acc);
      state.ui.task.textContent = 'Quiz finished.';
      state.ui.feedback.textContent = `Summary — Correct: ${state.quiz.correct}/${state.quiz.asked}, Accuracy: ${acc.toFixed(0)}%, Score: ${score.toFixed(0)} (${grade})`;
      Voice.speak('Quiz complete.');
    }

    function letterFor(score, acc){
      if(score>=95 && acc>=90) return 'A+';
      if(score>=90) return 'A';
      if(score>=85) return 'A-';
      if(score>=80) return 'B+';
      if(score>=75) return 'B';
      if(score>=70) return 'B-';
      if(score>=60) return 'C';
      if(score>=50) return 'D';
      return 'F';
    }

    // ---------- Finish & Save ----------
    function saveProgress(){
      // Choose best of practice/quiz score; convert to 0..100
      const q = state.quiz?.score||0, p = state.practice?.score||0;
      const s = Math.max(q, p);
      const norm = Math.max(0, Math.min(100, s));
      const saved = Progress.load();
      saved['anatomy-recognition'] = { completed: true, score: norm };
      Progress.save(saved);
      state.ui.finishNote.innerHTML = 'Status: <b>Saved</b> (score ' + norm.toFixed(0) + ')';
      Util.toast('Saved to dashboard.');
    }

    // ---------- Utils for training ----------
    function feedback(msg){ state.ui.feedback.textContent = msg; }
    function renderCoachStep(title, details){
      const el = document.getElementById('coachUI');
      el.innerHTML = '';
      const h = document.createElement('div'); h.textContent = title; el.appendChild(h);
      const p = document.createElement('div'); p.textContent = details; p.className='small'; el.appendChild(p);
    }

    // ---------- Initial setup ----------
    setMode('training');
    updateLabelVisibility();

    // ---------- Window resize: update overlay labels ----------
    window.addEventListener('resize', ()=> { updateLabelVisibility(); });

  </script>
</body>
</html>
