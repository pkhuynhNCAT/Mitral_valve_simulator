<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>MitraSim ‚Äî Mitral Repair Suturing Trainer (Single‚ÄëFile)</title>
<meta name="description" content="Web-based mitral valve suturing simulation for surgical training and education, with AI co-pilot guidance and scoring." />
<style>
  :root{
    --bg:#0f1115; --panel:#161a22; --mid:#1c2130; --ink:#e5ecff; --muted:#9fb0d6;
    --accent:#5dd0ff; --good:#3bd671; --warn:#ffce3a; --bad:#ff6b6b; --drape:#0d3e2e;
    --ghost:#3a86ff; --ring:#d9d9d9; --leaflet:#e6f2ee; --calc:#b8860b; --pledget:#ffffff;
    --grid:#2b3242; --focus:#9af; --pill:#263149; --pillText:#cfe1ff;
  }
  html, body { height:100%; background:var(--bg); color:var(--ink); font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji"; }
  * { box-sizing:border-box; }
  #app { display:grid; grid-template-rows:auto 1fr auto; height:100%; }

  /* Header */
  header {
    display:grid; grid-template-columns: 1fr auto auto auto; gap:10px; align-items:center;
    padding:10px 14px; background:linear-gradient(180deg, #151925, #0f131d);
    border-bottom:1px solid #1f2533; position:sticky; top:0; z-index:5;
  }
  .brand { display:flex; align-items:center; gap:10px; font-weight:700; letter-spacing:0.5px; }
  .brand .logo { width:28px; height:28px; border-radius:6px; background:linear-gradient(135deg, #2fa8ff, #00e59b); display:grid; place-items:center; font-weight:900; color:#04111a; }
  .stats { display:flex; gap:10px; flex-wrap:wrap; }
  .pill { background:var(--pill); color:var(--pillText); border:1px solid #34405a; padding:6px 10px; border-radius:999px; font-size:13px; }
  .controls { display:flex; gap:8px; }
  button, .btnlike {
    background:var(--panel); color:var(--ink); border:1px solid #2d364a; padding:8px 12px; border-radius:8px; font-weight:600; cursor:pointer;
  }
  button:hover { border-color:#40517a; }
  button.primary { background:linear-gradient(135deg, #2fa8ff33, #00e59b33); border-color:#2fa8ff77; }
  button.danger { border-color:#6e2a2a; background:#311e1e; color:#ffdede; }
  button.ghost { background:transparent; border-color:#3a4661; }

  /* Main layout */
  main { display:grid; grid-template-columns: 260px 1fr 320px; gap:12px; padding:12px; }
  aside, .right { background:var(--panel); border:1px solid #20283a; border-radius:12px; padding:12px; }
  .stageWrap { background:var(--mid); border:1px solid #222a3e; border-radius:12px; position:relative; display:grid; }
  .stageTop { display:flex; gap:10px; align-items:center; padding:10px; border-bottom:1px solid #222a3e; }
  .stage { position:relative; overflow:hidden; border-bottom-left-radius:12px; border-bottom-right-radius:12px; }
  canvas { display:block; width:100%; height:100%; background: radial-gradient(1200px 700px at 50% 50%, #114a37, var(--drape) 60%, #093022); }
  #hud { position:absolute; inset:0; pointer-events:none; }
  .legend { display:flex; gap:8px; flex-wrap:wrap; }
  .legend .key { display:flex; gap:8px; align-items:center; font-size:12px; color:var(--muted); }
  .swatch { width:14px; height:14px; border-radius:3px; border:1px solid #0006; }
  .swatch.leaflet{ background:var(--leaflet); }
  .swatch.ring{ background:var(--ring); }
  .swatch.calc{ background:var(--calc); }
  .swatch.safe{ background:#a9ffcd; }
  .swatch.ghost{ background:#3a86ff; }
  .swatch.suture{ background:#c6e0ff; }
  .swatch.pledget{ background:#fff; }

  /* Left panel */
  .tool { border:1px solid #2e3446; background:#151b28; border-radius:10px; margin-bottom:12px; }
  .tool h3 { font-size:14px; letter-spacing:0.2px; font-weight:700; padding:10px; margin:0; border-bottom:1px solid #232a3b; color:#b8c6f0; }
  .toolBody { padding:10px; display:grid; gap:10px; }
  .row { display:grid; grid-template-columns: 1fr auto; gap:8px; align-items:center; }
  .row label { font-size:13px; color:#c2d0fb; }
  .row .kpi { font-weight:700; }
  .option { display:flex; gap:8px; align-items:center; }
  input[type="range"] { width:100%; }
  .radioRow { display:flex; gap:8px; flex-wrap:wrap; }
  .radioRow button { padding:8px 10px; border-radius:8px; border:1px solid #2c3650; background:#141a2a; }
  .radioRow button.active { border-color:#3a86ff; outline:1px solid #3a86ff66; background:#0e1628; }

  /* Right panel (Co-Pilot) */
  .copilot { display:grid; gap:10px; }
  .callout { background:#0d1629; border:1px solid #2a3754; border-radius:10px; padding:10px; }
  .callout h4 { margin:0 0 8px 0; font-size:14px; color:#a7c6ff; }
  .hint { background:#182239; border:1px dashed #39507c; padding:10px; border-radius:8px; color:#cfe1ff; }
  .todo { display:grid; gap:8px; }
  .step { background:#121827; border:1px solid #28324a; border-radius:8px; padding:10px; }
  .step.active { border-color:#3a86ff; box-shadow:0 0 0 1px #3a86ff55 inset; }
  .step.done { opacity:0.7; }
  .badge { font-size:11px; background:#0b2636; border:1px solid #2a5670; padding:2px 6px; border-radius:999px; margin-left:6px; color:#8fd4ff; }

  /* Footer */
  footer { display:flex; gap:10px; justify-content:space-between; align-items:center; padding:10px 14px; border-top:1px solid #1f2533; color:#9fb0d6; background:#0e121b; }
  .kbd { border:1px solid #2a3452; border-bottom-width:2px; padding:2px 6px; border-radius:6px; background:#151b2a; font-weight:700; font-size:12px; }

  /* Microhelpers */
  .flex { display:flex; gap:10px; align-items:center; }
  .grow { flex:1; }
  .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace; }
  .small { font-size:12px; color:#b6c5ef; }
  .muted { color:#9fb0d6; }
  .center { text-align:center; }

  /* Tooltip */
  .tooltip { position:relative; }
  .tooltip:hover::after{
    content:attr(data-tip);
    position:absolute; left:0; top:calc(100% + 6px);
    background:#0b1426; color:#cfe1ff; border:1px solid #29406b; padding:6px 8px; border-radius:6px; white-space:nowrap; z-index:10;
  }

  /* Responsive */
  @media (max-width: 1100px){
    main { grid-template-columns: 1fr; }
    .right { order:3; }
    aside { order:2; }
    .stageWrap { order:1; min-height:60vh; }
  }
</style>
</head>
<body>
<div id="app">
  <header>
    <div class="brand">
      <div class="logo">M</div>
      <div>
        <div>MitraSim ‚Äî Suturing Trainer</div>
        <div class="small muted">Posterior annuloplasty sutures (P1‚ÄìP3) ‚Äî single-file, no libs</div>
      </div>
    </div>

    <div class="stats">
      <div class="pill" id="kpiTimer">‚è± Time: 00:00</div>
      <div class="pill" id="kpiSutures">üßµ Sutures: 0</div>
      <div class="pill" id="kpiSpacing">‚Üî Avg Spacing: ‚Äî</div>
      <div class="pill" id="kpiDepth">‚¨á Avg Bite Depth: ‚Äî</div>
      <div class="pill" id="kpiTrauma">ü©∏ Tissue Trauma: 0</div>
      <div class="pill" id="kpiGap">‚ûñ Coaptation Gap: ‚Äî</div>
      <div class="pill" id="kpiScore">‚≠ê Score: ‚Äî/100</div>
    </div>

    <div class="controls">
      <button class="ghost tooltip" id="btnScreenshot" data-tip="Capture the operative field as PNG">üì∏ Screenshot</button>
      <button class="ghost tooltip" id="btnSave" data-tip="Save current case to your browser">üíæ Save</button>
      <button class="ghost tooltip" id="btnLoad" data-tip="Load saved case">üìÇ Load</button>
    </div>

    <div class="controls">
      <button class="primary" id="btnStart">‚ñ∂ Start Skill Drill</button>
      <button id="btnEnd">‚úÖ End & Score</button>
      <button class="danger" id="btnReset">‚ôª Reset Tissue</button>
    </div>
  </header>

  <main>
    <!-- Left: Instruments & Settings -->
    <aside>
      <div class="tool">
        <h3>Instruments</h3>
        <div class="toolBody">
          <div class="radioRow" id="instrumentRow">
            <button data-tool="needle" class="active">ü™° Needle Driver <span class="badge">N</span></button>
            <button data-tool="forceps">üîó Forceps <span class="badge">F</span></button>
            <button data-tool="scissors">‚úÇ Scissors</button>
          </div>
          <div class="row">
            <label>Needle Curvature</label>
            <div class="kpi" id="kpiCurv">3/8</div>
          </div>
          <input type="range" id="needleCurvature" min="0.30" max="0.50" step="0.01" value="0.375" />
          <div class="row">
            <label>Needle Angle vs Normal</label>
            <div class="kpi" id="kpiAngle">70¬∞</div>
          </div>
          <input type="range" id="needleAngle" min="40" max="100" step="1" value="70" />
          <div class="row">
            <label>Suture Tension</label>
            <div class="kpi" id="kpiTension">0.00 N</div>
          </div>
          <input type="range" id="tension" min="0" max="12" step="0.1" value="0" />
          <div class="option">
            <input type="checkbox" id="pledget" />
            <label for="pledget">Use pledget</label>
          </div>
          <div class="option">
            <input type="checkbox" id="ghostTargets" checked />
            <label for="ghostTargets">Show ideal targets</label>
          </div>
        </div>
      </div>

      <div class="tool">
        <h3>Scenario</h3>
        <div class="toolBody">
          <div class="row"><label>Difficulty</label>
            <div class="radioRow" id="difficultyRow">
              <button data-diff="resident" class="active">Resident</button>
              <button data-diff="fellow">Fellow</button>
              <button data-diff="attending">Attending</button>
            </div>
          </div>
          <div class="row"><label>Calcification</label>
            <div class="radioRow" id="calcRow">
              <button data-calc="none" class="active">None</button>
              <button data-calc="posterior">Posterior</button>
              <button data-calc="anterior">Anterior</button>
            </div>
          </div>
          <div class="row">
            <label>Annulus size</label>
            <div class="kpi" id="kpiAnnulus">32 mm</div>
          </div>
          <input type="range" id="annulusSize" min="26" max="38" step="1" value="32" />
          <div class="row">
            <label>Target spacing</label>
            <div class="kpi" id="kpiTargetSpacing">4.0 mm</div>
          </div>
          <input type="range" id="targetSpacing" min="3" max="6" step="0.1" value="4.0" />
          <div class="row">
            <label>Target bite depth</label>
            <div class="kpi" id="kpiTargetDepth">3.5 mm</div>
          </div>
          <input type="range" id="targetDepth" min="2.5" max="5.0" step="0.1" value="3.5" />
        </div>
      </div>

      <div class="tool">
        <h3>Legend</h3>
        <div class="toolBody legend">
          <div class="key"><div class="swatch leaflet"></div> Leaflet</div>
          <div class="key"><div class="swatch ring"></div> Annulus</div>
          <div class="key"><div class="swatch calc"></div> Calcified zone</div>
          <div class="key"><div class="swatch safe"></div> Safe bite zone</div>
          <div class="key"><div class="swatch suture"></div> Suture</div>
          <div class="key"><div class="swatch pledget"></div> Pledget</div>
          <div class="key"><div class="swatch ghost"></div> AI suggestion</div>
        </div>
      </div>
    </aside>

    <!-- Center: Stage -->
    <div class="stageWrap">
      <div class="stageTop">
        <div class="flex grow">
          <div class="small">Task: Place interrupted posterior annuloplasty sutures (P1‚ÄìP3). Click to set <b>entry</b>, drag arc, click to set <b>exit</b>. Adjust <b>tension</b> to approximate coaptation without tearing.</div>
        </div>
        <div class="flex">
          <span class="small">Hotkeys: <span class="kbd">N</span> Needle <span class="kbd">F</span> Forceps <span class="kbd">R</span> Reset <span class="kbd">Space</span> Co‚ÄëPilot</span>
        </div>
      </div>
      <div class="stage">
        <canvas id="sim" width="1600" height="1000"></canvas>
        <svg id="hud" viewBox="0 0 1600 1000" aria-hidden="true"></svg>
      </div>
    </div>

    <!-- Right: AI Co-Pilot -->
    <div class="right">
      <div class="copilot">
        <div class="callout">
          <h4>AI Co‚ÄëPilot</h4>
          <div class="hint" id="hintBox">Welcome. Select <b>Needle Driver</b>. Set curvature ~ <b>3/8</b>, angle ~ <b>70¬∞</b>. Place your first bite in <b>P2</b> within <b>3‚Äì5 mm</b> of the annulus, perpendicular to the annular tangent.</div>
          <div class="flex">
            <button id="btnCoach">üí° Ask Co‚ÄëPilot</button>
            <button id="btnSpeak" class="ghost">üîä Voice</button>
            <button id="btnGhost" class="ghost">üëª Tog. Hints</button>
          </div>
        </div>

        <div class="callout">
          <h4>Checklist</h4>
          <div class="todo" id="todo">
            <div class="step active" data-step="1">1) Select needle driver and set needle curvature</div>
            <div class="step" data-step="2">2) Place posterior entry bite (3‚Äì5 mm from annulus)</div>
            <div class="step" data-step="3">3) Exit on corresponding anterior/posterior leaflet point</div>
            <div class="step" data-step="4">4) Optional: place pledget and tension gradually</div>
            <div class="step" data-step="5">5) Repeat along P1‚ÄìP3 with ~4 mm spacing</div>
            <div class="step" data-step="6">6) Assess coaptation gap and trauma; finalize</div>
          </div>
        </div>

        <div class="callout">
          <h4>Case Log</h4>
          <div id="log" class="small mono" style="max-height:220px; overflow:auto; background:#0b1222; border:1px solid #1e2945; border-radius:8px; padding:8px;"></div>
          <div class="flex">
            <button id="btnDownload">‚¨á Download Report</button>
            <button class="ghost" id="btnClearLog">üßπ Clear Log</button>
          </div>
        </div>

        <div class="callout small">
          <h4>Notes</h4>
          <div>‚Ä¢ This trainer simulates annular bites for ring annuloplasty (education only).<br>
               ‚Ä¢ The elastic leaflet mesh deforms with tension; excessive force causes tearing.<br>
               ‚Ä¢ Metrics follow OSATS-style domains + task metrics (spacing, bite depth, angle, trauma, time, coaptation gap).</div>
        </div>
      </div>
    </div>
  </main>

  <footer>
    <div class="small">¬© MitraSim (educational use only ‚Äî not a medical device). Expandable to chordal replacement / ring seating / valve replacement modules.</div>
    <div class="small">Build: single-file, no libs. Viewport: 1600√ó1000 canvas, mm scale shown in KPIs.</div>
  </footer>
</div>

<script>
/** ===============================
 *  MitraSim ‚Äî Single-file trainer
 *  (c) Educational use only
 *  ===============================
 *  High-level architecture
 *  - Stage (Canvas+SVG HUD)
 *  - Valve/Tissue model (ellipse annulus + leaflet mass-spring mesh)
 *  - Suture model (entry/exit, thread, pledget, spring link)
 *  - Physics (Hooke + damping + tear)
 *  - Copilot (heuristics + speech)
 *  - Scoring (OSATS + task metrics)
 *  - Persistence (localStorage), Report export, Screenshot
 */

// ---------- Globals & Utilities ----------
const App = {
  // View / scale
  W: 1600, H: 1000,
  pxPerMm: 5, // 1 mm = 5 px
  ctx: null, hud: null, canvas: null,
  running: true, last: performance.now(),
  // Instruments
  instrument: 'needle',
  // Scenario & Settings
  sizeMm: 32, // annulus mid diameter
  targetSpacingMm: 4.0,
  targetDepthMm: 3.5,
  calcPattern: 'none',
  difficulty: 'resident',
  // Needle params
  needleAngle: 70, // deg vs annulus normal
  needleCurvature: 0.375, // fraction of full circle
  tensionN: 0.0,
  pledget: false,
  showGhost: true,

  // Models
  valve: null, tissue: null, sutures: [], logs: [], ghosts: [],
  startTime: null, timerId: null,
  coaptationGapMm: null, score: null,
  metrics: {
    spacingMmArr: [], depthMmArr: [], angleArr: [], trauma: 0,
  },
  placing: { state:'idle', entry:null, exit:null, arc:null },
  speechOn:false,
};

function mmToPx(mm){ return mm * App.pxPerMm; }
function pxToMm(px){ return px / App.pxPerMm; }
function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
function lerp(a,b,t){ return a + (b-a)*t; }
function dist(a,b){ const dx=a.x-b.x, dy=a.y-b.y; return Math.hypot(dx,dy); }
function atan2n(y,x){ return Math.atan2(y,x); }

// Logging
function log(msg){ const t = App.startTime? ((Date.now()-App.startTime)/1000).toFixed(1)+'s' : '0.0s'; const line = `[${t}] ${msg}`; App.logs.push(line); renderLog(); }
function renderLog(){
  const el = document.getElementById('log');
  el.innerHTML = App.logs.slice(-200).map(l => l.replace(/</g,'&lt;')).join('<br/>');
  el.scrollTop = el.scrollHeight;
}

// ---------- Valve & Tissue Model (Ellipse + Mesh) ----------
function buildValve(){
  // Center in canvas
  const cx = App.W * 0.5, cy = App.H * 0.52;
  // Map annulus mm -> ellipse rx, ry (approx 32 mm AP x ~40 mm ML relationship)
  // We set ML ~ sizeMm + 6, AP ~ sizeMm - 6 to get mitral-like ellipse
  const ML = App.sizeMm + 6; // mediolateral (x)
  const AP = App.sizeMm - 6; // anteroposterior (y)
  const rx = mmToPx(ML*0.5), ry = mmToPx(AP*0.5);

  // Segmentation markers A1‚ÄìA3 / P1‚ÄìP3 along ellipse param t (0 at 3 o'clock)
  // We'll define standard: A segment anterior (upper), P posterior (lower)
  const segs = [
    { id:'A1', t: -Math.PI*0.15 }, { id:'A2', t: 0 }, { id:'A3', t: Math.PI*0.15 },
    { id:'P1', t: Math.PI - Math.PI*0.15 }, { id:'P2', t: Math.PI }, { id:'P3', t: Math.PI + Math.PI*0.15 },
  ];

  // Calcified zones (optional)
  let calcZones = [];
  if(App.calcPattern === 'posterior'){
    calcZones.push({ t0: Math.PI*0.88, t1: Math.PI*1.12 }); // near P2
  }else if(App.calcPattern === 'anterior'){
    calcZones.push({ t0: -Math.PI*0.22, t1: Math.PI*0.22 });
  }

  return { cx, cy, rx, ry, segs, calcZones };
}

function ellipsePoint(v, t){
  return { x: v.cx + v.rx*Math.cos(t), y: v.cy + v.ry*Math.sin(t) };
}
function ellipseTangent(v, t){
  // derivative ( -rx sin t, ry cos t )
  const tx = -v.rx*Math.sin(t), ty =  v.ry*Math.cos(t);
  const m = Math.hypot(tx,ty) || 1;
  return { x: tx/m, y: ty/m };
}
function ellipseNormal(v, t){
  // normal direction for ellipse (not unit-length)
  const nx = Math.cos(t)/v.rx, ny = Math.sin(t)/v.ry;
  const l = Math.hypot(nx,ny) || 1;
  return { x: nx/l, y: ny/l };
}
function ellipseParamForPoint(v, p){
  // approximate param angle using normalized coordinates
  const dx = (p.x - v.cx)/v.rx, dy = (p.y - v.cy)/v.ry;
  return Math.atan2(dy, dx);
}
function ellipseNormalizedRadius(v, p){
  const dx = (p.x - v.cx), dy = (p.y - v.cy);
  return Math.sqrt( (dx*dx)/(v.rx*v.rx) + (dy*dy)/(v.ry*v.ry) ); // 1 at boundary
}

// Build leaflet mesh (mass-spring) within the ellipse
function buildTissueMesh(v){
  const nodes = [], springs = [];
  const nx = 42, ny = 28; // grid resolution; tuned for perf/quality
  const xmin = v.cx - v.rx, xmax = v.cx + v.rx;
  const ymin = v.cy - v.ry, ymax = v.cy + v.ry;
  const dx = (xmax-xmin)/(nx-1), dy = (ymax-ymin)/(ny-1);

  const index = (ix,iy)=> iy*nx + ix;
  for(let iy=0; iy<ny; iy++){
    for(let ix=0; ix<nx; ix++){
      const x = xmin + ix*dx, y = ymin + iy*dy;
      const r = ellipseNormalizedRadius(v, {x,y});
      if(r<=1.01){ // inside ellipse
        // Type: boundary near annulus (pin), interior leaflet
        const pinned = (Math.abs(r-1) < 0.025); // pins on annulus line
        nodes.push({ x, y, vx:0, vy:0, mass: pinned? 1 : 1, pinned, dmg:0, type: pinned? 'annulus':'leaflet' });
      }else{
        nodes.push(null);
      }
    }
  }
  // Springs (4-neighborhood + diagonals for stability)
  const kLeaf = 24; // stiffness arbitrary tuned
  for(let iy=0; iy<ny; iy++){
    for(let ix=0; ix<nx; ix++){
      const i = index(ix,iy); if(!nodes[i]) continue;
      const here = nodes[i];
      const neigh = [[1,0],[0,1],[1,1],[1,-1]];
      for(const [dxi,dyi] of neigh){
        const jx = ix+dxi, jy = iy+dyi;
        if(jx<0||jx>=nx||jy<0||jy>=ny) continue;
        const j = index(jx,jy); if(!nodes[j]) continue;
        const other = nodes[j];
        const L = Math.hypot(other.x - here.x, other.y - here.y);
        springs.push({ i, j, L0: L, k: kLeaf, d: 1.2, broken:false }); // damping d
      }
    }
  }
  return { nodes, springs, nx, ny };
}

// ---------- Sutures ----------
function makeSuture(entry, exit, needle){
  // entry/exit: {x,y, nodeIdx}
  const id = 'S' + (App.sutures.length+1);
  const pledget = App.pledget;
  const tensionN = App.tensionN;
  const curvature = App.needleCurvature, angle = App.needleAngle;
  const arc = computeNeedleArc(entry, exit, curvature, angle);
  // Suture spring (connect node indices) adds deforming constraint
  const sSpring = { i: entry.nodeIdx, j: exit.nodeIdx, L0: dist(entry, exit)*0.8, k: 40, d: 1.6, broken:false };
  const stitch = { id, entry, exit, arc, pledget, tensionN, curvature, angle, spring: sSpring, tied:false,
                   metrics: assessSingleSutureMetrics(entry, exit, angle) };
  App.sutures.push(stitch);
  App.tissue.springs.push(sSpring);
  log(`Placed ${id}: depth=${stitch.metrics.depthMm.toFixed(1)}mm spacing‚âà${stitch.metrics.spacingMm?.toFixed(1)??'‚Äî'}mm angleŒî=${stitch.metrics.angleDeltaDeg.toFixed(0)}¬∞`);
  updateKPI();
  return stitch;
}

function computeNeedleArc(p1, p2, curvatureFrac, needleAngleDeg){
  // Visual-only curve approximating a curved needle pass.
  // We'll build a cubic Bezier: control points offset from the chord by angle-normal.
  const mid = { x:(p1.x+p2.x)/2, y:(p1.y+p2.y)/2 };
  const chord = { x: p2.x - p1.x, y: p2.y - p1.y };
  const len = Math.hypot(chord.x, chord.y) || 1;
  const nx = -chord.y/len, ny = chord.x/len; // normal to chord
  const bulge = len * (0.35 + 0.45*(curvatureFrac-0.3)); // curvature-based
  const angleRad = (needleAngleDeg-90) * Math.PI/180;
  const rot = Math.cos(angleRad)*1.0;
  const c1 = { x: p1.x + chord.x*0.25 + nx*bulge*rot, y: p1.y + chord.y*0.25 + ny*bulge*rot };
  const c2 = { x: p2.x - chord.x*0.25 + nx*bulge*rot, y: p2.y - chord.y*0.25 + ny*bulge*rot };
  return { p1, c1, c2, p2 };
}

// ---------- Physics ----------
function stepPhysics(dt){
  const t = App.tissue;
  const g = 0.0; // microgravity none
  // Integrate springs
  for(const s of t.springs){
    if(s.broken) continue;
    const a = t.nodes[s.i], b = t.nodes[s.j]; if(!a||!b) continue;
    const dx = b.x - a.x, dy = b.y - a.y;
    const L = Math.hypot(dx,dy) || 1;
    const ex = dx/L, ey = dy/L;
    const vrel = ( (b.vx - a.vx)*ex + (b.vy - a.vy)*ey );
    const F = s.k*(L - s.L0) + s.d*vrel;
    const fx = F*ex, fy = F*ey;

    if(!a.pinned){ a.vx += fx/a.mass*dt; a.vy += fy/a.mass*dt; }
    if(!b.pinned){ b.vx -= fx/b.mass*dt; b.vy -= fy/b.mass*dt; }

    // Tear check (only for leaflet springs)
    if( (a.type==='leaflet' || b.type==='leaflet') && L > s.L0*1.6 ){ // threshold
      s.broken = true;
      if(a.type==='leaflet') a.dmg++;
      if(b.type==='leaflet') b.dmg++;
      App.metrics.trauma++;
      log(`‚ö† Tissue tear near suture (spring broken)`);
      updateKPI();
    }
  }
  // Apply tension from sutures (reduce spring rest length with tension)
  for(const st of App.sutures){
    const s = st.spring;
    if(s.broken) continue;
    const tension = clamp(App.tensionN, 0, 12);
    s.L0 = Math.max(1, s.L0 * (1 - 0.0005 * tension)); // slowly tighten
    // Over-tension check: break suture or local tissue
    if(tension>8){
      // High tension raises tear chance ‚Äî handled by spring elongation already
    }
  }
  // Integrate motion
  for(const n of t.nodes){
    if(!n) continue;
    if(n.pinned) { n.vx=0; n.vy=0; continue; }
    // damping
    n.vx *= 0.985; n.vy *= 0.985;
    n.vy += g*dt;
    n.x += n.vx*dt; n.y += n.vy*dt;
  }
}

// ---------- Drawing ----------
function draw(){
  const ctx = App.ctx, v = App.valve, t = App.tissue;
  ctx.clearRect(0,0,App.W,App.H);
  // Drape vignette drawn by canvas bg

  // Annulus (ring)
  ctx.save();
  ctx.strokeStyle = '#d9d9d9'; ctx.lineWidth = 3;
  ctx.beginPath();
  for(let i=0;i<=240;i++){
    const th = i/240 * Math.PI*2;
    const p = ellipsePoint(v, th);
    if(i===0) ctx.moveTo(p.x,p.y); else ctx.lineTo(p.x,p.y);
  }
  ctx.stroke();

  // Safe zone band (3‚Äì5 mm inside annulus)
  for(const band of [3,5]){
    ctx.beginPath();
    const rxf = (v.rx - mmToPx(band)), ryf = (v.ry - mmToPx(band));
    for(let i=0;i<=200;i++){
      const th = i/200 * Math.PI*2;
      const x = v.cx + rxf*Math.cos(th), y = v.cy + ryf*Math.sin(th);
      if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    ctx.strokeStyle = band===3? 'rgba(169,255,205,0.45)' : 'rgba(169,255,205,0.15)';
    ctx.lineWidth = band===3? 2:1; ctx.setLineDash(band===3?[5,5]:[2,6]);
    ctx.stroke(); ctx.setLineDash([]);
  }

  // Calcified patches
  for(const cz of v.calcZones){
    ctx.beginPath();
    for(let i=0;i<=64;i++){
      const th = cz.t0 + (cz.t1-cz.t0)*i/64;
      const p = ellipsePoint(v, th);
      if(i===0) ctx.moveTo(p.x,p.y); else ctx.lineTo(p.x,p.y);
    }
    ctx.strokeStyle = 'rgba(184,134,11,0.9)'; ctx.lineWidth=6; ctx.stroke();
  }

  // Leaflet mesh (filled light)
  ctx.beginPath();
  // Clip to ellipse
  const path = new Path2D();
  for(let i=0;i<=220;i++){
    const th = i/220 * Math.PI*2;
    const p = ellipsePoint(v, th);
    if(i===0) path.moveTo(p.x,p.y); else path.lineTo(p.x,p.y);
  }
  path.closePath();
  ctx.save(); ctx.clip(path);
  // draw nodes as subtle shading
  ctx.fillStyle = '#e6f2ee';
  ctx.globalAlpha = 0.7;
  ctx.fillRect(v.cx - v.rx, v.cy - v.ry, v.rx*2, v.ry*2);
  ctx.globalAlpha = 1;

  // Mesh lines
  ctx.strokeStyle = 'rgba(40,52,70,0.7)'; ctx.lineWidth=1;
  for(const s of t.springs){
    if(s.broken) continue;
    const a = t.nodes[s.i], b = t.nodes[s.j]; if(!a||!b) continue;
    // only draw leaflet springs
    if(a.type==='annulus' && b.type==='annulus') continue;
    ctx.beginPath(); ctx.moveTo(a.x,a.y); ctx.lineTo(b.x,b.y); ctx.stroke();
  }
  ctx.restore();

  // Chordae (for realism; static anchors)
  drawChordae(ctx, v);

  // Segments labels
  drawSegments(ctx, v);

  // Sutures
  for(const st of App.sutures){
    drawSuture(ctx, st);
  }

  // Placing preview
  if(App.placing.state==='entry-set' && App.placing.arc){
    drawBezier(ctx, App.placing.arc, '#cfe3ff', 2, [6,4]);
  }

  // HUD overlay (SVG) for ghost targets and highlights
  renderHUD();
}

function drawSegments(ctx, v){
  ctx.save();
  ctx.font = '700 16px ui-sans-serif, system-ui';
  ctx.textAlign='center'; ctx.textBaseline='middle';
  for(const s of v.segs){
    const p = ellipsePoint(v, s.t);
    // label outside ring
    const r = 28;
    const dir = ellipseNormal(v, s.t);
    const lx = p.x + dir.x*mmToPx(8), ly = p.y + dir.y*mmToPx(8);
    ctx.fillStyle = '#b8c6f0';
    ctx.fillText(s.id, lx, ly);
  }
  ctx.restore();
}

function drawChordae(ctx, v){
  ctx.save();
  ctx.strokeStyle = 'rgba(120,120,120,0.8)'; ctx.lineWidth = 2;
  const pap1 = { x: v.cx - mmToPx(10), y: v.cy + mmToPx(18) };
  const pap2 = { x: v.cx + mmToPx(10), y: v.cy + mmToPx(18) };
  const attach = [
    ellipsePoint(v, Math.PI*0.85),
    ellipsePoint(v, Math.PI*1.0),
    ellipsePoint(v, Math.PI*1.15),
  ];
  for(const a of attach){
    ctx.beginPath(); ctx.moveTo(pap1.x, pap1.y); ctx.lineTo(a.x, a.y); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(pap2.x, pap2.y); ctx.lineTo(a.x, a.y); ctx.stroke();
  }
  ctx.restore();
}

function drawBezier(ctx, bez, color, w=3, dash=null){
  ctx.save();
  ctx.beginPath();
  ctx.moveTo(bez.p1.x, bez.p1.y);
  ctx.bezierCurveTo(bez.c1.x, bez.c1.y, bez.c2.x, bez.c2.y, bez.p2.x, bez.p2.y);
  ctx.strokeStyle = color; ctx.lineWidth = w;
  if(dash){ ctx.setLineDash(dash); }
  ctx.stroke();
  ctx.restore();
}

function drawSuture(ctx, st){
  // Thread
  drawBezier(ctx, st.arc, '#c6e0ff', 3);
  // Entry/Exit points
  ctx.save();
  ctx.fillStyle = '#c6e0ff';
  for(const p of [st.entry, st.exit]){
    ctx.beginPath(); ctx.arc(p.x,p.y, 5, 0, Math.PI*2); ctx.fill();
  }
  // Pledget
  if(st.pledget){
    ctx.fillStyle = '#ffffff'; ctx.strokeStyle='#284a7a'; ctx.lineWidth=1.5;
    ctx.beginPath(); ctx.roundRect( (st.entry.x+st.exit.x)/2 - 8, (st.entry.y+st.exit.y)/2 - 5, 16, 10, 2 ); ctx.fill(); ctx.stroke();
  }
  ctx.restore();
}

// ---------- HUD (ghost targets, highlights) ----------
function renderHUD(){
  const svg = App.hud; svg.innerHTML = '';
  if(!App.showGhost) return;
  const v = App.valve;
  // Generate ideal posterior targets every targetSpacing along P1‚ÄìP3 arc
  const tStart = Math.PI*0.82, tEnd = Math.PI*1.18;
  const spacingPx = mmToPx(App.targetSpacingMm);
  let prev = null;
  for(let th=tStart; th<=tEnd; th+=0.008){
    const p = ellipsePoint(v, th);
    if(!prev){ prev = p; continue; }
    if(Math.hypot(p.x-prev.x, p.y-prev.y) >= spacingPx){
      // Ghost target at 3.5 mm inside annulus
      const inx = p.x - ellipseNormal(v, th).x*mmToPx(App.targetDepthMm);
      const iny = p.y - ellipseNormal(v, th).y*mmToPx(App.targetDepthMm);
      const d = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
      d.setAttribute('cx', inx); d.setAttribute('cy', iny);
      d.setAttribute('r', 5); d.setAttribute('fill', '#3a86ff'); d.setAttribute('fill-opacity','0.8');
      svg.appendChild(d);
      prev = p;
    }
  }
}

// ---------- Metrics & Scoring ----------
function assessSingleSutureMetrics(entry, exit, angleDeg){
  // Bite depth: distance from annulus along normal
  const v = App.valve;
  const tEntry = ellipseParamForPoint(v, entry);
  const annPt = ellipsePoint(v, tEntry);
  const depthPx = Math.hypot(entry.x - annPt.x, entry.y - annPt.y);
  const depthMm = pxToMm(depthPx);

  // Angle vs normal at entry
  const n = ellipseNormal(v, tEntry);
  // We don't know true needle vector; approximate using angle slider vs ideal 90
  const angleDelta = Math.abs(angleDeg - 90);

  // Spacing to previous suture along annulus arc (posterior)
  let spacingMm = null;
  if(App.sutures.length>0){
    const last = App.sutures[App.sutures.length-1];
    const tPrev = ellipseParamForPoint(v, last.entry);
    // approximate arc length by parameter difference scaled by ellipse
    const arc = approxArcLen(v, tPrev, tEntry);
    spacingMm = pxToMm(arc);
  }

  return { depthMm, spacingMm, angleDeltaDeg: angleDelta };
}

function approxArcLen(v, t0, t1){
  // numeric integration of small segments
  const steps = 24;
  let L = 0;
  for(let i=0;i<steps;i++){
    const tA = lerp(t0,t1,i/steps), tB = lerp(t0,t1,(i+1)/steps);
    const pA = ellipsePoint(v, tA), pB = ellipsePoint(v, tB);
    L += Math.hypot(pB.x-pA.x, pB.y-pA.y);
  }
  return Math.abs(L);
}

function computeCoaptationGap(){
  // Simple proxy: distance between A2 and P2 inner edges after deformation
  const v = App.valve;
  const pA = ellipsePoint(v, 0); // A2
  const pP = ellipsePoint(v, Math.PI); // P2
  // Pull 4 mm inward for leaflet free edge approximation
  function inward(p, t){ const n = ellipseNormal(v, t); return { x: p.x - n.x*mmToPx(4), y: p.y - n.y*mmToPx(4) }; }
  const a = inward(pA, 0), b = inward(pP, Math.PI);
  const gapPx = dist(a,b);
  return pxToMm(gapPx);
}

function computeScore(final=false){
  const M = App.metrics;
  const w = { spacing:0.22, depth:0.18, angle:0.15, trauma:0.20, time:0.10, coaptation:0.15 };
  // Spacing: closeness to targetSpacing
  const sSpacing = avgScore(M.spacingMmArr.map(x => penaltyAbs(x, App.targetSpacingMm, 1.0)));
  // Depth: closeness to target depth
  const sDepth = avgScore(M.depthMmArr.map(x => penaltyAbs(x, App.targetDepthMm, 0.8)));
  // Angle: closeness to 90 deg (perpendicular)
  const sAngle = avgScore(M.angleArr.map(x => penaltyAbs(90-x, 0, 0.6)));
  // Trauma: fewer tears better (0 tears => 1.0)
  const sTrauma = Math.max(0, 1.0 - (M.trauma * 0.07));
  // Time: under 300s is good
  const tElapsed = App.startTime ? (Date.now()-App.startTime)/1000 : 0;
  const sTime = clamp(1.0 - Math.max(0, (tElapsed-300)/300), 0, 1);
  // Coaptation: smaller gap better; <=2mm ideal, >=6mm poor
  const gap = App.coaptationGapMm ?? computeCoaptationGap();
  const sCoap = clamp( (6 - clamp(gap,2,6)) / 4, 0, 1);

  const score = Math.round(100*( w.spacing*sSpacing + w.depth*sDepth + w.angle*sAngle + w.trauma*sTrauma + w.time*sTime + w.coaptation*sCoap ));
  return { score, breakdown:{sSpacing, sDepth, sAngle, sTrauma, sTime, sCoap}, elapsed:tElapsed };
}
function penaltyAbs(val, target, tolerance){
  // Return 1 at target, linear drop with abs error; reach 0 at ~ (target¬±tolerance*2)
  const err = Math.abs(val - target);
  const s = clamp(1 - err/(tolerance*2), 0, 1);
  return s;
}
function avgScore(arr){
  if(!arr || arr.length===0) return 0.5;
  const s = arr.reduce((a,b)=>a+b,0)/arr.length;
  return clamp(s,0,1);
}

// ---------- Input & Interaction ----------
function onCanvasDown(e){
  if(App.instrument!=='needle') return;
  const p = getMousePos(e);
  if(App.placing.state==='idle'){
    const entryNode = findNearestLeafletNode(p);
    if(!entryNode) return;
    App.placing.entry = { x: entryNode.x, y: entryNode.y, nodeIdx: entryNode.idx };
    App.placing.state='entry-set';
    advanceChecklist(2);
    log(`Entry set @ (${pxToMm(p.x).toFixed(1)}mm, ${pxToMm(p.y).toFixed(1)}mm)`);
  }else if(App.placing.state==='entry-set'){
    const exitNode = findNearestLeafletNode(p);
    if(!exitNode) return;
    App.placing.exit = { x: exitNode.x, y: exitNode.y, nodeIdx: exitNode.idx };
    // create suture
    const st = makeSuture(App.placing.entry, App.placing.exit, { angle:App.needleAngle, curv:App.needleCurvature });
    App.placing = { state:'idle', entry:null, exit:null, arc:null };
    // record metrics arrays
    App.metrics.depthMmArr.push(st.metrics.depthMm);
    if(st.metrics.spacingMm!=null) App.metrics.spacingMmArr.push(st.metrics.spacingMm);
    App.metrics.angleArr.push(90 - st.metrics.angleDeltaDeg);
    updateKPI();
    advanceChecklist(3);
    coachIfNeeded();
  }
}
function onCanvasMove(e){
  if(App.placing.state==='entry-set'){
    const p = getMousePos(e);
    const fakeExit = { x:p.x, y:p.y, nodeIdx: findNearestLeafletNode(p)?.idx ?? null };
    App.placing.arc = computeNeedleArc(App.placing.entry, fakeExit, App.needleCurvature, App.needleAngle);
  }
}
function findNearestLeafletNode(p){
  const t = App.tissue;
  let best=null, bi=-1, bd=1e9;
  for(let i=0;i<t.nodes.length;i++){
    const n = t.nodes[i]; if(!n||n.type!=='leaflet') continue;
    const d = Math.hypot(n.x - p.x, n.y - p.y);
    if(d<bd){ bd=d; best=n; bi=i; }
  }
  if(bd>18) return null; // require proximity
  best.idx = bi;
  return best;
}
function getMousePos(e){
  const rect = App.canvas.getBoundingClientRect();
  const x = (e.clientX - rect.left)* (App.canvas.width/rect.width);
  const y = (e.clientY - rect.top) * (App.canvas.height/rect.height);
  return {x,y};
}

// ---------- UI Wiring ----------
function updateKPI(){
  document.getElementById('kpiSutures').textContent = `üßµ Sutures: ${App.sutures.length}`;
  const avgSpacing = App.metrics.spacingMmArr.length? (App.metrics.spacingMmArr.reduce((a,b)=>a+b,0)/App.metrics.spacingMmArr.length).toFixed(1)+' mm' : '‚Äî';
  const avgDepth = App.metrics.depthMmArr.length? (App.metrics.depthMmArr.reduce((a,b)=>a+b,0)/App.metrics.depthMmArr.length).toFixed(1)+' mm' : '‚Äî';
  document.getElementById('kpiSpacing').textContent = `‚Üî Avg Spacing: ${avgSpacing}`;
  document.getElementById('kpiDepth').textContent = `‚¨á Avg Bite Depth: ${avgDepth}`;
  document.getElementById('kpiTrauma').textContent = `ü©∏ Tissue Trauma: ${App.metrics.trauma}`;
  App.coaptationGapMm = computeCoaptationGap();
  document.getElementById('kpiGap').textContent = `‚ûñ Coaptation Gap: ${App.coaptationGapMm.toFixed(1)} mm`;
  const {score} = computeScore();
  App.score = score;
  document.getElementById('kpiScore').textContent = `‚≠ê Score: ${score}/100`;
}

function startTimer(){
  App.startTime = Date.now();
  const f = ()=>{
    const s = Math.floor((Date.now()-App.startTime)/1000);
    const mm = String(Math.floor(s/60)).padStart(2,'0');
    const ss = String(s%60).padStart(2,'0');
    document.getElementById('kpiTimer').textContent = `‚è± Time: ${mm}:${ss}`;
  };
  clearInterval(App.timerId);
  App.timerId = setInterval(f, 500);
}

function setInstrument(name){
  App.instrument = name;
  document.querySelectorAll('#instrumentRow button').forEach(b=> b.classList.toggle('active', b.dataset.tool===name));
  log(`Instrument: ${name}`);
}
function setDifficulty(level){
  App.difficulty = level;
  document.querySelectorAll('#difficultyRow button').forEach(b=> b.classList.toggle('active', b.dataset.diff===level));
  // Adjust stiffness/tear thresholds subtly (not exhaustive)
  for(const s of App.tissue.springs){ if(s.k && !s.userSet){ s.k = level==='resident'? 22 : level==='fellow'? 26 : 30; } }
  log(`Difficulty set: ${level}`);
}
function setCalc(pattern){
  App.calcPattern = pattern;
  document.querySelectorAll('#calcRow button').forEach(b=> b.classList.toggle('active', b.dataset.calc===pattern));
  App.valve = buildValve(); // rebuild to update calc zones
  log(`Calcification: ${pattern}`);
}

function coachSpeak(text){
  if(!App.speechOn) return;
  try{
    const u = new SpeechSynthesisUtterance(text.replace(/<[^>]+>/g,' '));
    u.rate = 1; u.pitch=1; speechSynthesis.speak(u);
  }catch(_){}
}

function setHint(html){ const el = document.getElementById('hintBox'); el.innerHTML = html; coachSpeak(html); }
function advanceChecklist(step){
  const items = Array.from(document.querySelectorAll('.step'));
  items.forEach(it=>{
    const idx = Number(it.dataset.step);
    it.classList.toggle('active', idx===step);
    if(idx<step) it.classList.add('done');
  });
}

function coachIfNeeded(){
  const last = App.sutures.at(-1); if(!last) return;
  const d = last.metrics.depthMm, s = last.metrics.spacingMm, a = 90 - last.metrics.angleDeltaDeg;
  let hint = [];
  if(d < App.targetDepthMm-0.6) hint.push(`Increase <b>bite depth</b> toward ${App.targetDepthMm.toFixed(1)} mm.`);
  if(d > App.targetDepthMm+0.8) hint.push(`Reduce <b>bite depth</b> to avoid leaflet <b>blanching</b>.`);
  if(s != null && Math.abs(s-App.targetSpacingMm)>0.8) hint.push(`Aim for <b>${App.targetSpacingMm.toFixed(1)} mm</b> spacing; consider clocking positions.`);
  if(Math.abs(a-90)>15) hint.push(`Enter more <b>perpendicular</b> to annulus (angle‚âà90¬∞).`);
  if(App.tensionN>8) hint.push(`Ease <b>tension</b>; risk of tearing.`);
  if(hint.length===0) hint = [`Good! Maintain technique across <b>P1‚ÄìP3</b>.`];
  setHint(hint.join(' '));
}

// ---------- Buttons & Hotkeys ----------
function bindUI(){
  // Instruments
  document.getElementById('instrumentRow').addEventListener('click', (e)=>{
    if(e.target.tagName!=='BUTTON') return;
    setInstrument(e.target.dataset.tool);
  });
  document.getElementById('difficultyRow').addEventListener('click', (e)=>{
    if(e.target.tagName!=='BUTTON') return;
    setDifficulty(e.target.dataset.diff);
  });
  document.getElementById('calcRow').addEventListener('click', (e)=>{
    if(e.target.tagName!=='BUTTON') return;
    setCalc(e.target.dataset.calc);
  });

  // Sliders
  const curv = document.getElementById('needleCurvature');
  curv.addEventListener('input', e=>{
    App.needleCurvature = Number(e.target.value);
    document.getElementById('kpiCurv').textContent = (Math.round(App.needleCurvature*8)/8).toFixed(3).replace(/\.000$/,'') ;
  });
  const ang = document.getElementById('needleAngle');
  ang.addEventListener('input', e=>{
    App.needleAngle = Number(e.target.value);
    document.getElementById('kpiAngle').textContent = `${App.needleAngle}¬∞`;
  });
  const ten = document.getElementById('tension');
  ten.addEventListener('input', e=>{
    App.tensionN = Number(e.target.value);
    document.getElementById('kpiTension').textContent = `${App.tensionN.toFixed(2)} N`;
  });
  const ann = document.getElementById('annulusSize');
  ann.addEventListener('input', e=>{
    App.sizeMm = Number(e.target.value);
    document.getElementById('kpiAnnulus').textContent = `${App.sizeMm} mm`;
    App.valve = buildValve();
  });
  const tsp = document.getElementById('targetSpacing');
  tsp.addEventListener('input', e=>{
    App.targetSpacingMm = Number(e.target.value);
    document.getElementById('kpiTargetSpacing').textContent = `${App.targetSpacingMm.toFixed(1)} mm`;
  });
  const tdp = document.getElementById('targetDepth');
  tdp.addEventListener('input', e=>{
    App.targetDepthMm = Number(e.target.value);
    document.getElementById('kpiTargetDepth').textContent = `${App.targetDepthMm.toFixed(1)} mm`;
  });
  document.getElementById('pledget').addEventListener('change', e=> App.pledget = e.target.checked);
  document.getElementById('ghostTargets').addEventListener('change', e=> App.showGhost = e.target.checked);

  // Stage mouse
  App.canvas.addEventListener('mousedown', onCanvasDown);
  App.canvas.addEventListener('mousemove', onCanvasMove);

  // Core buttons
  document.getElementById('btnStart').addEventListener('click', ()=>{
    if(!App.startTime){ startTimer(); log('Skill drill started.'); setHint('Proceed with <b>P2</b> bite. Avoid calcified patches, maintain spacing.'); }
  });
  document.getElementById('btnEnd').addEventListener('click', ()=>{
    const {score, breakdown, elapsed} = computeScore(true);
    App.score = score;
    const msg = `Final Score: ${score}/100 ‚Ä¢ Spacing ${(breakdown.sSpacing*100|0)}% ‚Ä¢ Depth ${(breakdown.sDepth*100|0)}% ‚Ä¢ Angle ${(breakdown.sAngle*100|0)}% ‚Ä¢ Trauma ${(breakdown.sTrauma*100|0)}% ‚Ä¢ Time ${(breakdown.sTime*100|0)}% ‚Ä¢ Coaptation ${(breakdown.sCoap*100|0)}% ‚Ä¢ Time ${elapsed.toFixed(1)}s`;
    log(msg);
    setHint(msg);
  });
  document.getElementById('btnReset').addEventListener('click', resetAll);

  // Copilot
  document.getElementById('btnCoach').addEventListener('click', coachIfNeeded);
  document.getElementById('btnSpeak').addEventListener('click', ()=>{
    App.speechOn = !App.speechOn;
    document.getElementById('btnSpeak').textContent = App.speechOn? 'üîá Voice' : 'üîä Voice';
    if(App.speechOn) coachSpeak(document.getElementById('hintBox').innerText);
  });
  document.getElementById('btnGhost').addEventListener('click', ()=>{
    App.showGhost = !App.showGhost;
    renderHUD();
  });

  // Save/Load/Report/Screenshot
  document.getElementById('btnSave').addEventListener('click', saveState);
  document.getElementById('btnLoad').addEventListener('click', loadState);
  document.getElementById('btnDownload').addEventListener('click', downloadReport);
  document.getElementById('btnClearLog').addEventListener('click', ()=>{ App.logs = []; renderLog(); });
  document.getElementById('btnScreenshot').addEventListener('click', screenshot);

  // Hotkeys
  window.addEventListener('keydown', (e)=>{
    if(e.code==='KeyN'){ setInstrument('needle'); }
    else if(e.code==='KeyF'){ setInstrument('forceps'); }
    else if(e.code==='KeyR'){ resetAll(); }
    else if(e.code==='Space'){ App.showGhost = !App.showGhost; renderHUD(); }
  });
}

// ---------- Persistence & Report ----------
function saveState(){
  const data = {
    sizeMm:App.sizeMm, targetSpacingMm:App.targetSpacingMm, targetDepthMm:App.targetDepthMm,
    calcPattern:App.calcPattern, difficulty:App.difficulty,
    sutures: App.sutures.map(s=>({entry:s.entry, exit:s.exit, angle:s.angle, curvature:s.curvature, pledget:s.pledget})),
    metrics: App.metrics, logs: App.logs, startOffset: App.startTime? Date.now()-App.startTime : null
  };
  localStorage.setItem('mitrasim_save', JSON.stringify(data));
  log('üíæ Case saved to browser storage.');
}
function loadState(){
  const j = localStorage.getItem('mitrasim_save');
  if(!j){ log('No saved case found.'); return; }
  resetAll(true);
  const data = JSON.parse(j);
  App.sizeMm = data.sizeMm; App.targetSpacingMm=data.targetSpacingMm; App.targetDepthMm=data.targetDepthMm;
  App.calcPattern = data.calcPattern; App.difficulty=data.difficulty;
  document.getElementById('annulusSize').value=App.sizeMm; document.getElementById('kpiAnnulus').textContent = `${App.sizeMm} mm`;
  document.getElementById('targetSpacing').value=App.targetSpacingMm; document.getElementById('kpiTargetSpacing').textContent = `${App.targetSpacingMm.toFixed(1)} mm`;
  document.getElementById('targetDepth').value=App.targetDepthMm; document.getElementById('kpiTargetDepth').textContent = `${App.targetDepthMm.toFixed(1)} mm`;
  setCalc(App.calcPattern); setDifficulty(App.difficulty);
  // Recreate sutures
  for(const s of data.sutures){
    App.placing.entry = s.entry; App.placing.exit = s.exit;
    const st = makeSuture(s.entry, s.exit, { angle:s.angle, curv:s.curvature });
    st.pledget = s.pledget;
    App.placing = {state:'idle', entry:null, exit:null, arc:null};
  }
  App.metrics = data.metrics || App.metrics;
  App.logs = data.logs || [];
  renderLog();
  if(data.startOffset){ App.startTime = Date.now()-data.startOffset; startTimer(); }
  updateKPI();
  log('üìÇ Case loaded.');
}
function reportJSON(){
  const {score, breakdown, elapsed} = computeScore(true);
  const report = {
    timestamp: new Date().toISOString(),
    scenario: { difficulty:App.difficulty, calcification:App.calcPattern, annulusSizeMm:App.sizeMm },
    performance: { score, breakdown, elapsedSec:elapsed, coaptationGapMm: App.coaptationGapMm },
    sutures: App.sutures.map(s=>({
      entryPx:s.entry, exitPx:s.exit, entryDepthMm: assessSingleSutureMetrics(s.entry,s.exit,s.angle).depthMm,
      angleDeg:s.angle, spacingMm: assessSingleSutureMetrics(s.entry,s.exit,s.angle).spacingMm, pledget:s.pledget
    })),
    logs: App.logs
  };
  return report;
}
function downloadReport(){
  const data = reportJSON();
  const blob = new Blob([JSON.stringify(data, null, 2)], {type:'application/json'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href=url; a.download = `MitraSim_report_${Date.now()}.json`; a.click();
  setTimeout(()=>URL.revokeObjectURL(url), 2000);
  log('‚¨á Report downloaded.');
}
function screenshot(){
  // draw canvas onto temp canvas to get PNG; (HUD overlay ignored; could rasterize if needed)
  App.canvas.toBlob(blob=>{
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a'); a.href=url; a.download = `MitraSim_${Date.now()}.png`; a.click();
    setTimeout(()=>URL.revokeObjectURL(url), 2000);
  });
}

// ---------- Reset ----------
function resetAll(silent=false){
  // preserve settings; rebuild valve & tissue
  App.valve = buildValve();
  App.tissue = buildTissueMesh(App.valve);
  App.sutures = []; App.metrics = { spacingMmArr:[], depthMmArr:[], angleArr:[], trauma:0 };
  App.logs = silent? App.logs : [];
  App.placing = { state:'idle', entry:null, exit:null, arc:null };
  App.coaptationGapMm = null; App.score=null;
  if(!silent) log('Tissue reset.');
  updateKPI();
}

// ---------- Animation Loop ----------
function loop(now){
  const dt = Math.min(0.033, (now - App.last)/1000); App.last = now;
  if(App.running){
    stepPhysics(dt);
    draw();
  }
  requestAnimationFrame(loop);
}

// ---------- Init ----------
function init(){
  App.canvas = document.getElementById('sim');
  App.ctx = App.canvas.getContext('2d');
  App.hud = document.getElementById('hud');

  resetAll(true);
  bindUI();
  startTimer(); // auto-start timer for demo
  updateKPI();
  renderHUD();
  requestAnimationFrame(loop);
}

window.addEventListener('load', init);
</script>
</body>
</html>
