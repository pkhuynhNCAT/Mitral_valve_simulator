<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Mitral Suture Trainer — P2 Triangular Resection (Teach • Practice • Assess)</title>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
<style>
  :root{
    --bg:#0b0f14; --ink:#eaf2f8; --mut:#9fb3c4; --ok:#2ed573; --warn:#ffb020; --bad:#ff4d4f;
    --panel:#0f151d; --line:#1f2b36; --accent:#52e2c0; --accent2:#ffeb99; --accent3:#6fa2ff;
    --mono: ui-monospace, Menlo, Consolas, "Liberation Mono", monospace;
    --sans: ui-sans-serif, system-ui, Segoe UI, Roboto, Helvetica, Arial;
  }
  html,body{margin:0;height:100%;background:var(--bg);color:var(--ink);font:14px/1.45 var(--sans)}
  #app{display:grid;grid-template-rows:60px 1fr 32px;height:100%}
  header{display:flex;gap:12px;align-items:center;padding:10px 14px;background:linear-gradient(180deg,#0e1520,#0b1218);border-bottom:1px solid #182330}
  header h1{margin:0;font-size:16px;font-weight:800;letter-spacing:.2px}
  #toolbar{margin-left:auto;display:flex;gap:10px;flex-wrap:wrap;align-items:center}
  .grp{display:flex;gap:10px;align-items:center;background:#0f1823;border:1px solid #1b2733;border-radius:10px;padding:6px 8px}
  label{color:var(--mut);font-size:12px}
  select,button{background:#101825;color:#e6f0f6;border:1px solid #223243;border-radius:8px;padding:6px 10px;cursor:pointer}
  button:active{transform:translateY(1px)}
  main{display:grid;grid-template-columns:380px 1fr}
  aside{background:var(--panel);border-right:1px solid #1b2733;padding:12px;overflow:auto}
  aside h2{font-size:12px;letter-spacing:.1em;text-transform:uppercase;color:#a7bed1;margin:12px 0 8px}
  .card{background:rgba(9,14,19,.82);border:1px solid var(--line);border-radius:12px;padding:10px;margin-bottom:10px;backdrop-filter:blur(6px)}
  .kpi{display:flex;justify-content:space-between;font-family:var(--mono);font-weight:700}
  .pill{display:inline-block;border:1px solid #223243;border-radius:999px;padding:3px 8px;color:#a6c1d5;font-size:11px;margin:4px 4px 0 0}
  .toolbtn{display:flex;gap:6px;align-items:center;width:100%}
  .toolbtn.active{outline:2px solid #3c5977}
  .coach{background:#0d1621;border-left:4px solid #3b82f6;padding:10px;border-radius:8px}
  .ok{color:var(--ok)} .warn{color:var(--warn)} .bad{color:var(--bad)} .mut{color:#9fb3c4}

  #stage{position:relative;background:radial-gradient(60% 70% at 50% 50%,#0c141b 0%,#0a1016 100%)}
  canvas{display:block;width:100%;height:100%}
  #hud{position:absolute;top:10px;left:10px;display:grid;gap:8px;pointer-events:none}
  #hud .card{pointer-events:auto;min-width:300px}
  #tensionBox{position:absolute;left:12px;bottom:12px;background:rgba(9,14,19,.88);border:1px solid #1f2b36;border-radius:8px;padding:6px 8px;color:#cfe8ff;display:none}
  #tensionBox input[type=range]{width:200px}
  #coachBox{position:absolute;right:12px;top:12px;width:min(460px,38vw);max-height:62vh;overflow:auto;background:rgba(9,14,19,.88);border:1px solid #1f2b36;border-radius:12px;padding:12px;display:none}
  #ghostNext{position:absolute;right:12px;bottom:12px;background:rgba(12,18,27,.88);border:1px dashed #335; padding:6px 10px;border-radius:10px;color:#cfe8ff;display:none}

  /* HTML callouts anchored to world space */
  #callouts{position:absolute;left:0;top:0;right:0;bottom:0;pointer-events:none}
  .callout{position:absolute;max-width:320px;background:rgba(17,26,35,.96);border:1px solid #203040;border-radius:10px;padding:8px 10px;color:#dff0ff;box-shadow:0 10px 30px rgba(0,0,0,.5)}
  .nub{position:absolute;width:0;height:0;border-left:10px solid transparent;border-right:10px solid transparent;border-top:12px solid rgba(17,26,35,.96);left:18px;transform:translateY(-1px)}

  /* setup overlay (when local libs are missing) */
  #setup{position:absolute;inset:0;background:rgba(3,8,14,.9);color:#e6f0f6;display:none}
  #setup .panel{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);width:min(880px,92vw);background:#0f1823;border:1px solid #1b2733;border-radius:12px;padding:16px}
  #setup pre{background:#0b1219;border:1px solid #1b2733;border-radius:8px;padding:10px;overflow:auto}

  footer{display:flex;gap:10px;align-items:center;padding:6px 10px;border-top:1px solid #182330;color:#8dadc1}
  #status{color:#cfe8ff}
</style>

<!-- Import map: **local files only** -->
<script type="importmap">
{
  "imports": {
    "three": "./lib/three.module.js",
    "three/examples/jsm/controls/OrbitControls.js": "./lib/controls.OrbitControls.js",
    "three/examples/jsm/lines/Line2.js": "./lib/lines.Line2.js",
    "three/examples/jsm/lines/LineGeometry.js": "./lib/lines.LineGeometry.js",
    "three/examples/jsm/lines/LineMaterial.js": "./lib/lines.LineMaterial.js"
  }
}
</script>
</head>
<body>
<div id="app">
  <header>
    <h1>Mitral Suture Trainer — P2 Triangular Resection Closure</h1>
    <div id="toolbar">
      <div class="grp">
        <label>Mode</label>
        <select id="mode">
          <option value="teach">Teach (step‑gated)</option>
          <option value="practice">Practice (AI Copilot)</option>
          <option value="assess">Assess (scored)</option>
        </select>
      </div>
      <div class="grp">
        <label>Case</label>
        <select id="case">
          <option value="p2_mid">P2 central wedge</option>
          <option value="p2_wide">P2 wide wedge</option>
          <option value="p2_small">P2 small wedge</option>
        </select>
        <button id="load">Load case</button>
      </div>
      <div class="grp">
        <button id="start">Start</button>
        <button id="reset">Reset</button>
        <button id="export">Export JSON</button>
      </div>
    </div>
  </header>

  <main>
    <aside>
      <h2>Tools</h2>
      <div class="card">
        <button class="toolbtn" id="tool_place">🪡 Place bite (entry → exit)</button>
        <button class="toolbtn" id="tool_tension">🎯 Tighten knot (set tension)</button>
        <button class="toolbtn" id="tool_remove">🧹 Remove last bite</button>
        <button class="toolbtn" id="tool_finish">✅ Finish & score</button>
      </div>

      <h2>Targets (clinical)</h2>
      <div class="card">
        <ul class="mut" style="margin:0 0 6px 16px; padding:0">
          <li><b>Depth:</b> 4–6 mm from cut edge (both sides)</li>
          <li><b>Angle:</b> ~60° ±15° to edge (drive perpendicular)</li>
          <li><b>Spacing:</b> ~4–5 mm, uniform</li>
          <li><b>Symmetry:</b> entry ≈ exit depth</li>
          <li><b>Tension:</b> edges flush, no strangulation</li>
        </ul>
        <div class="pill">Edges are banded 2–8 mm; gold zone is 4–6 mm</div>
      </div>

      <h2>Session metrics</h2>
      <div class="card">
        <div class="kpi"><span>Bites</span><span id="biteN">0</span></div>
        <div class="kpi"><span>Depth err</span><span id="depthErr">—</span></div>
        <div class="kpi"><span>Angle err</span><span id="angleErr">—</span></div>
        <div class="kpi"><span>Spacing CV</span><span id="spacing">—</span></div>
        <div class="kpi"><span>Symmetry err</span><span id="sym">—</span></div>
        <div class="kpi"><span>Residual gap</span><span id="gap">—</span></div>
        <div class="kpi"><span>Tissue stress</span><span id="stress">—</span></div>
        <div class="kpi"><span>Time</span><span id="time">—</span></div>
        <div class="kpi"><span>Overall</span><span id="overall">—</span></div>
      </div>

      <h2>Coach log</h2>
      <div class="card coach" id="coachFeed" style="white-space:pre-wrap">—</div>

      <h2>Overlays</h2>
      <div class="card">
        <label><input id="ov_depth" type="checkbox" checked> Depth bands & ruler</label><br>
        <label><input id="ov_angle" type="checkbox" checked> Angle protractor</label><br>
        <label><input id="ov_heat"  type="checkbox" checked> Spacing heatmap</label><br>
        <label><input id="ov_labels" type="checkbox" checked> Edge labels & ticks</label>
      </div>

      <h2>Shortcuts</h2>
      <div class="card">
        <div class="pill">Click: place entry/exit</div>
        <div class="pill">Z: undo last • F: finish</div>
        <div class="pill">Drag: orbit • Shift+Drag: pan • Wheel: zoom</div>
      </div>
    </aside>

    <section id="stage">
      <div id="setup">
        <div class="panel">
          <h3>Local Three.js files not found</h3>
          <p>This trainer uses WebGL but <b>does not use CDNs</b>. Add these files once and refresh:</p>
          <pre><code>mkdir lib
# Windows PowerShell
$ProgressPreference='SilentlyContinue'
Invoke-WebRequest https://unpkg.com/three@0.160.0/build/three.module.js -OutFile lib/three.module.js
Invoke-WebRequest https://unpkg.com/three@0.160.0/examples/jsm/controls/OrbitControls.js -OutFile lib/controls.OrbitControls.js
Invoke-WebRequest https://unpkg.com/three@0.160.0/examples/jsm/lines/Line2.js -OutFile lib/lines.Line2.js
Invoke-WebRequest https://unpkg.com/three@0.160.0/examples/jsm/lines/LineGeometry.js -OutFile lib/lines.LineGeometry.js
Invoke-WebRequest https://unpkg.com/three@0.160.0/examples/jsm/lines/LineMaterial.js -OutFile lib/lines.LineMaterial.js

# macOS / Linux
mkdir -p lib
curl -L https://unpkg.com/three@0.160.0/build/three.module.js -o lib/three.module.js
curl -L https://unpkg.com/three@0.160.0/examples/jsm/controls/OrbitControls.js -o lib/controls.OrbitControls.js
curl -L https://unpkg.com/three@0.160.0/examples/jsm/lines/Line2.js -o lib/lines.Line2.js
curl -L https://unpkg.com/three@0.160.0/examples/jsm/lines/LineGeometry.js -o lib/lines.LineGeometry.js
curl -L https://unpkg.com/three@0.160.0/examples/jsm/lines/LineMaterial.js -o lib/lines.LineMaterial.js</code></pre>
          <p>Commit <code>lib/</code> to your repo so GitHub Pages can serve these files.</p>
        </div>
      </div>

      <div id="hud">
        <div class="card">
          <div style="font-weight:800;margin-bottom:6px">Step</div>
          <div id="stepText">Click left edge (entry)</div>
        </div>
        <div class="card">
          <div style="font-weight:800;margin-bottom:6px">Realtime feedback</div>
          <div id="fb">—</div>
        </div>
      </div>

      <div id="tensionBox">Tension <input id="tens" type="range" min="0.70" max="1.00" step="0.01" value="1.00"> <span id="tv">loose</span></div>
      <div id="coachBox" class="coach">
        <h3 id="coachTitle">Teaching Mode</h3>
        <div id="coachText">Place the <b>apex bite</b>: entry on LEFT, exit on RIGHT, depth ~5 mm (gold), angle ~60°.</div>
        <div style="margin-top:8px"><button id="coachPrev">◀ Back</button> <button id="coachNext">Next ▶</button></div>
      </div>

      <div id="ghostNext">Next target shown as <span style="color:#FFEB99">gold dot</span>. Keep 4–6 mm depth and ~5 mm spacing.</div>
      <div id="callouts"></div>
    </section>
  </main>

  <footer>
    <div>Local‑only Three.js • Surgeon view • Needle arc + suture tension • Tissue draw‑in • Teach/Practice/Assess. For education; not a medical device.</div>
    <div id="status"></div>
  </footer>
</div>

<script type="module">
/* ================= utilities / status ================= */
const clamp = (x,a,b)=>Math.max(a,Math.min(b,x));
const now   = ()=>performance.now();
const setStatus = (t, cls='')=>{ const el=document.getElementById('status'); el.textContent=t; el.className=cls; };

/* ================= dynamic local import (no CDNs) ================= */
let THREE, OrbitControls, Line2, LineGeometry, LineMaterial;
try {
  // Import map maps "three" → ./lib/three.module.js etc.
  THREE        = await import('three');
  ({ OrbitControls } = await import('three/examples/jsm/controls/OrbitControls.js'));
  ({ Line2 }        = await import('three/examples/jsm/lines/Line2.js'));
  ({ LineGeometry } = await import('three/examples/jsm/lines/LineGeometry.js'));
  ({ LineMaterial } = await import('three/examples/jsm/lines/LineMaterial.js'));
  document.getElementById('setup').style.display='none';
  setStatus('3D engine loaded (local).','ok');
} catch (e) {
  // show setup panel; do not throw (so the UI remains visible with instructions)
  console.error(e);
  document.getElementById('setup').style.display='block';
  setStatus('Local Three.js files missing. See setup panel.','bad');
  // Abort the rest of the script:
  throw e;
}

/* ================= scene / camera / renderer ================= */
const stage = document.getElementById('stage');
const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true });
renderer.setSize(stage.clientWidth, stage.clientHeight);
renderer.setPixelRatio(Math.min(2, window.devicePixelRatio||1));
stage.appendChild(renderer.domElement);

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x0b1016);

const camera = new THREE.PerspectiveCamera(50, stage.clientWidth/stage.clientHeight, 0.1, 5000);
camera.position.set(0, 70, 160);

const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true; controls.dampingFactor=0.06; controls.minDistance=90; controls.maxDistance=260;

const hemi = new THREE.HemisphereLight(0xbfdcff, 0x0a0d10, 0.9);
const key  = new THREE.DirectionalLight(0xffffff, 1.25); key.position.set(220,240,180); key.castShadow=true;
const fill = new THREE.DirectionalLight(0xaaccff, 0.35); fill.position.set(-160,40,-80);
scene.add(hemi,key,fill);

const floor = new THREE.Mesh(new THREE.CircleGeometry(800,64), new THREE.MeshStandardMaterial({color:0x0b1219, metalness:0.15, roughness:0.95}));
floor.rotation.x = -Math.PI/2; floor.receiveShadow = true; scene.add(floor);

/* ================= anatomy (surgeon view) ================= */
const mm = v=>v;
const ANN_RES=96;
function dShapePoints(Rlat=mm(18), Rantr=mm(15), saddle=mm(6)){
  const pts=[];
  for(let i=0;i<ANN_RES;i++){
    const t=i/ANN_RES, th=t*Math.PI*2, w=(Math.cos(th)>0)?0.5:1.0;
    const rX=THREE.MathUtils.lerp(Rantr,Rlat,w), rZ=Rlat;
    const x=rX*Math.cos(th), z=rZ*Math.sin(th), y=saddle*Math.cos(2*th);
    pts.push(new THREE.Vector3(x,y,z));
  }
  return pts;
}
const annPts = dShapePoints(18,15,6);
const annCurve = new THREE.CatmullRomCurve3(annPts,true);
const annulus = new THREE.Mesh(new THREE.TubeGeometry(annCurve, ANN_RES, 1.35, 32, true), new THREE.MeshStandardMaterial({color:0x8fa6c2, metalness:.45, roughness:.35}));
annulus.castShadow=annulus.receiveShadow=true; scene.add(annulus);

// papillary muscles (context)
const papAL = new THREE.Mesh(new THREE.ConeGeometry(3.4, 16, 24), new THREE.MeshStandardMaterial({color:0x405a70, metalness:.4, roughness:.55}));
const papPM = papAL.clone(); papAL.position.set(+15,-36,+15); papPM.position.set(-18,-40,-18); papAL.rotation.x=papPM.rotation.x=Math.PI; scene.add(papAL,papPM);

// leaflet “fabric” texture (procedural)
function makeLeafletTexture(){
  const c=document.createElement('canvas'); c.width=512; c.height=512; const g=c.getContext('2d');
  const grd=g.createLinearGradient(0,0,0,512); grd.addColorStop(0,'#eef5ff'); grd.addColorStop(1,'#e7eefc'); g.fillStyle=grd; g.fillRect(0,0,512,512);
  g.globalAlpha=0.18; g.strokeStyle='#c9d7ef'; for(let i=0;i<220;i++){ const x=Math.random()*512, y=Math.random()*512, R=8+Math.random()*28; g.beginPath(); g.ellipse(x,y,R,R*0.35,Math.random()*Math.PI,0,Math.PI*2); g.stroke(); }
  const img=g.getImageData(0,0,512,512); for(let i=0;i<img.data.length;i+=4){ img.data[i]+= (Math.random()*8)|0; img.data[i+1]+= (Math.random()*8)|0; img.data[i+2]+= (Math.random()*6)|0; } g.putImageData(img,0,0);
  const tex=new THREE.CanvasTexture(c); tex.wrapS=tex.wrapT=THREE.RepeatWrapping; tex.repeat.set(2,1); return tex;
}
const leafletTex = makeLeafletTexture();

const EDGE_SEGS=64;
const STRIP_W   = mm(8);
let gapDZ = mm(6);   // case‑dependent

function posteriorEdgeCurve(){
  const pts=[];
  for(let i=ANN_RES*0.55;i<ANN_RES*0.98;i+= (ANN_RES*0.43)/EDGE_SEGS ){
    const p=annPts[Math.floor(i)%ANN_RES].clone();
    p.y -= 1.5*Math.cos((i/(ANN_RES*0.43))*Math.PI);
    pts.push(p);
  }
  return new THREE.CatmullRomCurve3(pts,false);
}
let basePosterior = posteriorEdgeCurve();

function offsetCurve(curve, dz){ return new THREE.CatmullRomCurve3(curve.getPoints(EDGE_SEGS).map(p=>p.clone().add(new THREE.Vector3(0,0,dz)))); }

function stripFromCurve(curve, color, alpha=0.95, paintDepth=false){
  const pts = curve.getPoints(EDGE_SEGS);
  const geom = new THREE.BufferGeometry();
  const vtx = new Float32Array((EDGE_SEGS+1)*2*3), uv=new Float32Array((EDGE_SEGS+1)*2*2), idx=[];
  for(let i=0;i<=EDGE_SEGS;i++){
    const p=pts[i];
    const dir=(i<EDGE_SEGS? pts[i+1].clone().sub(pts[i]) : pts[i].clone().sub(pts[i-1])).normalize();
    const up=new THREE.Vector3(0,1,0);
    const n=new THREE.Vector3().crossVectors(dir, up).normalize(); // lateral
    const a=p.clone().add(n.clone().multiplyScalar(STRIP_W/2));
    const b=p.clone().add(n.clone().multiplyScalar(-STRIP_W/2));
    vtx.set([a.x,a.y,a.z], i*6+0); vtx.set([b.x,b.y,b.z], i*6+3);
    uv.set([0, i/EDGE_SEGS], i*4+0); uv.set([1, i/EDGE_SEGS], i*4+2);
    if(i<EDGE_SEGS){ const k=i*2; idx.push(k,k+1,k+2, k+1,k+3,k+2); }
  }
  geom.setAttribute('position', new THREE.BufferAttribute(vtx,3));
  geom.setAttribute('uv', new THREE.BufferAttribute(uv,2));
  geom.setIndex(idx); geom.computeVertexNormals();

  let mat;
  if(paintDepth){
    const c=document.createElement('canvas'); c.width=256; c.height=1024; const g=c.getContext('2d');
    g.fillStyle='rgba(240,248,255,0.97)'; g.fillRect(0,0,256,1024);
    g.strokeStyle='rgba(60,90,150,0.55)'; g.lineWidth=2;
    for(let x=16;x<256;x+= (STRIP_W/6)*(256/STRIP_W) ){ g.beginPath(); g.moveTo(x,0); g.lineTo(x,1024); g.stroke(); }
    const mm2px=256/STRIP_W; const x1=Math.round((STRIP_W/2-6)*mm2px), x2=Math.round((STRIP_W/2-4)*mm2px);
    g.fillStyle='rgba(255,235,153,0.35)'; g.fillRect(x1,0,(x2-x1),1024);
    const tex=new THREE.CanvasTexture(c); tex.wrapS=tex.wrapT=THREE.RepeatWrapping; tex.repeat.set(1,1);
    mat=new THREE.MeshStandardMaterial({map:tex, color, metalness:.06, roughness:.82, side:THREE.DoubleSide, transparent:true, opacity:alpha});
  } else {
    mat=new THREE.MeshStandardMaterial({map:leafletTex, color, metalness:.06, roughness:.82, side:THREE.DoubleSide, transparent:true, opacity:alpha});
  }
  const mesh=new THREE.Mesh(geom,mat); mesh.castShadow=mesh.receiveShadow=true; return mesh;
}

let leftCurve  = basePosterior.clone();
let rightCurve = offsetCurve(basePosterior, gapDZ);
let leftStrip  = stripFromCurve(leftCurve, 0xf1f7ff, 0.98, true);
let rightStrip = stripFromCurve(rightCurve,0xe7efff, 0.95, true);
scene.add(leftStrip,rightStrip);

// anterior context surface
(function anteriorSurface(){
  const pts=[]; for(let i=ANN_RES*0.05;i<ANN_RES*0.55;i+= (ANN_RES*0.5)/42 ){
    const p=annPts[Math.floor(i)%ANN_RES].clone();
    const n=annPts[(Math.floor(i+1))%ANN_RES].clone().sub(annPts[(Math.floor(i-1+ANN_RES))%ANN_RES]).normalize();
    const lat=new THREE.Vector3().crossVectors(n,new THREE.Vector3(0,1,0)).normalize();
    p.addScaledVector(lat,-mm(18)); p.y -= mm(2)*Math.sin(i); pts.push(p);
  }
  const curve=new THREE.CatmullRomCurve3(pts);
  const g=new THREE.TubeGeometry(curve, 42, 9, 32, false);
  const m=new THREE.MeshStandardMaterial({map:leafletTex, color:0xf7fbff, metalness:.06, roughness:.82, transparent:true, opacity:0.22, side:THREE.DoubleSide});
  const mesh=new THREE.Mesh(g,m); mesh.receiveShadow=true; scene.add(mesh);
})();

/* ================= labels ================= */
function addLabel(text,pos){
  const c=document.createElement('canvas'); c.width=256; c.height=64; const g=c.getContext('2d');
  g.fillStyle='#cfe8ff'; g.font='bold 36px Segoe UI'; g.textAlign='center'; g.textBaseline='middle'; g.fillText(text,128,32);
  const s=new THREE.Sprite(new THREE.SpriteMaterial({map:new THREE.CanvasTexture(c), transparent:true}));
  s.scale.set(12,3,1); s.position.copy(pos.clone().add(new THREE.Vector3(0,6,0))); scene.add(s); return s;
}
const leftLabel  = addLabel('P2 left edge',  leftCurve.getPoint(0.62));
const rightLabel = addLabel('P2 right edge', rightCurve.getPoint(0.62));

/* ================= needle & suture ================= */
const needleGroup = new THREE.Group(); scene.add(needleGroup);
function makeNeedle(radius=mm(8), span=Math.PI*3/8){
  const tube = new THREE.TorusGeometry(radius, 0.5, 18, 96, span);
  const mat  = new THREE.MeshStandardMaterial({color:0xa0b8cd, metalness:.8, roughness:.25});
  const mesh = new THREE.Mesh(tube, mat); mesh.rotation.y = Math.PI/2; return mesh;
}
function computeNeedleBasis(entry, exit){
  const mid = entry.clone().add(exit).multiplyScalar(0.5);
  const chord = exit.clone().sub(entry); const L=chord.length();
  const up = new THREE.Vector3(0,1,0);
  const n = new THREE.Vector3().crossVectors(chord, up).normalize();
  const z = chord.clone().normalize();
  const x = new THREE.Vector3().crossVectors(n, z).normalize();
  const y = new THREE.Vector3().crossVectors(z, x).normalize();
  return {mid, x,y,z, R:Math.max(mm(6), L/1.8), span: Math.PI*0.8};
}
let BUSY=false;
function animateNeedle(entry, exit, onDone){
  BUSY=true; needleGroup.clear();
  const B=computeNeedleBasis(entry,exit);
  const mesh=makeNeedle(B.R, B.span); needleGroup.add(mesh);
  const basis=new THREE.Matrix4().makeBasis(B.x,B.y,B.z), pos=new THREE.Matrix4().makeTranslation(B.mid.x,B.mid.y,B.mid.z);
  mesh.matrixAutoUpdate=false; let t=0;
  (function tick(){
    t += 0.03; const angle = -B.span/2 + B.span*Math.min(1,t);
    mesh.matrix = pos.clone().multiply(basis).multiply(new THREE.Matrix4().makeRotationX(angle));
    renderer.render(scene,camera);
    if(t<1){ requestAnimationFrame(tick); } else { BUSY=false; onDone && onDone(); }
  })();
}

class Rope {
  constructor(a,b,segments=18){
    this.nodes=[]; for(let i=0;i<=segments;i++) this.nodes.push(a.clone().lerp(b, i/segments));
    this.restLen = this.totalLength(); this.targetScale = 1.0;
    this.line = this.buildLine();
  }
  totalLength(){ let L=0; for(let i=1;i<this.nodes.length;i++) L+=this.nodes[i].distanceTo(this.nodes[i-1]); return L; }
  tighten(scale){ this.targetScale = clamp(scale,0.7,1.0); }
  step(){
    const want=this.restLen*this.targetScale, have=this.totalLength(), excess=have-want;
    if(Math.abs(excess)<0.01) return;
    const perSeg = excess/(this.nodes.length-1);
    for(let i=1;i<this.nodes.length-1;i++){
      const prev=this.nodes[i-1], cur=this.nodes[i], nxt=this.nodes[i+1];
      const u1 = cur.clone().sub(prev).normalize();
      const u2 = nxt.clone().sub(cur).normalize();
      cur.addScaledVector(u1, -perSeg*0.25).addScaledVector(u2, perSeg*0.25);
    }
  }
  buildLine(){
    const geo=new LineGeometry(); geo.setPositions(this.nodes.flatMap(p=>[p.x,p.y,p.z]));
    const mat=new LineMaterial({ color:0xfff2c2, linewidth:2, worldUnits:true });
    const line=new Line2(geo,mat); line.computeLineDistances(); return line;
  }
  updateLine(){
    this.line.geometry.setPositions(this.nodes.flatMap(p=>[p.x,p.y,p.z])); this.line.geometry.needsUpdate=true;
  }
}

/* ================= overlays (HTML callouts anchored to 3D) ============= */
const callouts = []; // {el, world:THREE.Vector3, tEnd:number}
function addCallout(world, text, ms=6000){
  const root=document.getElementById('callouts'); const box=document.createElement('div');
  box.className='callout'; box.innerText=text; const nub=document.createElement('div'); nub.className='nub'; box.appendChild(nub);
  root.appendChild(box); callouts.push({el:box, world:world.clone(), tEnd:performance.now()+ms});
}
function updateCallouts(){
  const rootRect=stage.getBoundingClientRect();
  for(let i=callouts.length-1;i>=0;i--){
    const c=callouts[i]; if(performance.now()>c.tEnd){ c.el.remove(); callouts.splice(i,1); continue; }
    const p=c.world.clone().project(camera); // NDC
    const x=(p.x*0.5+0.5)*rootRect.width, y=(-p.y*0.5+0.5)*rootRect.height;
    c.el.style.left = `${x+12}px`; c.el.style.top = `${y-12}px`;
  }
}

/* ================= picking & measurement ================= */
const ray = new THREE.Raycaster(); const mouse = new THREE.Vector2();
renderer.domElement.addEventListener('pointermove',(e)=> {
  const r = renderer.domElement.getBoundingClientRect();
  mouse.x = ((e.clientX-r.left)/r.width)*2-1; mouse.y = -((e.clientY-r.top)/r.height)*2+1;
});
renderer.domElement.addEventListener('pointerdown', onClick);

function nearestOnCurve(curve, p){
  let bestT=0, bestD=1e9;
  for(let i=0;i<=EDGE_SEGS;i++){ const t=i/EDGE_SEGS, q=curve.getPoint(t), d=q.distanceTo(p); if(d<bestD){ bestD=d; bestT=t; } }
  const pos=curve.getPoint(bestT), tangent=curve.getTangent(bestT).normalize();
  const lateral=new THREE.Vector3().crossVectors(tangent,new THREE.Vector3(0,1,0)).normalize();
  return {t:bestT,pos,tangent,lateral};
}
function depthFromEdge(curve, p){
  const pr=nearestOnCurve(curve,p); const d=p.clone().sub(pr.pos);
  const depth = Math.abs(d.dot(pr.lateral)); return {depth, base:pr.pos, tangent:pr.tangent, lateral:pr.lateral, t:pr.t};
}
function angleErrorDegrees(edgeTangent, chordVec){
  const edge=edgeTangent.clone().normalize(); const chord=chordVec.clone().normalize();
  const d = clamp(Math.abs(edge.dot(chord)), 0, 1); const ang = Math.acos(d)*180/Math.PI; return Math.abs(ang - 60);
}

/* ================= tissue draw‑in (local coaptation) ================= */
function applyDrawIn(idxT, amount, sigma){
  const Lpts = leftCurve.getPoints(EDGE_SEGS);
  const Rpts = rightCurve.getPoints(EDGE_SEGS);
  const idx = Math.round(idxT*EDGE_SEGS);
  for(let i=0;i<=EDGE_SEGS;i++){
    const w = Math.exp(-((i-idx)*(i-idx))/(2*sigma*sigma));
    const l=Lpts[i], r=Rpts[i];
    const dir = r.clone().sub(l).normalize();
    l.addScaledVector(dir,  amount*w*0.5);
    r.addScaledVector(dir, -amount*w*0.5);
  }
  // Rebuild curves and strips from modified samples
  leftCurve  = new THREE.CatmullRomCurve3(Lpts,false);
  rightCurve = new THREE.CatmullRomCurve3(Rpts,false);
  scene.remove(leftStrip,rightStrip);
  leftStrip  = stripFromCurve(leftCurve,  0xf1f7ff, 0.98, true);
  rightStrip = stripFromCurve(rightCurve, 0xe7efff, 0.95, true);
  scene.add(leftStrip,rightStrip);
}

/* ================= UI state & wiring ================= */
const ui = {
  mode: qs('#mode'), caseSel: qs('#case'), loadBtn: qs('#load'), startBtn: qs('#start'),
  resetBtn: qs('#reset'), exportBtn: qs('#export'),
  tool_place: qs('#tool_place'), tool_tension: qs('#tool_tension'), tool_remove: qs('#tool_remove'), tool_finish: qs('#tool_finish'),
  stepText: qs('#stepText'), fb: qs('#fb'),
  biteN: qs('#biteN'), depthErr: qs('#depthErr'), angleErr: qs('#angleErr'), spacing: qs('#spacing'),
  sym: qs('#sym'), gap: qs('#gap'), stress: qs('#stress'), time: qs('#time'), overall: qs('#overall'),
  tensionBox: qs('#tensionBox'), tens: qs('#tens'), tv: qs('#tv'),
  coachFeed: qs('#coachFeed'), coachBox: qs('#coachBox'), coachTitle: qs('#coachTitle'), coachText: qs('#coachText'),
  coachPrev: qs('#coachPrev'), coachNext: qs('#coachNext'),
  ghostNext: qs('#ghostNext'),
  ovDepth: qs('#ov_depth'), ovAngle: qs('#ov_angle'), ovHeat: qs('#ov_heat'), ovLabels: qs('#ov_labels')
};
function qs(s){return document.querySelector(s)}
let tool='place'; setTool('place');
ui.tool_place.onclick  = ()=> setTool('place');
ui.tool_tension.onclick= ()=> setTool('tension');
ui.tool_remove.onclick = removeLastBite;
ui.tool_finish.onclick = finalize;
document.addEventListener('keydown',(e)=>{ if(e.key==='z'||e.key==='Z') removeLastBite(); if(e.key==='f'||e.key==='F') finalize(); });

/* cases & framing */
function loadCase(kind){
  gapDZ = (kind==='p2_wide'? mm(8): kind==='p2_small'? mm(4): mm(6));
  basePosterior = posteriorEdgeCurve(); leftCurve = basePosterior.clone(); rightCurve = offsetCurve(basePosterior, gapDZ);
  scene.remove(leftStrip,rightStrip); leftStrip=stripFromCurve(leftCurve,0xf1f7ff,0.98,true); rightStrip=stripFromCurve(rightCurve,0xe7efff,0.95,true); scene.add(leftStrip,rightStrip);
  frameView(); clearAll(); ui.fb.textContent='Case loaded.';
}
function frameView(){
  const box = new THREE.Box3().setFromObject(leftStrip).union(new THREE.Box3().setFromObject(rightStrip));
  const c = box.getCenter(new THREE.Vector3()); controls.target.copy(c); camera.position.set(c.x, c.y+60, c.z+160);
}

/* ================= task state & modes ================= */
let step=0;  // 0 entry (left), 1 exit (right)
let entryP=null, exitP=null, activeIdx=-1, sessionStart=now();
const bites=[]; // records

const TEACH_STEPS=[
  { id:'intro', title:'Orientation', text:'Posterior wedge edges are depth‑banded (2–8 mm). Target is 4–6 mm (gold). Start with the apex bite.', gate:()=>true },
  { id:'apex',  title:'Apex', text:'LEFT entry → RIGHT exit, both ~5 mm and ~60°, symmetric.', gate:()=> bites.length>=1 && within(bites[0],{depth:[4,6], angle:15, sym:1.0}) },
  { id:'second',title:'Second bite', text:'Place the second bite ~5 mm from apex. Same criteria.', gate:()=> bites.length>=2 && within(bites[1],{depth:[4,6], angle:15, sym:1.0}) },
  { id:'series',title:'Series', text:'Complete with even spacing (~4–5 mm). Then tighten.', gate:()=> bites.length>=4 },
  { id:'tension',title:'Tension', text:'Switch to “Tighten knot”. Adjust to minimize residual gap without strangulation.', gate:()=> avgResidual()<=2.0 }
];
let teachIdx=0;
function within(b, lim){ const okD=(b.depthL>=lim.depth[0]&&b.depthL<=lim.depth[1]&&b.depthR>=lim.depth[0]&&b.depthR<=lim.depth[1]);
  const okA=(b.angleErr<=lim.angle); const okS=(Math.abs(b.depthL-b.depthR)<=lim.sym); return okD&&okA&&okS; }
function avgResidual(){ if(!bites.length) return 999; return bites.reduce((s,x)=>s+x.residual,0)/bites.length; }
function showCoach(){ if(ui.mode.value!=='teach'){ ui.coachBox.style.display='none'; return; } ui.coachBox.style.display='block';
  ui.coachTitle.textContent=`Teaching — Step ${teachIdx+1}/${TEACH_STEPS.length}: ${TEACH_STEPS[teachIdx].title}`; ui.coachText.textContent=TEACH_STEPS[teachIdx].text; }
ui.coachPrev.onclick=()=>{ teachIdx=Math.max(0,teachIdx-1); showCoach(); };
ui.coachNext.onclick=()=>{ if(TEACH_STEPS[teachIdx].gate()) teachIdx=Math.min(teachIdx+1,TEACH_STEPS.length-1); showCoach(); };

/* ================= clicking workflow ================= */
function onClick(){
  if(BUSY || tool!=='place') return;
  ray.setFromCamera(mouse, camera);
  const hitL = ray.intersectObject(leftStrip, false)[0];
  const hitR = ray.intersectObject(rightStrip,false)[0];

  if(step===0){
    if(!hitL || hitL.object!==leftStrip){ ui.fb.textContent='Place ENTRY on LEFT edge (gold 4–6 mm).'; return; }
    entryP = hitL.point.clone(); step=1; ui.stepText.textContent='Click right edge (exit)'; ui.fb.textContent='Good. Now EXIT on RIGHT edge.';
    flash(entryP, 0xFFEB99);
  } else {
    if(!hitR || hitR.object!==rightStrip){ ui.fb.textContent='Place EXIT on RIGHT edge.'; return; }
    exitP = hitR.point.clone();
    BUSY=true;
    animateNeedle(entryP, exitP, ()=>{
      const rope=new Rope(entryP, exitP, 18); scene.add(rope.line);
      // measure
      const dL=depthFromEdge(leftCurve , entryP); const dR=depthFromEdge(rightCurve, exitP);
      const chord = exitP.clone().sub(entryP);
      const angErr=angleErrorDegrees(dL.tangent, chord);
      const symErr=Math.abs(dL.depth - dR.depth);
      const spacing=bites.length? entryP.distanceTo(bites.at(-1).entry):NaN;
      const bite={
        entry:entryP.clone(), exit:exitP.clone(), rope,
        tLeft:dL.t, tRight:dR.t,
        depthL:+dL.depth.toFixed(2), depthR:+dR.depth.toFixed(2),
        angleErr:+angErr.toFixed(1), symmetry:+symErr.toFixed(2),
        spacingFromPrev: spacing? +spacing.toFixed(2) : NaN,
        get tension(){ return 1.0 - rope.targetScale; },
        get residual(){ // current gap in mm near left t
          const L=leftCurve.getPoint(dL.t), R=rightCurve.getPoint(dL.t); return L.distanceTo(R);
        }
      };
      bites.push(bite); activeIdx=bites.length-1; showTensionFor(bite);
      if(ui.mode.value==='practice') coachSay(aiAdvice(bite));
      if(ui.mode.value==='teach'    && TEACH_STEPS[teachIdx].gate()) { teachIdx=Math.min(teachIdx+1,TEACH_STEPS.length-1); showCoach(); }
      step=0; entryP=null; exitP=null; BUSY=false;
      ui.stepText.textContent='Click left edge (entry)'; ui.fb.textContent='Bite placed.';
      refreshScore(); updateHeat(); addCallout(bite.entry, coachLast); // anchor advice
    });
  }
}
function flash(p, color=0xFFEB99){
  const m=new THREE.Mesh(new THREE.SphereGeometry(1.4), new THREE.MeshBasicMaterial({color}));
  m.position.copy(p); scene.add(m); setTimeout(()=>scene.remove(m), 900);
}

/* ================= AI copilot ================= */
let coachLast='—';
function coachSay(msg){ coachLast=msg; ui.coachFeed.textContent=msg; }
function aiAdvice(b){
  const out=[];
  if(b.angleErr>25) out.push('Angle too parallel — roll wrist to drive more perpendicular (~60°).');
  else if(b.angleErr>15) out.push('Angle slightly shallow — bias more perpendicular.');
  if(b.depthL<4 || b.depthR<4) out.push('Depth shallow — move into gold band (4–6 mm).');
  if(b.depthL>6 || b.depthR>6) out.push('Depth deep — stay within 4–6 mm.');
  if(Math.abs(b.depthL-b.depthR)>1.2) out.push('Asymmetric entry/exit — adjust exit ~1–2 mm to match.');
  if(bites.length>1){
    const s=b.spacingFromPrev; if(s<3.2) out.push('Bites too close — target 4–5 mm.'); if(s>6.0) out.push('Bites too far — target 4–5 mm.');
  }
  if(b.tension>0.35) out.push('Tension high — risk of tissue stress; back off slightly.');
  if(!out.length) out.push('Nice bite. Maintain this pattern.');
  return out.join('\n');
}

/* ================= tension UI ================= */
function showTensionFor(b){
  ui.tensionBox.style.display='block';
  const slider=ui.tens, label=ui.tv; slider.value=b.rope.targetScale.toFixed(2);
  const update=()=>{ const t=1-parseFloat(slider.value); label.textContent=(t<0.05?'loose': t>0.25?'tight':'ok'); label.style.color=(t<0.05?'#9fb3c4': t>0.25?'#ffb020':'#2ed573'); };
  slider.oninput=()=>{
    b.rope.tighten(parseFloat(slider.value));
    // convert tightening into local tissue draw‑in near left t (Gaussian)
    const idxT = b.tLeft; const beforeGap = b.residual;
    const draw = (1.0 - b.rope.targetScale) * beforeGap * 0.65; // fraction of gap closed locally
    applyDrawIn(idxT, draw, /*sigma*/ 8);
    update(); refreshScore();
  };
  update();
}

/* ================= scoring ================= */
function mean(a){ return a.reduce((x,y)=>x+y,0)/a.length; }
function stdev(a){ const m=mean(a); return Math.sqrt(mean(a.map(v=>(v-m)*(v-m)))); }
function cv(a){ return mean(a)>0 ? stdev(a)/mean(a) : NaN; }
function computeScores(){
  if(!bites.length) return {overall:NaN};
  const target=5;
  const depthErrs=[], angErrs=[], spacings=[], symErrs=[], res=[], stress=[];
  for(let i=0;i<bites.length;i++){
    const b=bites[i];
    depthErrs.push((Math.abs(b.depthL-target)+Math.abs(b.depthR-target))/2);
    angErrs.push(b.angleErr);
    if(i>0 && isFinite(b.spacingFromPrev)) spacings.push(b.spacingFromPrev);
    symErrs.push(b.symmetry);
    res.push(b.residual);
    stress.push((1.0-b.rope.targetScale)*5);
  }
  const dE=mean(depthErrs), aE=mean(angErrs), spCV=spacings.length?cv(spacings):NaN, sE=mean(symErrs), rG=mean(res), tS=mean(stress);
  const sDepth=clamp(5-dE*0.8,1,5), sAngle=clamp(5-Math.max(0,aE-5)*0.12,1,5), sSpace=isFinite(spCV)?clamp(5-spCV*8,1,5):3, sSym=clamp(5-sE*0.6,1,5), sGap=clamp(5-rG*0.6,1,5), sStress=clamp(5-tS,1,5);
  const overall = (sDepth*0.24 + sAngle*0.16 + sSpace*0.16 + sSym*0.16 + sGap*0.16 + sStress*0.12);
  return {dE,aE,spCV,sE,rG,tS,overall};
}
function refreshScore(){
  const s=computeScores();
  ui.biteN.textContent=bites.length+'';
  ui.depthErr.textContent = isFinite(s.dE)? s.dE.toFixed(1)+' mm':'—';
  ui.angleErr.textContent = isFinite(s.aE)? s.aE.toFixed(1)+'°':'—';
  ui.spacing.textContent  = isFinite(s.spCV)? (s.spCV*100).toFixed(0)+'%':'—';
  ui.sym.textContent      = isFinite(s.sE)? s.sE.toFixed(1)+' mm':'—';
  ui.gap.textContent      = isFinite(s.rG)? s.rG.toFixed(1)+' mm':'—';
  ui.stress.textContent   = isFinite(s.tS)? s.tS.toFixed(2):'—';
  ui.overall.textContent  = isFinite(s.overall)? s.overall.toFixed(1)+'/5':'—';
  ui.time.textContent     = ((now()-sessionStart)/1000).toFixed(1)+' s';
}

/* ================= heatmap between entries ================= */
const heatGroup = new THREE.Group(); scene.add(heatGroup);
function updateHeat(){
  heatGroup.clear();
  if(bites.length<2) return;
  for(let i=1;i<bites.length;i++){
    const a=bites[i-1].entry, b=bites[i].entry;
    const dist=a.distanceTo(b);
    const col = (dist<mm(3.2)? 0xff4d4f : dist>mm(6.0)? 0xffb020 : 0x2ed573);
    const g=new LineGeometry(); g.setPositions([a.x,a.y,a.z, b.x,b.y,b.z]);
    const m=new LineMaterial({color:col, linewidth:3, worldUnits:true, transparent:true, opacity:0.25});
    const l=new Line2(g,m); l.computeLineDistances(); heatGroup.add(l);
  }
}

/* ================= remove / reset / finalize / export ================= */
function removeLastBite(){
  const b=bites.pop(); if(!b) return;
  scene.remove(b.rope.line); refreshScore(); updateHeat(); ui.fb.textContent='Removed last bite.'; if(!bites.length) ui.tensionBox.style.display='none';
}
function clearAll(){
  while(bites.length){ const b=bites.pop(); scene.remove(b.rope.line); }
  entryP=null; exitP=null; step=0; activeIdx=-1; ui.tensionBox.style.display='none'; sessionStart=now(); needleGroup.clear(); updateHeat(); refreshScore();
  ui.stepText.textContent='Click left edge (entry)'; ui.fb.textContent='—'; callouts.splice(0).forEach(c=>c.el.remove());
}
function finalize(){
  if(!bites.length){ ui.fb.textContent='Place at least one bite before finishing.'; return; }
  const s = computeScores();
  ui.fb.innerHTML = `<span class="${s.overall>=4?'ok':s.overall>=3?'warn':'bad'}">Finished. Overall ${s.overall.toFixed(1)}/5</span>`;
  if(ui.mode.value==='practice'){
    if(s.overall<3.5) coachSay('Repeat focusing on angle (~60°) and symmetric depth; maintain 4–5 mm spacing; avoid overtension.');
    else coachSay('Strong work. Try the wide wedge next, or speed challenge in Assess.');
  }
}
ui.exportBtn.onclick=()=>{
  const payload={ when:new Date().toISOString(), mode:ui.mode.value, case:ui.caseSel.value,
    bites:bites.map(b=>({ entry:b.entry, exit:b.exit, depthL:b.depthL, depthR:b.depthR, angleErr:b.angleErr, symmetry:b.symmetry, residual:b.residual, tension:b.tension })),
    summary:computeScores(), time_s:((now()-sessionStart)/1000).toFixed(1) };
  const blob=new Blob([JSON.stringify(payload,null,2)],{type:'application/json'});
  const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download='mitral_suture_session.json'; a.click(); URL.revokeObjectURL(a.href);
};

/* ================= toolbar ================= */
function setTool(t){ tool=t; ['place','tension','remove','finish'].forEach(k=>document.getElementById('tool_'+k).classList.toggle('active',k===t)); ui.stepText.textContent=(t==='place'?'Click left edge (entry)': t==='tension'?'Select last bite then adjust tension':''); }
ui.loadBtn.onclick=()=>{ loadCase(ui.caseSel.value); };
ui.startBtn.onclick=()=>{ sessionStart=now(); if(ui.mode.value==='teach'){ ui.coachBox.style.display='block'; showCoach(); } if(ui.mode.value==='practice'){ ui.ghostNext.style.display='block'; } };
ui.resetBtn.onclick=clearAll;
ui.mode.onchange=()=>{ clearAll(); if(ui.mode.value==='teach'){ ui.coachBox.style.display='block'; showCoach(); ui.ghostNext.style.display='none'; } else if(ui.mode.value==='practice'){ ui.coachBox.style.display='none'; ui.ghostNext.style.display='block'; } else { ui.coachBox.style.display='none'; ui.ghostNext.style.display='none'; } };

/* ================= render loop & resize ================= */
function tick(){ requestAnimationFrame(tick);
  // animate suture if an active rope exists
  if(activeIdx>=0 && bites[activeIdx]){ const b=bites[activeIdx]; b.rope.step(); b.rope.updateLine(); }
  controls.update(); updateCallouts(); renderer.render(scene,camera);
}
tick();
window.addEventListener('resize', ()=>{ renderer.setSize(stage.clientWidth, stage.clientHeight); camera.aspect=stage.clientWidth/stage.clientHeight; camera.updateProjectionMatrix(); });

/* ================= boot ================= */
function boot(){ loadCase('p2_mid'); setStatus('Ready','ok'); ui.coachFeed.textContent='Select a mode: Teaching is step‑gated; Practice gives AI Copilot; Assess scores strictly.'; }
boot();
</script>
</body>
</html>
