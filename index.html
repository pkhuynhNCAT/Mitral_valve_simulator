<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta
    name="viewport"
    content="width=device-width, initial-scale=1, viewport-fit=cover"/>
  <title>MitralSim Pro ‚Äî Module 1.1 ¬∑ Mitral Apparatus Overview</title>
  <meta name="description" content="Super‚Äërealistic, web‚Äëbased, 3D overview of the mitral apparatus (annulus, anterior/posterior leaflets, commissures) with cinematic rendering, annotations, and guided steps."/>
  <link rel="stylesheet" href="../assets/css/style.css"/>

  <!-- üì¶ Three.js (ESM) + examples -->
  <script type="module" crossorigin src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js"></script>
  <script type="module" crossorigin src="https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/controls/OrbitControls.js"></script>
  <script type="module" crossorigin src="https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/postprocessing/EffectComposer.js"></script>
  <script type="module" crossorigin src="https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/postprocessing/RenderPass.js"></script>
  <script type="module" crossorigin src="https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/postprocessing/UnrealBloomPass.js"></script>
  <script type="module" crossorigin src="https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/postprocessing/ShaderPass.js"></script>
  <script type="module" crossorigin src="https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/postprocessing/OutlinePass.js"></script>
  <script type="module" crossorigin src="https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/shaders/FXAAShader.js"></script>
  <script type="module" crossorigin src="https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/environments/RoomEnvironment.js"></script>

  <style>
    /* ---- Module‚Äëspecific design polish ---- */
    :root{
      --panelGrad: linear-gradient(180deg, rgba(33,38,45,.8), rgba(22,27,34,.85));
      --glass: rgba(24, 28, 36, .6);
    }
    body { background: radial-gradient(1200px 700px at 70% -10%, #142031, #0d1117 60%); }
    .topbar .inner { backdrop-filter: blur(10px); }
    .page { grid-template-columns: 380px 1fr; gap: 18px; }

    /* Cinematic canvas wrap */
    .canvas-wrap{
      background: radial-gradient(1200px 800px at 50% -20%, #0f1b29, #070a0f 55%, #05070a);
      border: 1px solid var(--outline);
      box-shadow: 0 40px 120px rgba(0,0,0,.65), inset 0 0 0 1px rgba(255,255,255,.02);
    }

    /* Annotations & overlays */
    #overlay { position:absolute; inset:0; pointer-events:none; }
    .callout {
      position:absolute; max-width:280px; color:#e8f0ff; font-size:12px; line-height:1.35;
      padding:10px 12px; border-radius:12px; border:1px solid rgba(120,140,170,.35);
      background: linear-gradient(180deg, rgba(16,22,30,.9), rgba(11,15,22,.88));
      box-shadow: 0 3px 18px rgba(0,0,0,.45);
    }
    .callout .title{ font-weight:700; margin-bottom:4px; font-size:12px; letter-spacing:.3px }
    .callout .meta { color:#9db0c7; font-size:11px }
    .pin {
      position:absolute; width:10px; height:10px; border-radius:50%;
      background: radial-gradient(9px 9px at 40% 35%, #76d0ff, #2274ff 60%, #1b3fa0 100%);
      box-shadow: 0 0 0 4px rgba(64,169,255,.18), 0 0 16px rgba(64,169,255,.35);
    }

    /* Control tiles */
    .toolrow { display:flex; gap:8px; flex-wrap:wrap }
    .toolbtn{
      border:1px solid var(--outline); border-radius:10px; background:var(--panelGrad); color:var(--ink);
      padding:8px 10px; font-size:12px; cursor:pointer; transition: transform .08s ease, box-shadow .15s ease;
    }
    .toolbtn:hover{ box-shadow:0 6px 18px rgba(0,0,0,.35); transform: translateY(-1px); }
    .toolbtn[data-active="1"]{ outline:2px solid #4cc9f0; outline-offset:-2px }

    .switch { display:flex; align-items:center; gap:10px; }
    .switch input{ width:18px; height:18px; }

    /* KPIs */
    .kpis2 { display:grid; grid-template-columns: repeat(3,1fr); gap:10px }
    .kpis2 .k { background:var(--panel); border:1px solid var(--outline); border-radius:12px; padding:10px; }
    .kpis2 .k .label { color:var(--muted); font-size:11px }
    .kpis2 .k .value { font-family: var(--mono); font-size:18px }

    /* Stepper */
    .step { padding:10px; border:1px dashed var(--outline); border-radius:10px; background:rgba(18,22,30,.45) }
    .step .t{ font-weight:700; margin-bottom:4px }
    .step .d{ color:var(--muted); font-size:12px }
    .hl { color:#a6e3a1 }

    /* Pretty sliders */
    .range { -webkit-appearance: none; width: 100%; height: 6px; border-radius: 8px; background:#1a2533; outline: none; }
    .range::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width:14px; height:14px; border-radius:50%; background:#4cc9f0; border:2px solid #0b1a2a; cursor:pointer }
    .mini-caption{ font-size:11px; color:var(--muted); margin-top:2px }

    /* Outline color indicator */
    .swatch { width:12px; height:12px; border-radius:3px; border:1px solid var(--outline); display:inline-block; translate: 0 2px; }

    /* Floating HUD badge */
    .hud {
      position:absolute; top:10px; right:10px; background:rgba(20,24,32,.55); border:1px solid var(--outline);
      color:#93b7ff; padding:8px 10px; border-radius:10px; font-size:12px; backdrop-filter: blur(8px);
    }
  </style>
</head>
<body>
  <div class="topbar">
    <div class="inner">
      <a class="btn secondary" href="../index.html">‚Üê Back</a>
      <div class="logo">Module 1.1 ‚Äî Mitral Apparatus Overview</div>
      <span class="badge">Annulus</span>
      <span class="badge">Anterior/Posterior Leaflets</span>
      <span class="badge">Commissures</span>
      <div style="flex:1"></div>
      <span class="badge">Cinematic 3D</span>
    </div>
  </div>

  <div class="container page">
    <!-- Sidebar -->
    <aside class="sidebar">
      <div class="panel">
        <h4>Lesson Mode</h4>
        <div class="toolrow">
          <button id="btnGuide" class="toolbtn" data-active="1">Guided</button>
          <button id="btnExplore" class="toolbtn">Explore</button>
          <button id="btnIdentify" class="toolbtn">Identify</button>
        </div>
        <div class="small" style="margin-top:6px">
          <b>Guided:</b> step‚Äëby‚Äëstep with highlights ¬∑
          <b>Explore:</b> free navigation + labels ¬∑
          <b>Identify:</b> click requested landmark (no hints).
        </div>
      </div>

      <div class="panel">
        <h4>Cinematic Controls</h4>
        <div class="list small">
          <div class="row">
            <label style="width:38%">Bloom</label>
            <input id="rngBloom" class="range" type="range" min="0" max="2.0" step="0.02" value="0.8"/>
          </div>
          <div class="mini-caption">Highlights the glossy tissue sheen</div>
          <div class="row" style="margin-top:10px">
            <label style="width:38%">Outline</label>
            <input id="rngOutline" class="range" type="range" min="0" max="0.06" step="0.002" value="0.032"/>
          </div>
          <div class="mini-caption">Selection glow thickness</div>
          <div class="row" style="margin-top:10px">
            <label style="width:38%">Pulse</label>
            <input id="rngPulse" class="range" type="range" min="0" max="1" step="0.02" value="0.35"/>
          </div>
          <div class="mini-caption">Subtle leaflet motion amplitude</div>
        </div>
      </div>

      <div class="panel">
        <h4>Layers</h4>
        <div class="list small" id="layers">
          <label class="switch"><input data-layer="annulus" type="checkbox" checked> Mitral Annulus</label>
          <label class="switch"><input data-layer="leafletA" type="checkbox" checked> Anterior Leaflet</label>
          <label class="switch"><input data-layer="leafletP" type="checkbox" checked> Posterior Leaflet</label>
          <label class="switch"><input data-layer="commissures" type="checkbox" checked> Commissures</label>
          <label class="switch"><input data-layer="coaptation" type="checkbox" checked> Coaptation Line</label>
          <label class="switch"><input data-layer="labels" type="checkbox" checked> Floating Labels</label>
          <label class="switch"><input data-layer="backdrop" type="checkbox" checked> Backdrop Volume</label>
        </div>
      </div>

      <div class="panel">
        <h4>Quick Camera</h4>
        <div class="toolrow">
          <button class="toolbtn" data-focus="annulus">Focus Annulus</button>
          <button class="toolbtn" data-focus="anterior">Focus Anterior</button>
          <button class="toolbtn" data-focus="posterior">Focus Posterior</button>
          <button class="toolbtn" data-focus="commAL">Focus A‚ÄëL Comm.</button>
          <button class="toolbtn" data-focus="commPM">Focus P‚ÄëM Comm.</button>
          <button class="toolbtn" data-focus="reset">Reset</button>
        </div>
        <div class="small" style="margin-top:8px">
          <b>Orbit</b> drag ¬∑ <b>Pan</b> shift+drag ¬∑ <b>Zoom</b> wheel ¬∑ Hotkeys:
          <kbd>1</kbd> Annulus <kbd>2</kbd> A‚Äëleaflet <kbd>3</kbd> P‚Äëleaflet <kbd>4</kbd>/<kbd>5</kbd> Commissures
        </div>
      </div>

      <div class="panel">
        <h4>Step Guide</h4>
        <div id="stepBox" class="step">
          <div class="t">Step 1 ‚Äî Mitral Annulus</div>
          <div class="d">The annulus is an elliptical fibrous ring. It is saddle‚Äëshaped with highest points anteriorly/posteriorly.</div>
        </div>
        <div class="row" style="margin-top:8px">
          <button id="btnPrev" class="btn secondary">‚óÄ Prev</button>
          <button id="btnNext" class="btn secondary">Next ‚ñ∂</button>
        </div>
      </div>

      <div class="panel">
        <h4>KPIs</h4>
        <div class="kpis2">
          <div class="k"><div class="label">Hovered</div><div id="kHovered" class="value">‚Äî</div></div>
          <div class="k"><div class="label">Identify Score</div><div id="kScore" class="value">0</div></div>
          <div class="k"><div class="label">Outline</div><div class="value"><span id="swOut" class="swatch" style="background:#7fb6ff"></span></div></div>
        </div>
      </div>
    </aside>

    <!-- Main -->
    <main>
      <div id="canvasWrap" class="canvas-wrap">
        <div id="overlay"></div>
        <div class="hud">Module 1.1 ¬∑ Overview</div>
      </div>
      <div class="row" style="margin-top:10px; gap:12px">
        <div class="chip"><b>Task:</b> <span id="task">Explore the mitral annulus, leaflets, and commissures. Hover to highlight; click to pin a label.</span></div>
        <div class="chip"><b>Status:</b> <span id="status">Ready</span></div>
      </div>
    </main>
  </div>

  <div class="footer small">¬© 2025 MitralSim Pro ‚Äî Educational prototype ¬∑ Not a medical device.</div>

  <!-- ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà -->
  <!--                                SCRIPT                                  -->
  <!-- ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà -->
  <script type="module">
    import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js';
    import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/controls/OrbitControls.js';
    import { EffectComposer } from 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/postprocessing/EffectComposer.js';
    import { RenderPass } from 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/postprocessing/UnrealBloomPass.js';
    import { OutlinePass } from 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/postprocessing/OutlinePass.js';
    import { ShaderPass } from 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/postprocessing/ShaderPass.js';
    import { FXAAShader } from 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/shaders/FXAAShader.js';
    import { RoomEnvironment } from 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/environments/RoomEnvironment.js';

    // -------------------- DOM refs --------------------
    const wrap = document.getElementById('canvasWrap');
    const overlay = document.getElementById('overlay');
    const stepBox = document.getElementById('stepBox');
    const statusEl = document.getElementById('status');
    const taskEl = document.getElementById('task');
    const kHovered = document.getElementById('kHovered');
    const kScore   = document.getElementById('kScore');
    const swOut    = document.getElementById('swOut');

    // -------------------- Renderer & Scene --------------------
    const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true });
    renderer.setPixelRatio(Math.min(2, window.devicePixelRatio||1));
    renderer.setSize(wrap.clientWidth, wrap.clientHeight);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    wrap.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x070a10, 0.08);

    const camera = new THREE.PerspectiveCamera(45, wrap.clientWidth/wrap.clientHeight, 0.02, 50);
    camera.position.set(0.9, 1.0, 2.9);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true; controls.dampingFactor = 0.08;
    controls.minDistance = 1.1; controls.maxDistance = 5.5;
    controls.target.set(0,0.18,0); controls.update();

    // PBR environment
    const pmrem = new THREE.PMREMGenerator(renderer);
    scene.environment = pmrem.fromScene(new RoomEnvironment(renderer), .7).texture;

    // Lights
    scene.add(new THREE.AmbientLight(0x52606e, .45));
    const key = new THREE.DirectionalLight(0xffffff, .85);
    key.position.set(2.5, 3.5, 3.0);
    key.castShadow = true; key.shadow.mapSize.set(1024,1024);
    key.shadow.camera.near = 0.1; key.shadow.camera.far = 12;
    scene.add(key);

    const fill = new THREE.DirectionalLight(0x99aaff, .35); fill.position.set(-2.2, 1.2, -2.0); scene.add(fill);
    const rim  = new THREE.DirectionalLight(0x3344aa, .3); rim.position.set(0.5, 1.8, -1.5); scene.add(rim);

    // Ground catch (soft shadow plane)
    const ground = new THREE.Mesh(
      new THREE.PlaneGeometry(8,8),
      new THREE.ShadowMaterial({ color: 0x000000, opacity: .18 })
    );
    ground.rotation.x = -Math.PI/2; ground.position.y = -0.25; ground.receiveShadow = true; scene.add(ground);

    // -------------------- Post‚Äëprocessing --------------------
    const composer = new EffectComposer(renderer);
    const renderPass = new RenderPass(scene, camera);
    composer.addPass(renderPass);

    const outlinePass = new OutlinePass(new THREE.Vector2(wrap.clientWidth, wrap.clientHeight), scene, camera);
    outlinePass.edgeStrength = 3.0;
    outlinePass.edgeGlow = .6;
    outlinePass.edgeThickness = 0.032 / 0.016; // relative to FXAA resolution
    outlinePass.pulsePeriod = 2.5;
    outlinePass.visibleEdgeColor.set('#7fb6ff');
    outlinePass.hiddenEdgeColor.set('#2a5bb7');
    composer.addPass(outlinePass);

    const fxaaPass = new ShaderPass(FXAAShader);
    fxaaPass.material.uniforms['resolution'].value.set(1/(wrap.clientWidth*renderer.getPixelRatio()), 1/(wrap.clientHeight*renderer.getPixelRatio()));
    composer.addPass(fxaaPass);

    const bloomPass = new UnrealBloomPass(new THREE.Vector2(wrap.clientWidth, wrap.clientHeight), 0.8, 0.32, 0.85);
    composer.addPass(bloomPass);

    // -------------------- Scene content root --------------------
    const root = new THREE.Group();
    scene.add(root);

    // Backdrop volumetric shell (subtle gradient)
    const backdrop = new THREE.Mesh(
      new THREE.SphereGeometry(10, 48, 32),
      new THREE.ShaderMaterial({
        side: THREE.BackSide, transparent:true, depthWrite:false,
        uniforms: {
          c1:{value:new THREE.Color('#09121d')},
          c2:{value:new THREE.Color('#0b1b2e')},
          fogC:{value:new THREE.Color('#0a0f19')}
        },
        vertexShader: `
          varying vec3 vPos;
          void main(){
            vPos = position;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);
          }
        `,
        fragmentShader: `
          varying vec3 vPos;
          uniform vec3 c1; uniform vec3 c2; uniform vec3 fogC;
          void main(){
            float h = normalize(vPos).y * 0.5 + 0.5;
            vec3 col = mix(c1, c2, h);
            gl_FragColor = vec4(mix(col, fogC, 0.2), 0.95);
          }
        `
      })
    );
    root.add(backdrop);

    // -------------------- Mitral Apparatus Geometry --------------------
    const groupValve = new THREE.Group(); groupValve.position.set(0,0.0,0); root.add(groupValve);

    // Annulus ‚Äî elliptical, mildly saddle shaped torus
    const annulus = makeAnnulus();
    annulus.name = 'Mitral Annulus';
    groupValve.add(annulus);

    // Leaflets ‚Äî physical material with sheen to mimic moist tissue
    const leafletA = makeLeaflet(+1, 0x78b99a, 'Anterior Leaflet');
    const leafletP = makeLeaflet(-1, 0x86b79d, 'Posterior Leaflet');
    groupValve.add(leafletA, leafletP);

    // Coaptation line ‚Äî thin ribbon at leaflet edges
    const coaptation = makeCoaptationLine();
    coaptation.name = 'Coaptation Line';
    groupValve.add(coaptation);

    // Commissures ‚Äî anterolateral (AL, left viewer side) & posteromedial (PM, right rear)
    const commissures = new THREE.Group(); commissures.name = 'Commissures';
    const commAL = makeCommissure( 0.85,  0.75, 'Anterolateral Commissure');
    const commPM = makeCommissure(-2.25, -2.35, 'Posteromedial Commissure');
    commissures.add(commAL, commPM);
    groupValve.add(commissures);

    // Labels anchors (for overlay)
    const anchors = [
      { obj: annulus,   title:'Mitral Annulus', meta:'Elliptical, saddle‚Äëshaped fibrous ring' },
      { obj: leafletA,  title:'Anterior Leaflet (A)', meta:'Broad, near LVOT/AMC; smooth edge' },
      { obj: leafletP,  title:'Posterior Leaflet (P)', meta:'Scalloped (P1‚ÄìP3); shorter height' },
      { obj: commAL,    title:'Anterolateral Commissure', meta:'Junction A1‚ÄìP1' },
      { obj: commPM,    title:'Posteromedial Commissure', meta:'Junction A3‚ÄìP3' }
    ];

    // Picking registry
    const pickables = new Set([annulus, leafletA, leafletP, commAL, commPM, coaptation]);

    // -------------------- Materials & helpers --------------------
    function makeAnnulus(){
      // Base torus ‚Üí elliptic scale; sculpt y to saddle using custom shader
      const geo = new THREE.TorusGeometry(0.62, 0.05, 48, 320);
      const mat = new THREE.MeshPhysicalMaterial({
        color: 0x2c8a51, metalness:0.05, roughness:0.4, transmission:0.0, thickness:0.2,
        clearcoat: 0.6, clearcoatRoughness: 0.3, sheen: 1.0, sheenRoughness: 0.9, sheenColor: new THREE.Color(0x99f0c8),
        envMapIntensity: 0.38
      });
      const mesh = new THREE.Mesh(geo, mat);
      mesh.scale.set(1.25, 1.0, 1.05);
      mesh.rotation.x = Math.PI/2;
      mesh.castShadow = true; mesh.receiveShadow = true;

      // Subtle saddle shape by per-vertex displacement
      const pos = geo.attributes.position;
      for(let i=0;i<pos.count;i++){
        const x = pos.getX(i), z = pos.getZ(i);
        const theta = Math.atan2(z, x);
        const saddle = 0.05 * Math.sin(2*theta);
        pos.setY(i, pos.getY(i) + saddle);
      }
      pos.needsUpdate = true;
      return mesh;
    }

    function makeLeaflet(sign=+1, baseColor=0x7fbba0, name='Leaflet'){
      const w=1.35, h=0.52, segX=64, segY=24;
      const geo = new THREE.PlaneGeometry(w, h, segX, segY);
      geo.rotateX(-Math.PI/2);
      // slight posterior/anterior offset for hinge
      geo.translate(0, 0.22 + sign*0.07, 0.0);

      // sculpt: bulge + scallop + hinge curvature
      const pos = geo.attributes.position;
      const norm = new Float32Array(pos.count*3); // later for custom shading if needed
      for(let i=0;i<pos.count;i++){
        const x = pos.getX(i), z = pos.getZ(i);
        const bulge   = Math.exp(-Math.abs(x)*0.9) * 0.09 * sign;
        const scallop = Math.sin((x*1.8) + (sign>0?0.2:-0.1))*0.03 * sign;
        const hinge   = -0.015 * Math.sign(sign) * (z>0?1:-1);
        pos.setY(i, pos.getY(i) + bulge + scallop + hinge);
        // store a pseudo anisotropy vector in "norm"
        norm[i*3+0] = Math.cos(x*2.0); norm[i*3+1] = 0.0; norm[i*3+2] = Math.sin(x*2.0);
      }
      geo.setAttribute('aniso', new THREE.BufferAttribute(norm, 3));
      pos.needsUpdate = true;

      const mat = new THREE.MeshPhysicalMaterial({
        color: baseColor,
        metalness: 0.05, roughness: 0.45,
        clearcoat: 0.8, clearcoatRoughness: 0.22,
        sheen: 1.0, sheenRoughness: 0.6, sheenColor: new THREE.Color(0xcfeee0),
        transmission: 0.08, thickness: 0.25, ior: 1.35,
        side: THREE.DoubleSide, envMapIntensity: 0.5
      });

      const mesh = new THREE.Mesh(geo, mat);
      mesh.name = name; mesh.castShadow = true; mesh.receiveShadow = true;
      return mesh;
    }

    function makeCoaptationLine(){
      // very thin circular line slightly inside annulus radius
      const r = 0.60; const pts = [];
      for(let i=0;i<=200;i++){
        const t = i/200 * Math.PI*2;
        pts.push(new THREE.Vector3(Math.cos(t)*r, 0.222 + 0.002*Math.sin(2*t), Math.sin(t)*r));
      }
      const geo = new THREE.BufferGeometry().setFromPoints(pts);
      const mat = new THREE.LineBasicMaterial({ color:0x9fe3ff, transparent:true, opacity:0.68 });
      const line = new THREE.Line(geo, mat); line.name='Coaptation Line';
      return line;
    }

    function makeCommissure(a0, a1, label){
      // small arc on annulus, glowing material
      const r=0.64, tube=0.018;
      const start=a0, end=a1; // radians
      const shape = new THREE.Shape();
      shape.absarc(0,0,r+tube, start, end, false);
      const hole = new THREE.Path(); hole.absarc(0,0,r-tube, end, start, true);
      shape.holes.push(hole);
      const geo = new THREE.ShapeGeometry(shape, 60);
      const mat = new THREE.MeshPhysicalMaterial({
        color: 0xf0d47f,
        emissive: 0x332000,
        roughness: 0.45, metalness: 0.35, clearcoat: 0.6, clearcoatRoughness: 0.3
      });
      const mesh = new THREE.Mesh(geo, mat);
      mesh.rotation.x = Math.PI/2;
      mesh.position.y = 0.223;
      mesh.name = label;
      mesh.castShadow = true; mesh.receiveShadow = true;
      return mesh;
    }

    // -------------------- Micro‚Äëanimation (lifelike) --------------------
    const motion = { t:0, pulseAmp: 0.35 };
    function animateLeaflets(dt){
      motion.t += dt;
      const a = motion.pulseAmp * 0.0025; // amplitude in meters
      const yA = a * Math.sin(motion.t*2.1);
      const yP = a * Math.sin(motion.t*2.1 + Math.PI);
      leafletA.position.y = 0.29 + yA;
      leafletP.position.y = 0.15 + yP;
      // subtle rim shimmer
      const cc = 0.6 + 0.1*Math.sin(motion.t*1.8);
      leafletA.material.clearcoat = cc; leafletP.material.clearcoat = cc;
    }

    // -------------------- Overlay labels --------------------
    const pinned = [];
    function screenXY(vec3){
      const v = vec3.clone().project(camera);
      const x = (v.x * 0.5 + 0.5) * wrap.clientWidth;
      const y = (-v.y * 0.5 + 0.5) * wrap.clientHeight;
      return {x,y, on: (v.z<1)};
    }
    function addCalloutAt(obj, title, meta){
      const box = document.createElement('div'); box.className='callout';
      const h = document.createElement('div'); h.className='title'; h.textContent = title; box.appendChild(h);
      if(meta){ const m=document.createElement('div'); m.className='meta'; m.textContent=meta; box.appendChild(m); }
      overlay.appendChild(box);
      pinned.push({ obj, box });

      // also add a pin dot
      const dot = document.createElement('div'); dot.className='pin'; overlay.appendChild(dot);
      pinned[pinned.length-1].dot = dot;
    }
    function clearOverlay(){ overlay.innerHTML=''; pinned.length = 0; }
    function updateOverlay(){
      pinned.forEach((p,i)=>{
        const center = new THREE.Vector3();
        p.obj.getWorldPosition(center);
        const {x,y,on} = screenXY(center);
        p.box.style.left = (x + 12) + 'px';
        p.box.style.top  = (y - 12) + 'px';
        p.box.style.opacity = on? '1':'0';
        p.dot.style.left = (x - 5) + 'px';
        p.dot.style.top  = (y - 5) + 'px';
        p.dot.style.opacity = on? '1':'0';
      });
    }

    // Seed a few key labels initially (can be toggled via "labels" layer)
    anchors.forEach(a => addCalloutAt(a.obj, a.title, a.meta));

    // -------------------- Interactions & hover highlight --------------------
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    let hovered = null;

    function setHovered(obj){
      if(hovered === obj) return;
      hovered = obj;
      outlinePass.selectedObjects = obj ? [obj] : [];
      kHovered.textContent = obj ? (obj.name || '‚Äî') : '‚Äî';
    }

    renderer.domElement.addEventListener('mousemove', (e)=>{
      const rect = renderer.domElement.getBoundingClientRect();
      mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
      mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
    });

    renderer.domElement.addEventListener('click', ()=>{
      if(!hovered) return;
      // pin a label if clicked
      addCalloutAt(hovered, hovered.name, hintFor(hovered));
      statusEl.textContent = 'Pinned: ' + hovered.name;
      score(2); // small exploration score
    });

    function hintFor(obj){
      switch(obj){
        case annulus: return 'Elliptical, saddle profile; sutures/repairs reference line.';
        case leafletA: return 'Broader leaflet; near LVOT/AMC; higher height.';
        case leafletP: return 'Scalloped P1‚ÄìP3; shorter height.';
        case coaptation: return 'Approximation line where leaflets meet.';
        default:
          if(obj && obj.name && obj.name.includes('Commissure')){
            return 'Leaflet junction: A‚ÄìP transition.';
          }
          return '';
      }
    }

    // Picking update (each frame)
    function updateHover(){
      raycaster.setFromCamera(mouse, camera);
      const intersects = raycaster.intersectObjects(Array.from(pickables), true);
      if(intersects.length>0){
        // prefer commissure arcs > annulus > leaflets > line
        intersects.sort((a,b)=>{
          const p = priority(a.object), q = priority(b.object);
          return p-q;
        });
        setHovered(getRoot(intersects[0].object));
      }else{
        setHovered(null);
      }
    }
    function priority(o){
      const name = getRoot(o).name || '';
      if(name.includes('Commissure')) return 0;
      if(name.includes('Annulus'))    return 1;
      if(name.includes('Leaflet'))    return 2;
      if(name.includes('Coaptation')) return 3;
      return 4;
    }
    function getRoot(o){ while(o.parent && o.parent!==scene && !pickables.has(o)) o=o.parent; return o; }

    // -------------------- Camera focus helpers --------------------
    const tmpV = new THREE.Vector3();
    function focusObject(obj, dist=2.2, elev=0.7){
      obj.getWorldPosition(tmpV);
      // simple tween
      const start = camera.position.clone();
      const startT = controls.target.clone();
      const endT = tmpV.clone();
      const dir = tmpV.clone().add(new THREE.Vector3(dist*.3, elev, dist*.5));
      const end = dir;
      let t=0;
      const animateFocus = (dt)=>{
        t += dt*1.4;
        const k = Math.min(1, t);
        camera.position.lerpVectors(start, end, easeInOutCubic(k));
        controls.target.lerpVectors(startT, endT, easeInOutCubic(k));
        if(k>=1) tickers.delete(animateFocus);
      };
      tickers.add(animateFocus);
    }
    function easeInOutCubic(x){ return x<0.5 ? 4*x*x*x : 1 - Math.pow(-2*x + 2, 3) / 2; }

    // Quick camera buttons
    document.querySelectorAll('[data-focus]').forEach(btn=>{
      btn.addEventListener('click', ()=>{
        const where = btn.getAttribute('data-focus');
        if(where==='annulus')   focusObject(annulus, 2.0, 0.6);
        if(where==='anterior')  focusObject(leafletA, 2.2, 0.7);
        if(where==='posterior') focusObject(leafletP, 2.2, 0.65);
        if(where==='commAL')    focusObject(commAL, 2.1, 0.55);
        if(where==='commPM')    focusObject(commPM, 2.1, 0.55);
        if(where==='reset') { controls.target.set(0,0.18,0); camera.position.set(0.9,1.0,2.9); }
        controls.update();
      });
    });

    window.addEventListener('keydown', (e)=>{
      if(e.key==='1') focusObject(annulus, 2.0, 0.6);
      if(e.key==='2') focusObject(leafletA, 2.2, 0.7);
      if(e.key==='3') focusObject(leafletP, 2.2, 0.65);
      if(e.key==='4') focusObject(commAL, 2.1, 0.55);
      if(e.key==='5') focusObject(commPM, 2.1, 0.55);
    });

    // -------------------- Step Guide (Guided mode) --------------------
    const steps = [
      { id:'annulus',  title:'Step 1 ‚Äî Mitral Annulus',      desc:'Elliptical, saddle‚Äëshaped fibrous ring. Hover to inspect; click to pin a label.', focus: annulus },
      { id:'anterior', title:'Step 2 ‚Äî Anterior Leaflet (A)', desc:'Broader leaflet adjacent to the LVOT/AMC. Smooth curved free edge.', focus: leafletA },
      { id:'posterior',title:'Step 3 ‚Äî Posterior Leaflet (P)',desc:'Scalloped leaflet (P1‚ÄìP3) with shorter height.', focus: leafletP },
      { id:'comm',     title:'Step 4 ‚Äî Commissures',          desc:'Anterolateral (A1‚ÄìP1) and Posteromedial (A3‚ÄìP3) leaflet junctions.', focus: commAL }
    ];
    let stepIndex = 0;

    function renderStep(){
      const s = steps[stepIndex];
      stepBox.innerHTML = `<div class="t">${s.title}</div><div class="d">${s.desc}</div>`;
      focusObject(s.focus, 2.2, 0.65);
      // glow emphasis target
      outlinePass.selectedObjects = [s.focus];
      statusEl.textContent = 'Guided: ' + s.title;
    }

    document.getElementById('btnPrev').addEventListener('click', ()=>{
      stepIndex = Math.max(0, stepIndex-1); renderStep();
    });
    document.getElementById('btnNext').addEventListener('click', ()=>{
      stepIndex = Math.min(steps.length-1, stepIndex+1); renderStep();
    });

    // -------------------- Modes: Guided / Explore / Identify --------------------
    const btnGuide = document.getElementById('btnGuide');
    const btnExplore = document.getElementById('btnExplore');
    const btnIdentify = document.getElementById('btnIdentify');
    const modes = { mode:'guided', score:0 };

    btnGuide.addEventListener('click', ()=> setMode('guided'));
    btnExplore.addEventListener('click', ()=> setMode('explore'));
    btnIdentify.addEventListener('click', ()=> setMode('identify'));

    function setMode(m){
      modes.mode = m;
      btnGuide.dataset.active = (m==='guided')?'1':'0';
      btnExplore.dataset.active = (m==='explore')?'1':'0';
      btnIdentify.dataset.active = (m==='identify')?'1':'0';
      if(m==='guided'){
        stepIndex=0; renderStep();
        taskEl.textContent = 'Follow the step guide. Hover to highlight; click to pin labels.';
      } else if(m==='explore'){
        outlinePass.selectedObjects = [];
        statusEl.textContent = 'Exploration mode';
        taskEl.textContent = 'Free explore. Toggle layers, adjust look, pin labels anywhere.';
      } else {
        // identify: random target requested
        requestIdentify();
      }
    }

    function requestIdentify(){
      const items = [annulus, leafletA, leafletP, commAL, commPM];
      const pick = items[Math.floor(Math.random()*items.length)];
      modes.expect = pick;
      outlinePass.selectedObjects = []; // no hint
      taskEl.textContent = 'Identify: ' + (pick.name);
      statusEl.textContent = 'Click the structure that matches the requested name (no outline hint).';
      focusObject(pick, 2.3, 0.7);
    }

    function score(delta){
      modes.score = Math.max(0, modes.score + delta);
      kScore.textContent = modes.score.toFixed(0);
    }

    // In identify mode, clicking a correct structure increases score, else decreases
    renderer.domElement.addEventListener('click', ()=>{
      if(modes.mode!=='identify' || !hovered) return;
      if(getRoot(hovered) === modes.expect){
        statusEl.textContent = 'Correct ‚úì';
        score(10);
      } else {
        statusEl.textContent = 'Incorrect ‚úó';
        score(-6);
      }
      // queue next
      setTimeout(requestIdentify, 500);
    });

    // -------------------- Layer toggles --------------------
    document.getElementById('layers').addEventListener('change', (e)=>{
      if(!(e.target instanceof HTMLInputElement)) return;
      const key = e.target.dataset.layer, v = e.target.checked;
      if(key==='annulus') annulus.visible = v;
      if(key==='leafletA') leafletA.visible = v;
      if(key==='leafletP') leafletP.visible = v;
      if(key==='commissures') commissures.visible = v;
      if(key==='coaptation') coaptation.visible = v;
      if(key==='labels'){ if(!v) clearOverlay(); else { overlay.innerHTML=''; anchors.forEach(a=> addCalloutAt(a.obj, a.title, a.meta)); } }
      if(key==='backdrop') backdrop.visible = v;
    });

    // Cinematic sliders
    const rngBloom = document.getElementById('rngBloom');
    const rngOutline = document.getElementById('rngOutline');
    const rngPulse = document.getElementById('rngPulse');
    rngBloom.addEventListener('input', ()=> bloomPass.strength = parseFloat(rngBloom.value));
    rngOutline.addEventListener('input', ()=>{
      const t = parseFloat(rngOutline.value);
      outlinePass.edgeThickness = t / 0.016;
    });
    rngPulse.addEventListener('input', ()=> motion.pulseAmp = parseFloat(rngPulse.value));

    // swatch color indicator (outline)
    swOut.style.background = '#7fb6ff';

    // -------------------- Ticker / loop --------------------
    const tickers = new Set();
    let last = performance.now();
    function loop(now){
      const dt = Math.min(0.033, (now - last)/1000); last = now;
      tickers.forEach(fn=> fn(dt));
      animateLeaflets(dt);
      updateHover();
      updateOverlay();
      controls.update();
      composer.render();
      requestAnimationFrame(loop);
    }
    requestAnimationFrame(loop);

    // Guided by default
    setMode('guided');
    renderStep();

    // -------------------- Resize handling --------------------
    window.addEventListener('resize', ()=>{
      const w = wrap.clientWidth, h=wrap.clientHeight;
      camera.aspect = w/h; camera.updateProjectionMatrix();
      renderer.setSize(w,h);
      composer.setSize(w,h);
      outlinePass.setSize(w,h);
      fxaaPass.material.uniforms['resolution'].value.set(1/(w*renderer.getPixelRatio()), 1/(h*renderer.getPixelRatio()));
    });

  </script>
</body>
</html>
