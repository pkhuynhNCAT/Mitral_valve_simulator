<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Mitral Suture Trainer â€” Triangular Resection Closure (P2)</title>
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" />
<style>
  :root{
    --bg:#0b0f14; --ink:#eaf2f8; --mut:#9fb3c4; --ok:#2ed573; --warn:#ffb020; --bad:#ff4d4f;
    --panel:#0f151d; --card:#0a1117; --line:#1f2b36; --accent:#52e2c0; --accent2:#8ad0ff;
    --mono: ui-monospace,Menlo,Consolas,monospace; --sans: ui-sans-serif,system-ui,Segoe UI,Roboto,Helvetica,Arial;
  }
  html,body{margin:0;height:100%;background:var(--bg);color:var(--ink);font:14px/1.4 var(--sans)}
  #app{display:grid;grid-template-rows:56px 1fr 30px;height:100%}
  header{display:flex;gap:12px;align-items:center;padding:10px 14px;background:linear-gradient(180deg,#0e1520,#0b1218);border-bottom:1px solid #182330}
  header h1{margin:0;font-size:16px;font-weight:700}
  #toolbar{margin-left:auto;display:flex;gap:10px;flex-wrap:wrap;align-items:center}
  #toolbar .grp{display:flex;gap:10px;align-items:center;background:#0f1823;border:1px solid #1b2733;border-radius:10px;padding:6px 8px}
  label{color:var(--mut);font-size:12px}
  select,button{background:#101825;color:#e6f0f6;border:1px solid #223243;border-radius:8px;padding:6px 10px;cursor:pointer}
  button:active{transform:translateY(1px)}
  main{display:grid;grid-template-columns:340px 1fr}
  aside{background:var(--panel);border-right:1px solid #1b2733;padding:12px;overflow:auto}
  aside h2{font-size:12px;letter-spacing:.1em;text-transform:uppercase;color:#a7bed1;margin:12px 0 8px}
  .card{background:rgba(9,14,19,.82);border:1px solid var(--line);border-radius:12px;padding:10px;margin-bottom:10px;backdrop-filter:blur(5px)}
  .kpi{display:flex;justify-content:space-between;font-family:var(--mono);font-weight:700}
  .pill{display:inline-block;border:1px solid #223243;border-radius:999px;padding:3px 8px;color:#a6c1d5;font-size:11px;margin:4px 4px 0 0}
  .toolbtn{display:flex;gap:6px;align-items:center;width:100%}
  .toolbtn.active{outline:2px solid #3c5977}
  #stage{position:relative;background:radial-gradient(60% 70% at 50% 50%,#0c141b 0%,#0a1016 100%)}
  canvas{display:block;width:100%;height:100%}
  #hud{position:absolute;top:10px;left:10px;display:grid;gap:8px;pointer-events:none}
  #hud .card{pointer-events:auto;min-width:260px}
  footer{display:flex;gap:10px;align-items:center;padding:6px 10px;border-top:1px solid #182330;color:#8dadc1}
  #status{color:#cfe8ff}
  .ok{color:var(--ok)} .warn{color:var(--warn)} .bad{color:var(--bad)}
</style>
</head>
<body>
<div id="app">
  <header>
    <h1>Mitral Suture Trainer â€” P2 Triangular Resection Closure</h1>
    <div id="toolbar">
      <div class="grp">
        <label>Mode</label>
        <select id="mode">
          <option value="teach">Teach (guided)</option>
          <option value="assess">Assess (scored)</option>
        </select>
      </div>
      <div class="grp">
        <label>Case</label>
        <select id="case">
          <option value="p2_mid">P2 central wedge</option>
          <option value="p2_wide">P2 wide wedge</option>
          <option value="p2_small">P2 small wedge</option>
        </select>
        <button id="load">Load case</button>
      </div>
      <div class="grp">
        <button id="start">Start</button>
        <button id="reset">Reset</button>
        <button id="export">Export JSON</button>
      </div>
    </div>
  </header>

  <main>
    <aside>
      <h2>Tools</h2>
      <div class="card">
        <button class="toolbtn" id="tool_place">ğŸª¡ Place bite (entry â†’ exit)</button>
        <button class="toolbtn" id="tool_tension">ğŸ¯ Tighten knot (set tension)</button>
        <button class="toolbtn" id="tool_remove">ğŸ§¹ Remove last bite</button>
        <button class="toolbtn" id="tool_finish">âœ… Finish & score</button>
      </div>

      <h2>Targets (guidance)</h2>
      <div class="card">
        <div>â€¢ Bite depth: <b>4â€“6 mm</b> from cut edge (both sides)</div>
        <div>â€¢ Bite angle: ~<b>60Â°Â±15Â°</b> to edge</div>
        <div>â€¢ Spacing: uniform (~<b>4â€“5 mm</b>) along wedge</div>
        <div>â€¢ Symmetry: entryâ‰ˆexit depth</div>
        <div>â€¢ Tension: <b>coaptation flush</b> (no gap, no strangulation)</div>
      </div>

      <h2>Session metrics</h2>
      <div class="card" id="scoreSummary">
        <div class="kpi"><span>Bites placed</span><span id="biteN">0</span></div>
        <div class="kpi"><span>Avg depth error</span><span id="depthErr">â€”</span></div>
        <div class="kpi"><span>Avg angle error</span><span id="angleErr">â€”</span></div>
        <div class="kpi"><span>Spacing CV</span><span id="spacing">â€”</span></div>
        <div class="kpi"><span>Symmetry error</span><span id="sym">â€”</span></div>
        <div class="kpi"><span>Residual gap</span><span id="gap">â€”</span></div>
        <div class="kpi"><span>Overall</span><span id="overall">â€”</span></div>
      </div>

      <h2>Shortcuts</h2>
      <div class="card">
        <div class="pill">Click on <b>left edge</b> â†’ then <b>right edge</b> to place one bite</div>
        <div class="pill">Enter tension: drag slider on the suture</div>
        <div class="pill">Z: remove last â€¢ F: finish & score</div>
      </div>
    </aside>

    <section id="stage">
      <div id="hud">
        <div class="card">
          <div style="font-weight:700;margin-bottom:6px">Step</div>
          <div id="stepText">Click left edge (entry)</div>
        </div>
        <div class="card">
          <div style="font-weight:700;margin-bottom:6px">Realtime feedback</div>
          <div id="fb">â€”</div>
        </div>
      </div>
    </section>
  </main>

  <footer>
    <div>Realistic needle arc, bite metrics, suture tension. For education; not a medical device.</div>
    <div id="status"></div>
  </footer>
</div>

<script type="module">
/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Resilient loader for Three.js â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
const statusEl = document.getElementById('status');
function setStatus(t, cls=''){ statusEl.textContent=t; statusEl.className=cls; }
async function loadThree() {
  const tries = [
    async ()=>({ THREE: await import('https://unpkg.com/three@0.160.0/build/three.module.js'),
                 OrbitControls: (await import('https://unpkg.com/three@0.160.0/examples/jsm/controls/OrbitControls.js')).OrbitControls }),
    async ()=>({ THREE: await import('https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js'),
                 OrbitControls: (await import('https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/controls/OrbitControls.js')).OrbitControls }),
    async ()=>({ THREE: await import('https://esm.sh/three@0.160.0'),
                 OrbitControls: (await import('https://esm.sh/three@0.160.0/examples/jsm/controls/OrbitControls.js')).OrbitControls })
  ];
  let lastErr=null;
  for (const t of tries){ try { return await t(); } catch(e){ lastErr=e; } }
  throw lastErr || new Error('Failed to load Three.js');
}
setStatus('Loading 3D engineâ€¦');
const { THREE, OrbitControls } = await loadThree().catch(e=>{ console.error(e); setStatus('Could not load 3D engine (CDN blocked?)', 'bad'); throw e; });
setStatus('Loaded.', 'ok');

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Scene / camera / lights â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
const stage = document.getElementById('stage');
const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true });
renderer.setSize(stage.clientWidth, stage.clientHeight);
renderer.setPixelRatio(Math.min(2, window.devicePixelRatio||1));
stage.appendChild(renderer.domElement);

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x0b1016);

const camera = new THREE.PerspectiveCamera(50, stage.clientWidth/stage.clientHeight, 0.1, 5000);
camera.position.set(0, 60, 150);

const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true; controls.dampingFactor=0.05; controls.minDistance=80; controls.maxDistance=260;

const hemi = new THREE.HemisphereLight(0xaad4ff, 0x0a0d10, 0.8);
const key  = new THREE.DirectionalLight(0xffffff, 1.05); key.position.set(180,220,160); key.castShadow = true;
const fill = new THREE.DirectionalLight(0x99bbff, 0.3); fill.position.set(-160,40,-80);
scene.add(hemi,key,fill);

const floor = new THREE.Mesh(new THREE.CircleGeometry(800,64), new THREE.MeshStandardMaterial({color:0x0b1219, metalness:0.2, roughness:0.9}));
floor.rotation.x = -Math.PI/2; floor.receiveShadow = true; scene.add(floor);

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Geometry: wedge edges & leaflet strips â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   Units: 1 = 1 mm. X = mediolateral, Y = superior (atrial), Z = anteroposterior
   We model the triangular resection as two ribbon surfaces separated by a wedge gap.
--------------------------------------------------------------------------- */
const mm = v=>v;
const EDGE_LEN = mm(40);      // length of the wedge edge (arc length)
const EDGE_SEGS = 40;         // sampling along the edge
const STRIP_W   = mm(8);      // strip width to represent leaflet thickness region for â€œdepthâ€ measure

function makeEdgeCurve(kind="mid"){ // left & right param curves with a small bow
  // Generate a shallow S-curved edge in XZ plane; Y slight saddle
  const points = [];
  for(let i=0;i<=EDGE_SEGS;i++){
    const t = i/EDGE_SEGS;
    const x = THREE.MathUtils.lerp(-EDGE_LEN/2, EDGE_LEN/2, t);
    const z = (kind==="wide"? mm(6): kind==="small"? mm(2): mm(4)) * Math.sin(t*Math.PI*1.0);
    const y = mm(1.5) * Math.cos(t*Math.PI*2);
    points.push(new THREE.Vector3(x,y,z));
  }
  const curve = new THREE.CatmullRomCurve3(points);
  return curve;
}
let caseKind = "mid";
const leftCurve  = makeEdgeCurve("mid");
const rightCurve = makeEdgeCurve("mid");
// Offset right curve in +Z to form the gap
function offsetCurve(curve, dz=mm(6)){ // clone + translate Z
  const pts = curve.getPoints(EDGE_SEGS).map(p=>p.clone().add(new THREE.Vector3(0,0,dz)));
  return new THREE.CatmullRomCurve3(pts);
}
let gapDZ = mm(6);
let left  = leftCurve;
let right = offsetCurve(rightCurve, gapDZ);

// Build a visible ribbon (strip) along a curve (for depth reference)
function makeStrip(curve, color){
  const pts = curve.getPoints(EDGE_SEGS);
  const geom = new THREE.BufferGeometry();
  const vtx = new Float32Array((EDGE_SEGS+1)*2*3);
  const idx = [];
  for(let i=0;i<=EDGE_SEGS;i++){
    const p = pts[i];
    const dir = (i<EDGE_SEGS? pts[i+1].clone().sub(pts[i]) : pts[i].clone().sub(pts[i-1])).normalize();
    const up  = new THREE.Vector3(0,1,0);
    const n = new THREE.Vector3().crossVectors(dir, up).normalize(); // lateral normal
    const a = p.clone().add(n.clone().multiplyScalar(STRIP_W/2));
    const b = p.clone().add(n.clone().multiplyScalar(-STRIP_W/2));
    vtx.set([a.x,a.y,a.z], i*6+0);
    vtx.set([b.x,b.y,b.z], i*6+3);
    if(i<EDGE_SEGS){
      const k=i*2; idx.push(k,k+1,k+2,  k+1,k+3,k+2);
    }
  }
  geom.setAttribute('position', new THREE.BufferAttribute(vtx,3));
  geom.setIndex(idx);
  geom.computeVertexNormals();
  const mat = new THREE.MeshStandardMaterial({color, metalness:.08, roughness:.85, side:THREE.DoubleSide});
  const mesh = new THREE.Mesh(geom, mat); mesh.castShadow=true; mesh.receiveShadow=true;
  return mesh;
}
let leftStrip  = makeStrip(left,  0xf0f6ff);
let rightStrip = makeStrip(right, 0xe3ecff);
scene.add(leftStrip, rightStrip);

// Landmarks
const apexBall = new THREE.Mesh(new THREE.SphereGeometry(1.6), new THREE.MeshStandardMaterial({color:0xffd28a, metalness:.3, roughness:.5}));
function placeApex(){
  const p = left.getPoint(EDGE_SEGS/2).clone().add(right.getPoint(EDGE_SEGS/2)).multiplyScalar(0.5);
  apexBall.position.copy(p); apexBall.position.y += mm(0.6);
}
placeApex(); scene.add(apexBall);

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Needle & Suture model â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   - Needle: 3/8 circle arc with radius ~16 mm, driven from entry to exit
   - Suture: rope with nodes; after "tighten", target length reduces â†’ edges approximate
--------------------------------------------------------------------------- */
const needleGroup = new THREE.Group(); scene.add(needleGroup);
function makeNeedle(radius=mm(8), span= Math.PI*3/8){
  const tube = new THREE.TorusGeometry(radius, 0.5, 12, 64, span);
  const mat  = new THREE.MeshStandardMaterial({color:0x9ab5c9, metalness:.8, roughness:.25});
  const mesh = new THREE.Mesh(tube, mat); mesh.rotation.y = Math.PI/2;
  return mesh;
}
function computeNeedlePath(entry, exit){
  // Plane spanning entryâ†’exit, arc center midway, radius from chord
  const mid = entry.clone().add(exit).multiplyScalar(0.5);
  const chord = exit.clone().sub(entry); const L=chord.length();
  const R = Math.max(mm(6), L/1.8); // pick radius so arc is realistic
  const up = new THREE.Vector3(0,1,0);
  const n = new THREE.Vector3().crossVectors(chord, up).normalize(); // approximate plane normal
  return { mid, n, R, span: Math.PI*0.8 }; // drive ~144Â°
}
function animateNeedle(entry, exit, onDone){
  needleGroup.clear();
  const {mid,n,R,span} = computeNeedlePath(entry, exit);
  const mesh = makeNeedle(R, span);
  needleGroup.add(mesh);
  // Build a local basis: z along chord, x ~ normal, y ~ up
  const z = exit.clone().sub(entry).normalize();
  const x = new THREE.Vector3().crossVectors(n, z).normalize();
  const y = new THREE.Vector3().crossVectors(z, x).normalize();
  const basis = new THREE.Matrix4().makeBasis(x,y,z);
  const pos = new THREE.Matrix4().makeTranslation(mid.x, mid.y, mid.z);
  mesh.matrixAutoUpdate=false;
  let t=0;
  function tick(){
    t += 0.03;
    const angle = -span/2 + span*Math.min(1,t);
    const rot = new THREE.Matrix4().makeRotationX(angle);
    mesh.matrix = pos.clone().multiply(basis).multiply(rot);
    renderer.render(scene,camera);
    if(t<1){ requestAnimationFrame(tick); } else { onDone && onDone(); }
  }
  tick();
}

// Suture rope (simple PBD line)
class Rope {
  constructor(a,b,segments=18){
    this.nodes=[]; this.prev=[];
    for(let i=0;i<=segments;i++){
      const p = a.clone().lerp(b, i/segments);
      this.nodes.push(p); this.prev.push(p.clone());
    }
    this.restLen = this.totalLength();
    this.targetScale = 1.0; // lowered on tightening
  }
  totalLength(){
    let L=0; for(let i=1;i<this.nodes.length;i++) L += this.nodes[i].distanceTo(this.nodes[i-1]);
    return L;
  }
  tighten(scale){ this.targetScale = Math.max(0.7, Math.min(1.0, scale)); }
  step(){
    // shorten total length toward restLen*targetScale by pulling interior nodes
    const want = this.restLen*this.targetScale, have=this.totalLength();
    const excess = have - want;
    if(Math.abs(excess)<0.01) return;
    const perSeg = excess/(this.nodes.length-1);
    for(let i=1;i<this.nodes.length-1;i++){
      const prev=this.nodes[i-1], cur=this.nodes[i], nxt=this.nodes[i+1];
      const v1 = cur.clone().sub(prev), v2 = nxt.clone().sub(cur);
      const u1 = v1.normalize(), u2 = v2.normalize();
      cur.addScaledVector(u1, -perSeg*0.25).addScaledVector(u2, perSeg*0.25);
    }
  }
  mesh(){
    const g = new THREE.BufferGeometry();
    const pos = new Float32Array(this.nodes.length*3);
    for(let i=0;i<this.nodes.length;i++){ const p=this.nodes[i]; pos.set([p.x,p.y,p.z], i*3); }
    g.setAttribute('position', new THREE.BufferAttribute(pos,3));
    const m = new THREE.LineBasicMaterial({color:0xfff2c2, linewidth:2});
    const line = new THREE.Line(g,m);
    line.userData.update = ()=>{
      const a = line.geometry.getAttribute('position');
      for(let i=0;i<this.nodes.length;i++){ const p=this.nodes[i]; a.setXYZ(i,p.x,p.y,p.z); }
      a.needsUpdate = true;
    };
    return line;
  }
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Task state & UI â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
const ui = {
  mode: document.getElementById('mode'),
  caseSel: document.getElementById('case'),
  loadBtn: document.getElementById('load'),
  startBtn: document.getElementById('start'),
  resetBtn: document.getElementById('reset'),
  exportBtn: document.getElementById('export'),
  tool_place: document.getElementById('tool_place'),
  tool_tension: document.getElementById('tool_tension'),
  tool_remove: document.getElementById('tool_remove'),
  tool_finish: document.getElementById('tool_finish'),
  stepText: document.getElementById('stepText'),
  fb: document.getElementById('fb'),
  biteN: document.getElementById('biteN'),
  depthErr: document.getElementById('depthErr'),
  angleErr: document.getElementById('angleErr'),
  spacing: document.getElementById('spacing'),
  sym: document.getElementById('sym'),
  gap: document.getElementById('gap'),
  overall: document.getElementById('overall')
};
let tool='place'; setTool('place');

ui.tool_place.onclick  = ()=> setTool('place');
ui.tool_tension.onclick= ()=> setTool('tension');
ui.tool_remove.onclick = removeLastBite;
ui.tool_finish.onclick = finalize;

document.addEventListener('keydown', (e)=>{
  if(e.key==='z' || e.key==='Z') removeLastBite();
  if(e.key==='f' || e.key==='F') finalize();
});

ui.loadBtn.onclick = ()=>{
  caseKind = ui.caseSel.value==='p2_wide'? "wide" : ui.caseSel.value==='p2_small'? "small" : "mid";
  gapDZ = (caseKind==="wide"? mm(8): caseKind==="small"? mm(4): mm(6));
  scene.remove(leftStrip,rightStrip);
  const base = makeEdgeCurve(caseKind);
  left = base;
  right = offsetCurve(base, gapDZ);
  leftStrip  = makeStrip(left,  0xf0f6ff);
  rightStrip = makeStrip(right, 0xe3ecff);
  scene.add(leftStrip, rightStrip);
  placeApex();
  clearAll();
  ui.fb.textContent='Case loaded.';
};
ui.startBtn.onclick = ()=>{ ui.fb.textContent='Start: click left edge (entry), then right edge (exit).'; };
ui.resetBtn.onclick = clearAll;
ui.exportBtn.onclick = exportJSON;

function setTool(t){
  tool=t;
  ['place','tension','remove','finish'].forEach(k=>{
    document.getElementById('tool_'+k).classList.toggle('active', k===t);
  });
  ui.stepText.textContent = (t==='place' ? 'Click left edge (entry)' : t==='tension' ? 'Drag suture slider to set tension' : t==='remove' ? 'Remove last bite' : 'Finish & score');
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Placement workflow â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
const ray = new THREE.Raycaster(); const mouse = new THREE.Vector2();
renderer.domElement.addEventListener('pointermove',(e)=> {
  const r = renderer.domElement.getBoundingClientRect();
  mouse.x = ((e.clientX-r.left)/r.width)*2-1; mouse.y = -((e.clientY-r.top)/r.height)*2+1;
});
renderer.domElement.addEventListener('pointerdown', onClick);

let step=0; // 0: entry, 1: exit
let entryP=null, exitP=null;

const bites = []; // {entry, exit, rope, line, depthL, depthR, angle, spacingFromPrev, symmetry, tension, residualGap}

function onClick(e){
  if(tool!=='place') return;
  ray.setFromCamera(mouse, camera);
  const hitL = ray.intersectObject(leftStrip, false)[0];
  const hitR = ray.intersectObject(rightStrip,false)[0];

  if(step===0){
    if(!hitL){ ui.fb.textContent='Place entry on LEFT edge.'; return; }
    entryP = hitL.point.clone();
    step=1; ui.stepText.textContent = 'Click right edge (exit)'; ui.fb.textContent='Good. Now click exit on RIGHT edge.';
    flash(entryP, 0x52e2c0);
  } else {
    if(!hitR){ ui.fb.textContent='Place exit on RIGHT edge.'; return; }
    exitP = hitR.point.clone();
    // animate needle, then lay rope, then score this bite
    animateNeedle(entryP, exitP, ()=>{
      const rope = new Rope(entryP, exitP, 18);
      const line = rope.mesh(); scene.add(line);
      bites.push( scoreBite(entryP, exitP, rope, line) );
      refreshScore();
      step=0; entryP=null; exitP=null;
      ui.stepText.textContent='Click left edge (entry)';
      ui.fb.textContent='Bite placed. Use â€œTighten knotâ€ to set tension.';
    });
  }
}

function flash(p, color=0x52e2c0){
  const m=new THREE.Mesh(new THREE.SphereGeometry(1.2), new THREE.MeshBasicMaterial({color}));
  m.position.copy(p); scene.add(m); setTimeout(()=>scene.remove(m), 900);
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Scoring utilities â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
function nearestOnStrip(curve, p){
  // project onto curve params by sampling
  let bestT=0, bestD=1e9;
  for(let i=0;i<=EDGE_SEGS;i++){
    const t=i/EDGE_SEGS, q=curve.getPoint(t);
    const d=q.distanceTo(p); if(d<bestD){ bestD=d; bestT=t; }
  }
  const q=curve.getPoint(bestT);
  const dir = curve.getTangent(bestT).normalize();
  const up  = new THREE.Vector3(0,1,0);
  const lateral = new THREE.Vector3().crossVectors(dir, up).normalize();
  return {t:bestT, pos:q, tangent:dir, lateral};
}
function depthFromEdge(curve, p){
  const pr = nearestOnStrip(curve,p);
  const d  = p.clone().sub(pr.pos);
  const depth = Math.abs(d.dot(pr.lateral)); // mm from the cut edge centerline (strip midline)
  return {depth, tangent: pr.tangent, lateral: pr.lateral, base: pr.pos};
}
function angleErrorDegrees(tangent, entryToExit){
  // desired near-perpendicular bite: the bite chord should be ~normal to edge tangent â†’ angle ~ 90Â°; we grade target 60Â°Â±15Â° (needle drive plane)
  const edge = tangent.clone().normalize();
  const chord = entryToExit.clone().normalize();
  const ang = THREE.MathUtils.radToDeg( Math.acos( clamp( Math.abs(edge.dot(chord)), -1, 1) ) ); // 0â†’parallel, 90â†’perp
  // Map to target ~60Â±15: error = |ang-60|
  return Math.abs(ang - 60);
}
function residualGapAfterTension(rope){
  // approximate: distance between edge bases minus effective shortening
  const L = rope.totalLength();
  const want = rope.restLen*rope.targetScale;
  const gain = L - want;
  return clamp( (gapDZ - gain*0.4), 0, gapDZ ); // crude mapping
}

function scoreBite(entry, exit, rope, line){
  // Lay the rope & attach an interactive tension slider in HUD (simple)
  rope.tighten(1.0); // initially loose
  const dL = depthFromEdge(left, entry), dR = depthFromEdge(right, exit);
  const chord = exit.clone().sub(entry);
  const angErr = angleErrorDegrees(dL.tangent, chord);
  const symErr = Math.abs(dL.depth - dR.depth);
  const spacing = bites.length>0 ? entry.distanceTo(bites.at(-1).entry) : NaN;

  // attach small UI slider in 3D (billboard)
  const tensionObj = makeTensionWidget(rope, line);
  scene.add(tensionObj);

  return {
    entry, exit, rope, line, tensionObj,
    depthL:dL.depth, depthR:dR.depth, angleErr:angErr, spacingFromPrev:spacing, symmetry:symErr,
    get residual(){ return residualGapAfterTension(rope); },
    get tension(){ return 1.0 - rope.targetScale; }
  };
}
function makeTensionWidget(rope, line){
  // simple DOM slider overlaying canvas (bottom-left of rope mid)
  const div = document.createElement('div');
  div.style.position='absolute'; div.style.left='12px'; div.style.bottom='12px'; div.style.background='rgba(9,14,19,.8)';
  div.style.border='1px solid #1f2b36'; div.style.borderRadius='8px'; div.style.padding='6px 8px'; div.style.color='#cfe8ff';
  div.innerHTML = `Tension <input id="tens" type="range" min="0.70" max="1.00" step="0.01" value="1.00"> <span id="tv">loose</span>`;
  document.body.appendChild(div);
  const inp = div.querySelector('#tens'); const tv = div.querySelector('#tv');
  inp.oninput = ()=>{ rope.tighten(parseFloat(inp.value)); tv.textContent = (1-parseFloat(inp.value) < 0.05 ? 'loose' : (1-parseFloat(inp.value) > 0.25 ? 'tight' : 'ok')); };
  // rudimentary updater
  const id = setInterval(()=>{ rope.step(); line.userData.update && line.userData.update(); }, 33);
  div.dataset._interval = id;
  div.dataset._type = 'tensionWidget';
  return { isWidget:true, remove(){ clearInterval(id); div.remove(); } };
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Finish, remove, refresh score â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
function removeLastBite(){
  const b = bites.pop(); if(!b) return;
  scene.remove(b.line); b.tensionObj?.remove();
  refreshScore(); ui.fb.textContent='Removed last bite.';
}
function clearAll(){
  for(const b of bites){ scene.remove(b.line); b.tensionObj?.remove(); }
  bites.length=0; step=0; entryP=null; exitP=null;
  ui.biteN.textContent='0'; ui.depthErr.textContent='â€”'; ui.angleErr.textContent='â€”';
  ui.spacing.textContent='â€”'; ui.sym.textContent='â€”'; ui.gap.textContent='â€”'; ui.overall.textContent='â€”';
  ui.stepText.textContent='Click left edge (entry)'; ui.fb.textContent='â€”';
  needleGroup.clear();
}
function finalize(){
  if(bites.length===0){ ui.fb.textContent='Place at least one bite before finishing.'; return; }
  const s = computeScores();
  ui.fb.innerHTML = `<span class="${s.overall>=4?'ok':s.overall>=3?'warn':'bad'}">Finished. Overall ${s.overall.toFixed(1)}/5</span>`;
}
function refreshScore(){
  const s = computeScores();
  ui.biteN.textContent = bites.length+'';
  ui.depthErr.textContent = isFinite(s.depthErr)? s.depthErr.toFixed(1)+' mm':'â€”';
  ui.angleErr.textContent = isFinite(s.angleErr)? s.angleErr.toFixed(1)+'Â°':'â€”';
  ui.spacing.textContent  = isFinite(s.spacingCV)? (s.spacingCV*100).toFixed(0)+'%':'â€”';
  ui.sym.textContent      = isFinite(s.symErr)? s.symErr.toFixed(1)+' mm':'â€”';
  ui.gap.textContent      = isFinite(s.resGap)? s.resGap.toFixed(1)+' mm':'â€”';
  ui.overall.textContent  = isFinite(s.overall)? s.overall.toFixed(1)+'/5':'â€”';
}

function computeScores(){
  if(bites.length===0) return {overall:NaN};
  const targetDepth=5, depthTol=2; // 4â€“6 mm
  let depthErrs=[], angErrs=[], spacings=[], symErrs=[], resGaps=[], tensScores=[];
  for(let i=0;i<bites.length;i++){
    const b=bites[i];
    const dErr = (Math.abs(b.depthL-targetDepth)+Math.abs(b.depthR-targetDepth))/2;
    depthErrs.push(dErr);
    angErrs.push(b.angleErr);
    if(i>0) spacings.push( b.entry.distanceTo(bites[i-1].entry) );
    symErrs.push(b.symmetry);
    resGaps.push(b.residual);
    tensScores.push( b.tension ); // just to track usage
  }
  const mean = arr=>arr.reduce((a,b)=>a+b,0)/arr.length;
  const stdev = arr=>{ const m=mean(arr); return Math.sqrt(mean(arr.map(x=>(x-m)*(x-m)))); };
  const cv = arr=> (mean(arr)>0? stdev(arr)/mean(arr) : NaN);

  const dE  = mean(depthErrs);
  const aE  = mean(angErrs);
  const spCV= spacings.length? cv(spacings) : NaN;
  const sE  = mean(symErrs);
  const rG  = mean(resGaps);

  // Map errors to 1â€“5 scores (5 best). Tuned linearly with soft caps.
  const sDepth = clamp(5 - dE*0.8, 1, 5);
  const sAngle = clamp(5 - Math.max(0,aE-5)*0.12, 1, 5); // allow small error band
  const sSpace = isFinite(spCV)? clamp(5 - spCV*8, 1, 5) : 3;
  const sSym   = clamp(5 - sE*0.6, 1, 5);
  const sGap   = clamp(5 - rG*0.6, 1, 5);

  const overall = (sDepth*0.28 + sAngle*0.18 + sSpace*0.18 + sSym*0.18 + sGap*0.18);
  return {depthErr:dE, angleErr:aE, spacingCV:spCV, symErr:sE, resGap:rG, overall};
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Export session JSON â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
function exportJSON(){
  const payload = {
    when: new Date().toISOString(),
    mode: ui.mode.value,
    case: ui.caseSel.value,
    bites: bites.map(b=>({
      entry: {x:b.entry.x,y:b.entry.y,z:b.entry.z},
      exit:  {x:b.exit.x, y:b.exit.y, z:b.exit.z},
      depthL: b.depthL, depthR:b.depthR, angleErr:b.angleErr,
      symmetry:b.symmetry, tension:b.tension, residualGap:b.residual
    })),
    summary: computeScores()
  };
  const blob = new Blob([JSON.stringify(payload,null,2)], {type:'application/json'});
  const url = URL.createObjectURL(blob); const a=document.createElement('a');
  a.href=url; a.download='mitral_suture_session.json'; a.click(); URL.revokeObjectURL(url);
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Render loop & resize â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
function tick(){
  requestAnimationFrame(tick);
  controls.update();
  renderer.render(scene,camera);
}
tick();
window.addEventListener('resize', ()=>{
  renderer.setSize(stage.clientWidth, stage.clientHeight);
  camera.aspect = stage.clientWidth/stage.clientHeight; camera.updateProjectionMatrix();
});

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Boot â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
ui.fb.textContent='Load a case, then place bites (leftâ†’right). Tighten tension, finish & score.';
setStatus('Ready', 'ok');
</script>
</body>
</html>
