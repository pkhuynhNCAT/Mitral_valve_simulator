<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Mitral Valve 2D — Minimal, Runs Anywhere</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<style>
  :root{ --bg:#0b0f14; --ink:#eaf2f8; --mut:#9fb3c4; --ok:#2ed573; --warn:#ffb020; --bad:#ff4d4f; --panel:#0f151d; }
  html,body{margin:0;height:100%;background:var(--bg);color:var(--ink);font:14px/1.4 ui-sans-serif,system-ui,Segoe UI,Roboto,Helvetica,Arial}
  #wrap{display:grid;grid-template-rows:48px 1fr 36px;height:100%}
  header{display:flex;align-items:center;gap:12px;padding:8px 12px;background:linear-gradient(180deg,#0e1520,#0b1218);border-bottom:1px solid #182330}
  header h1{font-size:15px;margin:0;font-weight:600}
  #ui{display:flex;flex-wrap:wrap;gap:10px;align-items:center;margin-left:auto}
  #ui label{color:var(--mut);font-size:12px}
  #ui input[type=range]{width:150px}
  #ui select,#ui button{background:#101825;color:#e6f0f6;border:1px solid #223243;border-radius:8px;padding:6px 8px}
  main{position:relative}
  canvas{display:block;width:100%;height:100%}
  #hud{position:absolute;top:8px;left:8px;display:grid;gap:6px}
  .card{background:rgba(9,14,19,.8);border:1px solid #1f2b36;border-radius:8px;padding:6px 8px;backdrop-filter:blur(5px);min-width:200px}
  .k{color:#a8bfd1;font-size:11px}
  .v{font-family:ui-monospace,Menlo,Consolas,monospace;font-weight:700}
  footer{display:flex;align-items:center;padding:6px 10px;color:#8dadc1;border-top:1px solid #182330}
  #status{margin-left:8px}
</style>
</head>
<body>
<div id="wrap">
  <header>
    <h1>Mitral Valve 2D — Minimal Simulation</h1>
    <div id="ui">
      <label>HR <input id="hr" type="range" min="40" max="140" value="70"></label>
      <span id="hrV">70 bpm</span>
      <label>ΔP_peak <input id="dP" type="range" min="40" max="140" step="5" value="100"></label>
      <span id="dPV">100 mmHg</span>
      <select id="case">
        <option value="normal">Normal</option>
        <option value="p2_flail">Degenerative — P2 flail</option>
        <option value="functional">Functional — tethering</option>
      </select>
      <button id="reset">Load case</button>
      <button id="pause">Pause</button>
    </div>
  </header>

  <main>
    <canvas id="cv"></canvas>
    <div id="hud">
      <div class="card">
        <div class="k">EROA (per-beat)</div>
        <div class="v" id="eroa">0.00 cm²</div>
      </div>
      <div class="card">
        <div class="k">Regurg Volume / Fraction</div>
        <div class="v" id="rv">0.0 ml • 0%</div>
      </div>
      <div class="card">
        <div class="k">Status</div>
        <div class="v" id="simstatus">Running</div>
      </div>
    </div>
  </main>

  <footer>
    <div>Pure Canvas 2D (no WebGL/CDNs). Educational demo — not a medical device.</div>
    <div id="status"></div>
  </footer>
</div>

<script>
/* ============================== Minimal Valve 2D ============================== */
/* Pure Canvas 2D beating valve with two deformable leaflets + chordae.        */
/* No external libs. Designed to run on GitHub Pages and any modern browser.   */

/* ---- Canvas setup ---- */
const canvas = document.getElementById('cv');
const ctx = canvas.getContext('2d');
function resize(){ canvas.width = canvas.clientWidth; canvas.height = canvas.clientHeight; }
window.addEventListener('resize', resize); resize();

/* ---- UI elements ---- */
const el = (id)=>document.getElementById(id);
const hrSl = el('hr'), dPSl = el('dP'), caseSel = el('case');
const hrV = el('hrV'), dPV = el('dPV'), eroaV = el('eroa'), rvV = el('rv');
const statusV = el('simstatus'), statusBar = el('status');
const btnReset = el('reset'), btnPause = el('pause');

/* ---- Model constants (units: pixels ~ mm; 10 px ≈ 10 mm) ---- */
const K = 60;                          // segments along annulus/leaflets
const CENTER = ()=>({ x: canvas.width*0.5, y: canvas.height*0.55 });
const R_ML = ()=>Math.min(canvas.width, canvas.height)*0.22;   // mediolateral radius
const R_AP = ()=>Math.min(canvas.width, canvas.height)*0.17;   // anteroposterior radius
const LEAF_LEN_ANT = 65;               // mm-ish (pixels)
const LEAF_LEN_POST = 55;
const DAMP = 0.04;                     // global damping
const RAD_STIFF = 0.20;                // radial (hinge->free) stiffness
const EDGE_STIFF = 0.12;               // neighbor smoothness
const CHORDA_STIFF = 0.15;             // chordae stiffness
const COAPT_GAP = 1.0;                 // minimal separation (mm-ish)
const PRESSURE_GAIN = 0.02;            // px per mmHg per frame (tuned)

/* ---- State ---- */
let running = true;
let HR = +hrSl.value;
let DP = +dPSl.value;
let CASE = caseSel.value;
let t0 = performance.now();
let lastBeat = t0;
let beatLog = [];      // {eroa_cm2, rv_ml, rf}

/* ---- Geometry buffers ---- */
let hinge = new Array(K);
let normal = new Array(K);
let ant = { free: new Array(K), prev: new Array(K), len: LEAF_LEN_ANT, side:-1, chordIdx:[] };
let post= { free: new Array(K), prev: new Array(K), len: LEAF_LEN_POST, side:+1, chordIdx:[] };
let papAL, papPM;

/* ---- Utility ---- */
function lerp(a,b,t){ return a+(b-a)*t; }
function len2(a,b){ const dx=a.x-b.x, dy=a.y-b.y; return Math.hypot(dx,dy); }
function add(a,b){ return {x:a.x+b.x,y:a.y+b.y}; }
function sub(a,b){ return {x:a.x-b.x,y:a.y-b.y}; }
function mul(a,s){ return {x:a.x*s,y:a.y*s}; }
function set(p,q){ p.x=q.x; p.y=q.y; }
function clamp(x,a,b){ return Math.max(a,Math.min(b,x)); }

/* ---- Build annulus (ellipse) + normals ---- */
function buildAnnulus(){
  const c = CENTER(), rx = R_ML(), ry = R_AP();
  for(let i=0;i<K;i++){
    const t = i/(K-1);               // arc across LV–LA line (nearly 180°)
    const ang = lerp(-Math.PI*0.9, Math.PI*0.9, t);
    const p = { x: c.x + rx*Math.cos(ang), y: c.y + ry*Math.sin(ang) };
    hinge[i] = p;
    const nvec = { x: (p.x - c.x), y: (p.y - c.y) };
    const L = Math.hypot(nvec.x, nvec.y) || 1;
    normal[i] = { x: nvec.x/L, y: nvec.y/L };  // outward normal
  }
  papAL = { x: c.x + rx*0.45, y: c.y + ry*1.4 };   // anterolateral
  papPM = { x: c.x - rx*0.48, y: c.y + ry*1.5 };   // posteromedial
}

/* ---- Initialize leaflets ---- */
function initLeaf(side){
  const st = (side<0) ? ant : post;
  for(let i=0;i<K;i++){
    const base = add(hinge[i], mul(normal[i], side * st.len));
    st.free[i] = {x: base.x, y: base.y};
    st.prev[i] = {x: base.x, y: base.y};
  }
  // chordae: every 3rd node goes to AL (left half) or PM (right half)
  st.chordIdx = [];
  for(let i=0;i<K;i+=3){
    st.chordIdx.push(i);
  }
}

/* ---- Apply pathology presets ---- */
function applyCase(){
  // Reset geometry
  buildAnnulus();
  initLeaf(-1); // anterior
  initLeaf(+1); // posterior

  if(CASE === 'p2_flail'){
    // "Cut" a band of posterior chordae around center
    const mid = Math.floor(K/2), span = Math.floor(K*0.12);
    for(let i=mid-span;i<=mid+span;i++){
      // Move that free point farther out (flail) and weaken neighbor coupling
      post.free[i].y += 15;
      post.prev[i].y += 15;
      // Remove its chordae by not treating it as chordIdx
    }
    // Filter chordae indices to exclude the flail region
    post.chordIdx = post.chordIdx.filter(i => i < mid-span || i > mid+span);
  } else if(CASE === 'functional'){
    // Shift papillary points apically and dilate the annulus slightly
    const c = CENTER(); const scale = 1.10;
    for(let i=0;i<K;i++){
      hinge[i] = add(c, mul(sub(hinge[i], c), scale));
      normal[i] = mul(normal[i], 1); // recalc not needed since direction preserved
    }
    papAL.y += 18; papPM.y += 22; papAL.x += 6; papPM.x -= 6;
    // Tethering effect: increase posterior leaflet rest length a little
    post.len += 6;
  }
}

/* ---- Heart cycle (ΔP over time) ---- */
function beatPeriodMs(){ return 60000/HR; }
function dP_mmHg(timeMs){
  const T = beatPeriodMs(); const t = (timeMs % T)/T;
  const syst = 0.38;
  if(t < syst){ const x = t/syst; return DP * Math.sin(Math.PI*x); } // half-sine up/down
  const d = (t - syst) / (1 - syst);
  return -8 * (1 - Math.cos(Math.PI*d)) * 0.5; // small negative diastolic suction
}

/* ---- Physics step (Verlet + positional corrections) ---- */
function step(dt){
  const now = performance.now();
  const dP = dP_mmHg(now);
  const Ppush = PRESSURE_GAIN * dP;

  function integrateLeaf(st){
    for(let i=0;i<K;i++){
      const p = st.free[i], prev = st.prev[i];

      // Verlet integration with global damping
      const vx = (p.x - prev.x) * (1 - DAMP);
      const vy = (p.y - prev.y) * (1 - DAMP);
      prev.x = p.x; prev.y = p.y;

      // Pressure drives leaflets inward during systole, outward during diastole
      // Direction: -side * normal (so both move towards hinge when dP > 0)
      const dir = mul(normal[i], -st.side * Ppush);

      p.x += vx + dir.x;
      p.y += vy + dir.y;

      // Radial spring towards (hinge + side*len*normal)
      const target = add(hinge[i], mul(normal[i], st.side * st.len));
      p.x += (target.x - p.x) * RAD_STIFF;
      p.y += (target.y - p.y) * RAD_STIFF;
    }

    // Edge smoothness (neighbor coupling)
    for(let i=1;i<K-1;i++){
      const p = st.free[i], a = st.free[i-1], b = st.free[i+1];
      p.x += ((a.x + b.x)/2 - p.x) * EDGE_STIFF;
      p.y += ((a.y + b.y)/2 - p.y) * EDGE_STIFF;
    }

    // Chordae to papillary muscles
    for(const idx of st.chordIdx){
      const p = st.free[idx];
      const anchor = (idx < K/2) ? papAL : papPM;
      const d = sub(anchor, p);
      const L = Math.hypot(d.x, d.y) || 1;
      // Desired chord length is current; just pull slightly toward anchor (tension)
      const pull = CHORDA_STIFF;
      p.x += (d.x / L) * pull * 6;   // 6 px nominal
      p.y += (d.y / L) * pull * 6;
    }
  }

  // Integrate both leaflets
  integrateLeaf(ant); integrateLeaf(post);

  // Coaptation contact: keep a minimal gap (prevents interpenetration)
  for(let i=0;i<K;i++){
    const A = ant.free[i], P = post.free[i];
    const d = sub(P, A);
    const L = Math.hypot(d.x, d.y) || 1;
    const gap = L - COAPT_GAP;
    if(gap < 0){
      // Move both half the correction along the line
      const corr = (COAPT_GAP - L) * 0.5;
      const ux = d.x / L, uy = d.y / L;
      A.x -= ux * corr; A.y -= uy * corr;
      P.x += ux * corr; P.y += uy * corr;
    }
  }

  // Per-beat metrics (EROA & regurg stats)
  accumulateBeatMetrics(dP, dt);
}

/* ---- Metrics ---- */
let eroaAcc_mm2 = 0, eroaN = 0, rv_ml_acc = 0;
function accumulateBeatMetrics(dP, dt){
  // EROA estimate: sum positive gaps between free edges along arc
  let area_mm2 = 0;
  for(let i=0;i<K;i++){
    const A = ant.free[i], P = post.free[i];
    const L = len2(A, P);
    const gap = Math.max(0, L - 1.0); // 1 mm tolerance for "coapted" line
    // Arc spacing in mm-ish (approx)
    const s = (R_ML()*Math.PI*1.8) / (K-1) / (Math.min(canvas.width, canvas.height)/300*10); // rough normalization
    area_mm2 += gap * s;
  }
  const eroa_cm2_inst = area_mm2 / 100.0;

  // Jet velocity from echo rule: ΔP ≈ 4 v^2 → v ≈ sqrt(ΔP/4) m/s
  const v_ms = dP>0 ? Math.sqrt(Math.max(0, dP)/4) : 0;
  const flow_ml_s = eroa_cm2_inst * (v_ms * 100); // (cm² * cm/s) = ml/s

  // Accumulate during systole (dP>0)
  if(dP > 2){
    eroaAcc_mm2 += area_mm2;
    eroaN += 1;
    rv_ml_acc += flow_ml_s * dt;
  }

  // Beat boundary
  const now = performance.now();
  if(now - lastBeat >= beatPeriodMs()){
    const eroa_cm2 = (eroaN>0) ? (eroaAcc_mm2/eroaN)/100.0 : 0;
    const rv_ml = rv_ml_acc;
    // Stroke volume ~ 4.5 L/min scaled by ΔP, crude; RF = RV/SV
    const CO_ml_min = 4500 * clamp(DP/100, 0.7, 1.3);
    const SV_ml = CO_ml_min / HR;
    const rf = clamp(SV_ml ? (rv_ml/SV_ml*100) : 0, 0, 95);

    beatLog.push({ eroa_cm2, rv_ml, rf });
    if(beatLog.length > 8) beatLog.shift();

    eroaV.textContent = eroa_cm2.toFixed(2) + ' cm²';
    rvV.textContent   = rv_ml.toFixed(1) + ' ml • ' + Math.round(rf) + '%';

    eroaAcc_mm2 = 0; eroaN = 0; rv_ml_acc = 0; lastBeat += beatPeriodMs();
  }
}

/* ---- Render ---- */
function draw(){
  const w=canvas.width, h=canvas.height;
  ctx.clearRect(0,0,w,h);

  // Backdrop grid
  ctx.save();
  ctx.strokeStyle = '#14202a';
  ctx.lineWidth = 1;
  for(let x=0;x<w;x+=40){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,h); ctx.stroke(); }
  for(let y=0;y<h;y+=40){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(w,y); ctx.stroke(); }
  ctx.restore();

  // Annulus
  ctx.save();
  ctx.strokeStyle = '#95a9c4';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(hinge[0].x, hinge[0].y);
  for(let i=1;i<K;i++) ctx.lineTo(hinge[i].x, hinge[i].y);
  ctx.stroke();
  ctx.restore();

  // Leaflet fills (posterior then anterior)
  function fillLeaf(leaf, color){
    ctx.save();
    ctx.fillStyle = color;
    ctx.beginPath();
    ctx.moveTo(hinge[0].x, hinge[0].y);
    for(let i=1;i<K;i++) ctx.lineTo(hinge[i].x, hinge[i].y);
    for(let i=K-1;i>=0;i--) ctx.lineTo(leaf.free[i].x, leaf.free[i].y);
    ctx.closePath();
    ctx.fill();
    ctx.restore();
  }
  fillLeaf(post, 'rgba(240,248,255,0.95)');
  fillLeaf(ant , 'rgba(230,235,255,0.92)');

  // Chordae
  ctx.save();
  ctx.strokeStyle = '#6fa2ff';
  ctx.lineWidth = 1;
  for(const idx of post.chordIdx){
    const a = post.free[idx], b = (idx<K/2)? papAL : papPM;
    ctx.beginPath(); ctx.moveTo(a.x,a.y); ctx.lineTo(b.x,b.y); ctx.stroke();
  }
  for(const idx of ant.chordIdx){
    const a = ant.free[idx], b = (idx<K/2)? papAL : papPM;
    ctx.beginPath(); ctx.moveTo(a.x,a.y); ctx.lineTo(b.x,b.y); ctx.stroke();
  }
  // Papillary markers
  ctx.fillStyle = '#3e566e';
  ctx.beginPath(); ctx.arc(papAL.x,papAL.y,4,0,Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.arc(papPM.x,papPM.y,4,0,Math.PI*2); ctx.fill();
  ctx.restore();
}

/* ---- Main loop ---- */
let last = performance.now();
function loop(){
  if(!running){ requestAnimationFrame(loop); return; }
  const now = performance.now();
  const dt = Math.min(1/60, (now-last)/1000);
  step(dt);
  draw();
  last = now;
  requestAnimationFrame(loop);
}

/* ---- UI wiring ---- */
hrSl.oninput = ()=>{ HR = +hrSl.value; hrV.textContent = HR + ' bpm'; };
dPSl.oninput = ()=>{ DP = +dPSl.value; dPV.textContent = DP + ' mmHg'; };
btnReset.onclick = ()=>{ CASE = caseSel.value; applyCase(); statusBar.textContent = 'Loaded: '+CASE; };
btnPause.onclick = ()=>{
  running = !running;
  statusV.textContent = running ? 'Running' : 'Paused';
  btnPause.textContent = running ? 'Pause' : 'Resume';
  if(running) last = performance.now();
};

function boot(){
  buildAnnulus();
  initLeaf(-1); initLeaf(+1);
  applyCase(); // default selection
  running = true; statusV.textContent = 'Running';
  loop();
}
boot();
</script>
</body>
</html>
