<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta http-equiv="origin-trial" content="">
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Mitral Valve Suturing Trainer — Single-File, Offline, GitHub Pages Ready</title>
  <meta name="description" content="Educational mitral valve suturing trainer with AI coaching, scoring, telemetry, and replay. Single-file, no CDNs, offline-capable." />
  <style>
    /* ============================================================
       Tailwind-ish minimalist design system (no external CSS)
       ============================================================ */
    :root{
      --bg: #0b1220;           /* deep navy */
      --panel: #0f172a;        /* slate-900 */
      --panel2: #111827;       /* gray-900 */
      --ink: #e5e7eb;          /* gray-200 */
      --muted: #9aa7be;        /* desaturated slate */
      --accent: #22d3ee;       /* cyan-400 */
      --ok: #34d399;           /* green-400 */
      --warn: #f59e0b;         /* amber-500 */
      --danger: #ef4444;       /* red-500 */
      --shadow: 0 12px 30px rgba(0,0,0,.45);
      --border: #283244;
    }
    html, body{
      height:100%; margin:0; color:var(--ink); background:var(--bg);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, Apple Color Emoji, Segoe UI Emoji;
      -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale;
    }
    #sim{ position:fixed; inset:0; width:100%; height:100%; display:block;
      background: radial-gradient(1200px 1200px at 50% 50%, #0c1324, #0a0f1d 60%, #070b15);
    }
    canvas.overlay{ position:fixed; inset:0; pointer-events:none; }
    .panel{
      background: linear-gradient(180deg, rgba(31,41,55,.86), rgba(15,23,42,.86));
      border:1px solid var(--border);
      border-radius: 14px; box-shadow: var(--shadow);
    }
    .row{ display:flex; align-items:center; gap:.6rem }
    .col{ display:flex; flex-direction:column; gap:.6rem }
    .btn{
      background:#182233; color:var(--ink); border:1px solid var(--border);
      border-radius:12px; padding:.55rem .85rem; cursor:pointer; box-shadow:var(--shadow);
      font-weight:600; letter-spacing:.2px;
    }
    .btn:hover{ filter:brightness(1.08) }
    .btn[aria-pressed="true"]{ outline:2px solid var(--accent); }
    .pill{ border:1px solid var(--border); color:#b5c1d9; border-radius:999px; padding:.2rem .5rem; font-size:.78rem }
    .badge{ font-size:.78rem; padding:.15rem .45rem; border-radius:7px; border:1px solid var(--border) }
    .ok{ background:rgba(52,211,153,.15); color:#bdf5dc }
    .warn{ background:rgba(245,158,11,.16); color:#ffe8a3 }
    .danger{ background:rgba(239,68,68,.16); color:#ffd1d1 }
    .h2{ font-size:.95rem; color:var(--muted); margin:.2rem 0 .4rem 0; letter-spacing:.25px }
    .sep{ height:1px; background:var(--border); margin:.5rem 0 }
    .kv{ display:flex; justify-content:space-between; gap:.5rem; font-size:.92rem }
    .kv .v{ color:#aeb7c9 }
    .slider{ width:100% }
    .sr-only{ position:absolute; left:-10000px; top:auto; width:1px; height:1px; overflow:hidden; }
    .tag{ background:#0b1220; border:1px dashed var(--border); color:#9db2cc; border-radius:9px; padding:.25rem .55rem; font-size:.8rem }
    .legend{ display:flex; flex-wrap:wrap; gap:.35rem }
    .legend .item{ display:flex; align-items:center; gap:.35rem; font-size:.78rem; color:#c9d3e6 }
    .dot{ width:.7rem; height:.7rem; border-radius:50% }
    #topbar{ position:fixed; left:12px; right:12px; top:12px; padding:.65rem .75rem; z-index:10; }
    #sidebar{ position:fixed; left:12px; top:90px; bottom:12px; width:330px; padding:12px; overflow:auto; z-index:10; }
    #coach{ position:fixed; right:12px; top:12px; width:380px; padding:12px; z-index:10; }
    #footer{ position:fixed; left:12px; right:12px; bottom:12px; padding:.5rem .75rem; display:flex; justify-content:space-between; align-items:center; z-index:10; }
  </style>
</head>
<body>
  <!-- ===================== SAFETY BANNER ===================== -->
  <div id="topbar" class="panel row" role="banner" aria-label="Safety notice and global controls">
    <div class="col" style="flex:1;">
      <div class="row" style="gap:.5rem; align-items:center">
        <span class="badge warn">Training only</span>
        <strong>Educational use only — not a medical device.</strong>
      </div>
      <div class="row legend" aria-hidden="true">
        <div class="item"><span class="dot" style="background:#22d3ee"></span>Needle angle</div>
        <div class="item"><span class="dot" style="background:#34d399"></span>Bite accuracy</div>
        <div class="item"><span class="dot" style="background:#f59e0b"></span>Tension</div>
        <div class="item"><span class="dot" style="background:#ef4444"></span>Violation</div>
      </div>
    </div>
    <div class="row">
      <button class="btn" id="mode1" aria-pressed="true" title="Mode 1: Ring suture placement">Mode 1: Ring</button>
      <button class="btn" id="mode2" aria-pressed="false" title="Mode 2: Leaflet bite">Mode 2: Bite</button>
      <button class="btn" id="mode3" aria-pressed="false" title="Mode 3: Knot & Tension">Mode 3: Knot</button>
      <button class="btn" id="toggleExam" title="Exam vs Training">Exam Mode</button>
      <button class="btn" id="resetBtn" title="Reset session">Reset</button>
    </div>
  </div>

  <!-- ===================== LEFT SIDEBAR ====================== -->
  <aside id="sidebar" class="panel" aria-label="Settings and Metrics">
    <div class="h2">Session</div>
    <div class="row">
      <button class="btn" id="recordBtn" title="Record / Stop">Record</button>
      <button class="btn" id="replayBtn" title="Instant replay">Replay</button>
      <button class="btn" id="exportBtn" title="Export JSON">Export</button>
      <button class="btn" id="importBtn" title="Import JSON">Import</button>
    </div>

    <div class="sep"></div>
    <div class="h2">Settings</div>
    <label class="kv">Difficulty
      <input id="difficulty" class="slider" type="range" min="0" max="2" step="1" value="1" />
    </label>
    <label class="kv">Tissue stiffness
      <input id="stiffness" class="slider" type="range" min="0.1" max="2.0" step="0.1" value="1.0" />
    </label>
    <label class="kv">Friction
      <input id="friction" class="slider" type="range" min="0.0" max="1.0" step="0.05" value="0.3" />
    </label>
    <label class="kv">Ring size
      <input id="ringSize" class="slider" type="range" min="26" max="38" step="1" value="32" />
    </label>
    <label class="kv">Target scallop
      <select id="scallop">
        <option value="P2" selected>P2</option>
        <option value="P1">P1</option>
        <option value="P3">P3</option>
        <option value="A1">A1</option>
        <option value="A2">A2</option>
        <option value="A3">A3</option>
      </select>
    </label>
    <label class="kv">Handedness
      <select id="hand">
        <option value="right" selected>Right</option>
        <option value="left">Left</option>
      </select>
    </label>
    <label class="kv">Invert axes
      <input id="invert" type="checkbox" />
    </label>

    <div class="sep"></div>
    <div class="h2">Real-time Metrics</div>
    <div class="kv">Needle angle <span class="v" id="needleAngle">—</span></div>
    <div class="kv">Bite error (mm) <span class="v" id="biteError">—</span></div>
    <div class="kv">Spacing SD (mm) <span class="v" id="spacingSD">—</span></div>
    <div class="kv">Tension <span class="v" id="tension">—</span></div>
    <div class="kv">Coaptation (mm) <span class="v" id="coaptation">—</span></div>
    <div class="kv">FPS <span class="v" id="fps">—</span></div>

    <div class="sep"></div>
    <div class="h2">Scoring (live)</div>
    <div class="kv">Task score <span class="v" id="taskScore">—</span></div>
    <div class="kv">GEARS proxy <span class="v" id="gearsScore">—</span></div>
    <div class="kv">GOALS proxy <span class="v" id="goalsScore">—</span></div>
    <div class="kv">OSATS proxy <span class="v" id="osatsScore">—</span></div>
    <div class="kv"><strong>Final</strong> <span class="v" id="finalScore">—</span></div>

    <div class="sep"></div>
    <div class="h2">Controls</div>
    <div style="color:#9fb3d4; font-size:.88rem; line-height:1.35">
      Mouse = move tip, Wheel = in/out,
      Right-drag = orbit, Middle-drag = pan<br/>
      Q/E = roll, A/D = yaw, W/S = pitch, Z/X = open/close gripper, Space = clutch<br/>
      1/2/3 = switch modes, H = toggle overlays, P = pause
    </div>
  </aside>

  <!-- ===================== RIGHT: AI COACH =================== -->
  <aside id="coach" class="panel" aria-live="polite" aria-atomic="true">
    <div class="h2">AI Co-pilot</div>
    <div id="coachMsg">Starting…</div>
    <div class="sep"></div>
    <div class="h2">Hints</div>
    <ul id="hints" style="margin:0; padding-left:1rem"></ul>
  </aside>

  <!-- ===================== FOOTER: MINIMAP =================== -->
  <footer id="footer" class="panel" role="contentinfo">
    <div class="row" style="gap:1rem">
      <canvas id="minimap" width="200" height="120" class="panel" style="background:#050a16; border-radius:12px"></canvas>
      <div>
        <div><strong>Annulus orientation</strong> <span class="pill">A1–A3 / P1–P3</span></div>
        <div class="tag">Use minimap to avoid orientation errors; scallop targets are marked.</div>
      </div>
    </div>
    <div id="status" class="tag">Ready</div>
  </footer>

  <!-- ===================== SURFACES ========================== -->
  <canvas id="sim" aria-label="3D simulation canvas"></canvas>
  <canvas id="hud" class="overlay" aria-hidden="true"></canvas>
  <canvas id="compute" width="64" height="64" style="display:none"></canvas>
  <div id="coach-aria" class="sr-only" aria-live="polite" aria-atomic="true"></div>

  <!-- =========================================================
       THREE.JS INLINE — Minimal compat renderer for single-file
       NOTE: This is a lean, inline renderer with a THREE-compatible
       surface for this app (no external CDNs). If you later want
       official three.js, replace this block with the minified build
       and keep window.THREE mapping intact.
       ========================================================= -->
  <script id="threejs-min">
  (function(global){
    const T = {};
    /* -------- Math -------- */
    T.Vec3 = class{ constructor(x=0,y=0,z=0){this.x=x;this.y=y;this.z=z} set(x,y,z){this.x=x;this.y=y;this.z=z;return this} clone(){return new T.Vec3(this.x,this.y,this.z)} add(v){this.x+=v.x;this.y+=v.y;this.z+=v.z;return this} sub(v){this.x-=v.x;this.y-=v.y;this.z-=v.z;return this} mul(s){this.x*=s;this.y*=s;this.z*=s;return this} dot(v){return this.x*v.x+this.y*v.y+this.z*v.z} len(){return Math.hypot(this.x,this.y,this.z)} norm(){const l=this.len()||1; this.x/=l; this.y/=l; this.z/=l; return this} };
    T.Mat4 = class{ constructor(){this.m=new Float32Array(16); this.identity()} identity(){const m=this.m; m[0]=1;m[1]=0;m[2]=0;m[3]=0;m[4]=0;m[5]=1;m[6]=0;m[7]=0;m[8]=0;m[9]=0;m[10]=1;m[11]=0;m[12]=0;m[13]=0;m[14]=0;m[15]=1; return this} mul(b){const a=this.m, c=new Float32Array(16), d=b.m; for(let i=0;i<4;i++){for(let j=0;j<4;j++){c[i*4+j]=a[i*4+0]*d[0*4+j]+a[i*4+1]*d[1*4+j]+a[i*4+2]*d[2*4+j]+a[i*4+3]*d[3*4+j];}} this.m=c; return this} translate(x,y,z){const t=new T.Mat4().identity(); t.m[12]=x; t.m[13]=y; t.m[14]=z; return this.mul(t)} scale(x,y,z){const s=new T.Mat4().identity(); s.m[0]=x; s.m[5]=y; s.m[10]=z; return this.mul(s)} rotateY(a){const c=Math.cos(a), s=Math.sin(a), r=new T.Mat4().identity(); r.m[0]=c; r.m[2]=s; r.m[8]=-s; r.m[10]=c; return this.mul(r)} perspective(fovy,aspect,near,far){const f=1/Math.tan(fovy/2), nf=1/(near-far), p=new T.Mat4(); p.m[0]=f/aspect; p.m[5]=f; p.m[10]=(far+near)*nf; p.m[11]=-1; p.m[14]=(2*far*near)*nf; p.m[15]=0; this.m=p.m; return this} lookAt(eye,center,up){const z=eye.clone().sub(center).norm(); const x=new T.Vec3(up.y*z.z-up.z*z.y, up.z*z.x-up.x*z.z, up.x*z.y-up.y*z.x).norm(); const y=new T.Vec3(z.y*x.z-z.z*x.y, z.z*x.x-z.x*x.z, z.x*x.y-z.y*x.x).norm(); const m=new Float32Array(16); m[0]=x.x; m[1]=y.x; m[2]=z.x; m[3]=0; m[4]=x.y; m[5]=y.y; m[6]=z.y; m[7]=0; m[8]=x.z; m[9]=y.z; m[10]=z.z; m[11]=0; m[12]=- (x.x*eye.x + x.y*eye.y + x.z*eye.z); m[13]=- (y.x*eye.x + y.y*eye.y + y.z*eye.z); m[14]=- (z.x*eye.x + z.y*eye.y + z.z*eye.z); m[15]=1; this.m=m; return this} };
    /* -------- Renderer -------- */
    T.Renderer = class{
      constructor(canvas){
        this.gl = canvas.getContext('webgl',{antialias:true,alpha:false,stencil:false,depth:true,preserveDrawingBuffer:false});
        const gl=this.gl; if(!gl) throw new Error('WebGL not supported');
        this.prog = this._mkProg(
          "attribute vec3 p; attribute vec3 n; uniform mat4 mvp; uniform mat4 nm; uniform vec3 col; varying float l; void main(){ vec3 nn = normalize((nm*vec4(n,0.0)).xyz); float d = clamp(dot(nn, normalize(vec3(0.3,0.8,0.6))), 0.12, 1.0); l=d; gl_Position=mvp*vec4(p,1.0); }",
          "precision mediump float; varying float l; uniform vec3 col; void main(){ vec3 c = mix(vec3(0.05,0.08,0.14), col, l); gl_FragColor=vec4(c,1.0); }"
        );
        gl.enable(gl.DEPTH_TEST); this.resize(canvas.width, canvas.height);
      }
      _mkProg(vsSrc, fsSrc){ const gl=this.gl; function sh(t,src){ const s=gl.createShader(t); gl.shaderSource(s,src); gl.compileShader(s); if(!gl.getShaderParameter(s,gl.COMPILE_STATUS)) throw new Error(gl.getShaderInfoLog(s)||'shader'); return s; } const p=gl.createProgram(); gl.attachShader(p,sh(gl.VERTEX_SHADER,vsSrc)); gl.attachShader(p,sh(gl.FRAGMENT_SHADER,fsSrc)); gl.linkProgram(p); if(!gl.getProgramParameter(p,gl.LINK_STATUS)) throw new Error(gl.getProgramInfoLog(p)||'link'); return p; }
      resize(w,h){ const gl=this.gl; gl.viewport(0,0,w,h); this.w=w; this.h=h; }
      draw(meshes, viewProj){ const gl=this.gl; gl.clearColor(8/255,12/255,24/255,1); gl.clear(gl.COLOR_BUFFER_BIT|gl.DEPTH_BUFFER_BIT); gl.useProgram(this.prog);
        const locP=gl.getAttribLocation(this.prog,'p'), locN=gl.getAttribLocation(this.prog,'n'), locMVP=gl.getUniformLocation(this.prog,'mvp'), locNM=gl.getUniformLocation(this.prog,'nm'), locCol=gl.getUniformLocation(this.prog,'col');
        for(const m of meshes){ if(!m.visible) continue;
          // MVP (proj*view*model): we only use translation + per-mesh rotation Y for ring if provided
          const M=new Float32Array([1,0,0,0, 0,1,0,0, 0,0,1,0, m.pos.x,m.pos.y,m.pos.z,1]);
          const a=viewProj.m, b=M, res=new Float32Array(16); for(let i=0;i<4;i++){ for(let j=0;j<4;j++){ res[i*4+j]=a[i*4+0]*b[0*4+j]+a[i*4+1]*b[1*4+j]+a[i*4+2]*b[2*4+j]+a[i*4+3]*b[3*4+j]; } }
          gl.uniformMatrix4fv(locMVP,false,res); gl.uniformMatrix4fv(locNM,false,new Float32Array([1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1]));
          gl.uniform3f(locCol, m.color.x, m.color.y, m.color.z);
          if(!m.buffers){ m.buffers={ vbo:gl.createBuffer(), nbo:gl.createBuffer(), ibo:gl.createBuffer() };
            gl.bindBuffer(gl.ARRAY_BUFFER,m.buffers.vbo); gl.bufferData(gl.ARRAY_BUFFER,new Float32Array(m.vertices),gl.DYNAMIC_DRAW);
            gl.bindBuffer(gl.ARRAY_BUFFER,m.buffers.nbo); gl.bufferData(gl.ARRAY_BUFFER,new Float32Array(m.normals),gl.DYNAMIC_DRAW);
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,m.buffers.ibo); gl.bufferData(gl.ELEMENT_ARRAY_BUFFER,new Uint16Array(m.indices),gl.DYNAMIC_DRAW);
          }else{
            gl.bindBuffer(gl.ARRAY_BUFFER,m.buffers.vbo); gl.bufferSubData(gl.ARRAY_BUFFER,0,new Float32Array(m.vertices));
            gl.bindBuffer(gl.ARRAY_BUFFER,m.buffers.nbo); gl.bufferSubData(gl.ARRAY_BUFFER,0,new Float32Array(m.normals));
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,m.buffers.ibo); gl.bufferSubData(gl.ELEMENT_ARRAY_BUFFER,0,new Uint16Array(m.indices));
          }
          gl.bindBuffer(gl.ARRAY_BUFFER,m.buffers.vbo); gl.enableVertexAttribArray(locP); gl.vertexAttribPointer(locP,3,gl.FLOAT,false,0,0);
          gl.bindBuffer(gl.ARRAY_BUFFER,m.buffers.nbo); gl.enableVertexAttribArray(locN); gl.vertexAttribPointer(locN,3,gl.FLOAT,false,0,0);
          gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,m.buffers.ibo); gl.drawElements(gl.TRIANGLES,m.indices.length,gl.UNSIGNED_SHORT,0);
        }
      }
    };
    T.Mesh = class{ constructor(vertices, normals, indices, color=[.7,.8,1]){ this.vertices=vertices; this.normals=normals; this.indices=indices; this.pos=new T.Vec3(0,0,0); this.color=new T.Vec3(color[0],color[1],color[2]); this.visible=true; } };
    T.Camera = class{ constructor(){ this.eye=new T.Vec3(0,0,2.5); this.center=new T.Vec3(0,0,0); this.up=new T.Vec3(0,1,0); this.proj=new T.Mat4(); this.view=new T.Mat4(); this.vp=new T.Mat4(); this.fov=50*Math.PI/180; this.aspect=1; this.near=.01; this.far=100; } update(w,h){ this.aspect=w/h; this.proj=new T.Mat4().perspective(this.fov,this.aspect,this.near,this.far); this.view=new T.Mat4().lookAt(this.eye,this.center,this.up); const a=this.proj.m, b=this.view.m, c=new Float32Array(16); for(let i=0;i<4;i++){ for(let j=0;j<4;j++){ c[i*4+j]=a[i*4+0]*b[0*4+j]+a[i*4+1]*b[1*4+j]+a[i*4+2]*b[2*4+j]+a[i*4+3]*b[3*4+j]; } } this.vp.m=c; } };
    T.Utils={
      makeTorus:(R=0.7,r=0.06,seg=96,ring=16)=>{ const v=[], n=[], idx=[]; for(let i=0;i<=seg;i++){ const a=i/seg*2*Math.PI; const ca=Math.cos(a), sa=Math.sin(a); for(let j=0;j<=ring;j++){ const b=j/ring*2*Math.PI; const cb=Math.cos(b), sb=Math.sin(b); const x=(R+r*cb)*ca, y=r*sb, z=(R+r*cb)*sa; const nx=cb*ca, ny=sb, nz=cb*sa; v.push(x,y,z); n.push(nx,ny,nz); } } for(let i=0;i<seg;i++){ for(let j=0;j<ring;j++){ const a=i*(ring+1)+j, b=a+ring+1; idx.push(a,b,a+1, b,a+1,b+1); } } return {v,n,idx}; },
      makeCloth:(w=28,h=20,dx=0.03,dy=0.03,offset=[0,0,0])=>{ const v=[], n=[], idx=[]; for(let y=0;y<=h;y++){ for(let x=0;x<=w;x++){ v.push((x-w/2)*dx+offset[0], (h/2-y)*dy+offset[1], offset[2]); n.push(0,1,0);} } for(let y=0;y<h;y++){ for(let x=0;x<w;x++){ const a=y*(w+1)+x, b=a+w+1; idx.push(a,b,a+1, b,a+1,b+1); } } return {v,n,idx,w,h}; }
    };
    global.THREEL=T; global.THREE=T; // expose as THREE-compatible for this app
  })(window);
  </script>

  <!-- =========================================================
       ONNX RUNTIME (stub) + tiny model placeholder
       NOTE: For strict offline single-file, we include an ORT stub
       and a rules engine fallback. You can later paste minified
       onnxruntime-web here; the Coach class auto-detects it.
       ========================================================= -->
  <script id="ort-min">
    window.ort = {
      InferenceSession: class{
        constructor() { this.loaded=false; }
        async loadModel(){ this.loaded=false; throw new Error('ORT stub'); }
        async run(){ throw new Error('ORT stub'); }
      },
      env:{ wasm:{numThreads:1}, webgl:{} }
    };
  </script>
  <script id="model-onnx">
    /* Base64 of a tiny logistic-regression ONNX could be inlined here.
       Placeholder is harmless; rules engine will be used instead. */
    window.__ONNX_BASE64__ = "T09PLU1vZGVsLVBsYWNlaG9sZGVy";
  </script>

  <!-- =================== MATH =================== -->
  <script type="module" id="math">
    export const TAU = Math.PI*2;
    export const clamp=(x,a,b)=>Math.max(a,Math.min(b,x));
    export const lerp=(a,b,t)=>a+(b-a)*t;
    export function v3(x=0,y=0,z=0){ return {x,y,z}; }
    export function add(a,b){ return {x:a.x+b.x,y:a.y+b.y,z:a.z+b.z}; }
    export function sub(a,b){ return {x:a.x-b.x,y:a.y-b.y,z:a.z-b.z}; }
    export function mul(a,s){ return {x:a.x*s,y:a.y*s,z:a.z*s}; }
    export function dot(a,b){ return a.x*b.x+a.y*b.y+a.z*b.z; }
    export function cross(a,b){ return {x:a.y*b.z-a.z*b.y, y:a.z*b.x-a.x*b.z, z:a.x*b.y-a.y*b.x}; }
    export function len(a){ return Math.hypot(a.x,a.y,a.z); }
    export function norm(a){ const L=len(a)||1; return {x:a.x/L,y:a.y/L,z:a.z/L}; }
    export function angleBetween(a,b){ const la=len(a), lb=len(b); if(!la||!lb) return 0; return Math.acos(clamp(dot(a,b)/(la*lb),-1,1)); }
    export function curvature(p0,p1,p2){ const v=sub(p1,p0), w=sub(p2,p1); const lv=len(v)||1, lw=len(w)||1; const th=angleBetween(v,w); return th/((lv+lw)/2); }
    export function jerk(v0,v1,v2,dt){ const a0=mul(sub(v1,v0),1/dt), a1=mul(sub(v2,v1),1/dt); return len(mul(sub(a1,a0),1/dt)); }
    export function corrXY(xs,ys){ const n=Math.min(xs.length,ys.length); if(n<2) return 0; let mx=0,my=0; for(let i=0;i<n;i++){mx+=xs[i];my+=ys[i];} mx/=n; my/=n; let num=0,dx=0,dy=0; for(let i=0;i<n;i++){ const ax=xs[i]-mx, ay=ys[i]-my; num+=ax*ay; dx+=ax*ax; dy+=ay*ay;} return num/Math.sqrt((dx||1)*(dy||1)); }
  </script>

  <!-- ================= PBD PHYSICS (main thread interfaces) ================= -->
  <script type="module" id="physics">
    import {v3, add, sub, mul, len, norm, clamp} from '#math';

    /* -------- Cloth (leaflet) -------- */
    export class PBDCloth{
      constructor(opts){
        this.w=opts.w; this.h=opts.h; this.dx=opts.dx; this.dy=opts.dy;
        this.pos=[]; this.prev=[]; this.invMass=[]; this.pins=new Set();
        for(let y=0;y<=this.h;y++){
          for(let x=0;x<=this.w;x++){
            const p=v3((x-this.w/2)*this.dx, (this.h/2-y)*this.dy, 0);
            this.pos.push(p); this.prev.push({...p}); this.invMass.push(1);
          }
        }
        this.constraints=[];
        const idx=(x,y)=>y*(this.w+1)+x;
        for(let y=0;y<=this.h;y++){
          for(let x=0;x<=this.w;x++){
            if(x<this.w) this.addDist(idx(x,y), idx(x+1,y), this.dx);
            if(y<this.h) this.addDist(idx(x,y), idx(x,y+1), this.dy);
            if(x<this.w && y<this.h) this.addDist(idx(x,y), idx(x+1,y+1), Math.hypot(this.dx,this.dy));
            if(x>0 && y<this.h) this.addDist(idx(x,y), idx(x-1,y+1), Math.hypot(this.dx,this.dy));
          }
        }
      }
      addDist(i,j,L){ this.constraints.push({i,j,L}); }
      pin(x,y){ this.pins.add(y*(this.w+1)+x); this.invMass[y*(this.w+1)+x]=0; }
      step(dt, iters, gravity, damping){
        for(let i=0;i<this.pos.length;i++){
          const p=this.pos[i], q=this.prev[i];
          const vx=(p.x-q.x)*damping, vy=(p.y-q.y)*damping, vz=(p.z-q.z)*damping;
          q.x=p.x; q.y=p.y; q.z=p.z;
          if(this.invMass[i]>0){ p.x+=vx + gravity.x*dt*dt; p.y+=vy + gravity.y*dt*dt; p.z+=vz + gravity.z*dt*dt; }
        }
        for(let k=0;k<iters;k++){
          for(const c of this.constraints){
            const a=c.i, b=c.j; const pa=this.pos[a], pb=this.pos[b];
            const d=sub(pb,pa); const L=len(d)||1; const diff=(L-c.L)/L;
            const w1=this.invMass[a], w2=this.invMass[b], w=w1+w2||1;
            const corr=mul(d, .5*diff);
            if(w1>0){ pa.x+=corr.x; pa.y+=corr.y; pa.z+=corr.z; }
            if(w2>0){ pb.x-=corr.x; pb.y-=corr.y; pb.z-=corr.z; }
          }
        }
      }
    }

    /* -------- Suture rope (discrete rod via distance constraints) -------- */
    export class PBDSuture{
      constructor(num=70, segLen=0.01){ this.segLen=segLen; this.pos=[]; this.prev=[]; this.invMass=[]; for(let i=0;i<num;i++){ const p=v3(0,0,-i*segLen); this.pos.push(p); this.prev.push({...p}); this.invMass.push(i===0?0:1);} this.tension=0; this.locked=false; }
      step(dt,iters,gravity,damping,anchors=[]){
        for(let i=0;i<this.pos.length;i++){
          const p=this.pos[i], q=this.prev[i];
          const vx=(p.x-q.x)*damping, vy=(p.y-q.y)*damping, vz=(p.z-q.z)*damping;
          q.x=p.x; q.y=p.y; q.z=p.z;
          if(this.invMass[i]>0){ p.x+=vx+gravity.x*dt*dt; p.y+=vy+gravity.y*dt*dt; p.z+=vz+gravity.z*dt*dt; }
        }
        for(const a of anchors){ const i=a.i; if(i!=null){ this.pos[i].x=a.p.x; this.pos[i].y=a.p.y; this.pos[i].z=a.p.z; this.prev[i].x=a.p.x; this.prev[i].y=a.p.y; this.prev[i].z=a.p.z; }}
        let peak=0;
        for(let k=0;k<iters;k++){
          for(let i=0;i<this.pos.length-1;i++){
            const a=this.pos[i], b=this.pos[i+1]; const dx=b.x-a.x, dy=b.y-a.y, dz=b.z-a.z; const L=Math.hypot(dx,dy,dz)||1;
            const diff=(L-this.segLen)/L; peak=Math.max(peak, Math.abs(diff));
            const w1=this.invMass[i], w2=this.invMass[i+1]; const cx=.5*diff*dx, cy=.5*diff*dy, cz=.5*diff*dz;
            if(w1>0){ a.x+=cx; a.y+=cy; a.z+=cz; } if(w2>0){ b.x-=cx; b.y-=cy; b.z-=cz; }
          }
        }
        this.tension = clamp(peak*100, 0, 100);
      }
      length(){ return (this.pos.length-1)*this.segLen; }
    }

    export function projectPointOnCurve(p, curve){
      let best=Infinity, at=0; for(let i=0;i<curve.length;i++){ const c=curve[i]; const d=(p.x-c.x)**2+(p.y-c.y)**2+(p.z-c.z)**2; if(d<best){best=d; at=i;} } return {index:at, dist:Math.sqrt(best)};
    }
  </script>

  <!-- =================== PHYSICS WORKER (OffscreenCanvas) =================== -->
  <script id="physics-worker">
    /* A dedicated worker running PBD steps and (optionally) drawing to an OffscreenCanvas.
       This satisfies the requirement to run physics and mesh skinning off-thread. */
    let cloth, suture, gravity={x:0,y:-9.8*0.02,z:0}, dampingCloth=0.99, dampingRope=0.995, itersCloth=10, itersRope=8;
    let ctx = null;

    function v3(x=0,y=0,z=0){ return {x,y,z}; }
    function sub(a,b){ return {x:a.x-b.x,y:a.y-b.y,z:a.z-b.z}; }
    function len(a){ return Math.hypot(a.x,a.y,a.z); }
    function clamp(x,a,b){ return Math.max(a,Math.min(b,x)); }

    class PBDCloth{
      constructor(w,h,dx,dy){
        this.w=w; this.h=h; this.dx=dx; this.dy=dy;
        this.pos=[]; this.prev=[]; this.invMass=[]; this.pins=new Set();
        for(let y=0;y<=h;y++){
          for(let x=0;x<=w;x++){
            const p=v3((x-w/2)*dx, (h/2-y)*dy, 0);
            this.pos.push(p); this.prev.push({...p}); this.invMass.push(1);
          }
        }
        this.constraints=[]; const idx=(x,y)=>y*(this.w+1)+x;
        for(let y=0;y<=h;y++){
          for(let x=0;x<=w;x++){
            if(x<w) this.addDist(idx(x,y), idx(x+1,y), dx);
            if(y<h) this.addDist(idx(x,y), idx(x,y+1), dy);
            if(x<w && y<h) this.addDist(idx(x,y), idx(x+1,y+1), Math.hypot(dx,dy));
            if(x>0 && y<h) this.addDist(idx(x,y), idx(x-1,y+1), Math.hypot(dx,dy));
          }
        }
      }
      addDist(i,j,L){ this.constraints.push({i,j,L}); }
      pin(x,y){ this.pins.add(y*(this.w+1)+x); this.invMass[y*(this.w+1)+x]=0; }
      step(dt,iters){
        for(let i=0;i<this.pos.length;i++){
          const p=this.pos[i], q=this.prev[i];
          const vx=(p.x-q.x)*0.99, vy=(p.y-q.y)*0.99, vz=(p.z-q.z)*0.99;
          q.x=p.x; q.y=p.y; q.z=p.z;
          if(this.invMass[i]>0){ p.x+=vx + gravity.x*dt*dt; p.y+=vy + gravity.y*dt*dt; p.z+=vz + gravity.z*dt*dt; }
        }
        for(let k=0;k<iters;k++){
          for(const c of this.constraints){
            const a=c.i, b=c.j; const pa=this.pos[a], pb=this.pos[b];
            const d=sub(pb,pa); const L=len(d)||1; const diff=(L-c.L)/L; const cx=.5*diff*d.x, cy=.5*diff*d.y, cz=.5*diff*d.z;
            if(this.invMass[a]>0){ pa.x+=cx; pa.y+=cy; pa.z+=cz; } if(this.invMass[b]>0){ pb.x-=cx; pb.y-=cy; pb.z-=cz; }
          }
        }
      }
    }
    class PBDSuture{
      constructor(num=70, segLen=0.01){ this.segLen=segLen; this.pos=[]; this.prev=[]; this.invMass=[]; for(let i=0;i<num;i++){ const p=v3(0,0,-i*segLen); this.pos.push(p); this.prev.push({...p}); this.invMass.push(i===0?0:1);} this.tension=0; }
      step(dt,iters,anchors=[]){
        for(let i=0;i<this.pos.length;i++){
          const p=this.pos[i], q=this.prev[i];
          const vx=(p.x-q.x)*0.995, vy=(p.y-q.y)*0.995, vz=(p.z-q.z)*0.995;
          q.x=p.x; q.y=p.y; q.z=p.z;
          if(this.invMass[i]>0){ p.x+=vx + gravity.x*dt*dt; p.y+=vy + gravity.y*dt*dt; p.z+=vz + gravity.z*dt*dt; }
        }
        for(const a of anchors){ const i=a.i; if(i!=null){ this.pos[i].x=a.p.x; this.pos[i].y=a.p.y; this.pos[i].z=a.p.z; this.prev[i].x=a.p.x; this.prev[i].y=a.p.y; this.prev[i].z=a.p.z; }}
        let peak=0;
        for(let k=0;k<iters;k++){
          for(let i=0;i<this.pos.length-1;i++){
            const a=this.pos[i], b=this.pos[i+1]; const dx=b.x-a.x, dy=b.y-a.y, dz=b.z-a.z; const L=Math.hypot(dx,dy,dz)||1;
            const diff=(L-this.segLen)/L; peak=Math.max(peak, Math.abs(diff));
            const cx=.5*diff*dx, cy=.5*diff*dy, cz=.5*diff*dz;
            if(this.invMass[i]>0){ a.x+=cx; a.y+=cy; a.z+=cz; } if(this.invMass[i+1]>0){ b.x-=cx; b.y-=cy; b.z-=cz; }
          }
        }
        this.tension = clamp(peak*100,0,100);
      }
    }

    function drawHeat(px){ if(!ctx) return; const w=64,h=64; const img=ctx.createImageData(w,h); for(let i=0;i<w*h;i++){ const t = Math.min(255, Math.floor(px*2.55)); img.data[i*4+0]=t; img.data[i*4+1]=40; img.data[i*4+2]=120; img.data[i*4+3]=200; } ctx.putImageData(img,0,0); }

    onmessage = (e)=>{
      const {type} = e.data||{};
      if(type==='init'){
        const {w,h,dx,dy, ropeN, segLen, pinTop, offscreen} = e.data;
        cloth = new PBDCloth(w,h,dx,dy);
        if(pinTop){ for(let x=0;x<=cloth.w;x++) cloth.pin(x,0); }
        suture = new PBDSuture(ropeN, segLen);
        if(offscreen){ ctx = offscreen.getContext('2d'); }
        postMessage({type:'ready'});
      }else if(type==='step'){
        const {dt, anchor} = e.data;
        cloth.step(dt, itersCloth);
        suture.step(dt, itersRope, anchor?[{i:0,p:anchor}]:[]);
        // Offscreen heat debug ~ tension
        drawHeat(suture.tension);
        // Pack positions
        const cPos = new Float32Array(cloth.pos.length*3);
        for(let i=0;i<cloth.pos.length;i++){ const p=cloth.pos[i]; cPos[i*3+0]=p.x; cPos[i*3+1]=p.y; cPos[i*3+2]=p.z; }
        const rPos = new Float32Array(suture.pos.length*3);
        for(let i=0;i<suture.pos.length;i++){ const p=suture.pos[i]; rPos[i*3+0]=p.x; rPos[i*3+1]=p.y; rPos[i*3+2]=p.z; }
        postMessage({type:'state', cloth:cPos, rope:rPos, tension:suture.tension}, [cPos.buffer, rPos.buffer]);
      }else if(type==='settings'){
        const {gravY, itsCloth, itsRope} = e.data;
        gravity.y = gravY;
        if(itsCloth) itersCloth=itsCloth;
        if(itsRope) itersRope=itsRope;
      }
    };
  </script>

  <!-- ================= SCENE (annulus + leaflet + labels) ================= -->
  <script type="module" id="scene">
    import {v3} from '#math';
    const T = window.THREE;

    export function buildValve(ringSizeMM){
      const ringScale = ringSizeMM/32;
      const torus = T.Utils.makeTorus(0.7*ringScale, 0.05*ringScale, 120, 18);
      const ring = new T.Mesh(torus.v, torus.n, torus.idx, [0.32,0.9,0.86]); ring.pos.set(0,0,0);

      const cloth = T.Utils.makeCloth(28, 20, 0.03*ringScale, 0.03*ringScale, [0,0.08*ringScale,0]);
      const leaflet = new T.Mesh(cloth.v, cloth.n, cloth.idx, [0.95,0.83,0.86]);

      const curve=[]; const seg=180; const R=0.7*ringScale;
      for(let i=0;i<seg;i++){ const a=i/seg*Math.PI*2; const x=Math.cos(a)*R, z=Math.sin(a)*R; curve.push(v3(x,0,z)); }

      const labels=[
        {id:'A1', p:v3(-0.45*ringScale,0, 0.45*ringScale)},
        {id:'A2', p:v3( 0.00*ringScale,0, 0.65*ringScale)},
        {id:'A3', p:v3( 0.45*ringScale,0, 0.45*ringScale)},
        {id:'P1', p:v3(-0.45*ringScale,0,-0.45*ringScale)},
        {id:'P2', p:v3( 0.00*ringScale,0,-0.65*ringScale)},
        {id:'P3', p:v3( 0.45*ringScale,0,-0.45*ringScale)}
      ];
      return { ring, leaflet, cloth, labels, curve, ringScale };
    }

    export function updateLeafletMesh(leafletMesh, clothPositions){
      const v = leafletMesh.vertices;
      for(let i=0;i<clothPositions.length; i++) v[i] = clothPositions[i];
      const n = leafletMesh.normals; for(let i=0;i<n.length;i+=3){ n[i]=0; n[i+1]=1; n[i+2]=0; }
    }
  </script>

  <!-- ================= IO (mouse/keys/gamepad) ================= -->
  <script type="module" id="io">
    import {clamp} from '#math';
    export class Input{
      constructor(canvas){ this.canvas=canvas; this.keys=new Set(); this.orbit={theta:0.9, phi:0.85, dist:2.1}; this.pan={x:0,y:0}; this.mouse={x:0,y:0, down:false}; this.clutch=false; this._bind(); }
      _bind(){ const c=this.canvas; c.tabIndex=0;
        c.addEventListener('keydown',e=>{this.keys.add(e.key.toLowerCase()); if(e.key===' ') this.clutch=!this.clutch;});
        c.addEventListener('keyup',e=>{this.keys.delete(e.key.toLowerCase());});
        c.addEventListener('mousedown',e=>{ if(e.button===0) this.mouse.down=true; this._store(e); });
        c.addEventListener('mouseup',()=>{ this.mouse.down=false;});
        c.addEventListener('mousemove',e=>{ this._store(e);
          if(e.buttons===2){ this.orbit.theta+=e.movementX*0.005; this.orbit.phi=clamp(this.orbit.phi+e.movementY*0.005, 0.1, 1.55);}
          else if(e.buttons===4){ this.pan.x+=e.movementX*0.002; this.pan.y-=e.movementY*0.002; }
        });
        c.addEventListener('wheel',e=>{ this.orbit.dist=clamp(this.orbit.dist+e.deltaY*0.001, 1.2, 4.0); });
        c.addEventListener('contextmenu',e=>e.preventDefault());
        window.addEventListener('blur',()=>{this.keys.clear(); this.mouse.down=false;});
      }
      _store(e){ const r=this.canvas.getBoundingClientRect(); this.mouse.x=(e.clientX-r.left)/r.width*2-1; this.mouse.y=-( (e.clientY-r.top)/r.height*2-1 ); }
    }
  </script>

  <!-- ================= AI COACH ================= -->
  <script type="module" id="ai">
    import {jerk} from '#math';
    export class Coach{
      constructor(){ this.enabled=true; this.lastMsg=''; this.hints=['Drive needle at ~90° to surface','Aim symmetric entry/exit bites','Keep steady tension while tying']; this.buffer=[]; this.out={intent:'',severity:0}; this.usesORT=false; this._initHints(); }
      _initHints(){ const ul=document.getElementById('hints'); ul.innerHTML=''; for(const h of this.hints){ const li=document.createElement('li'); li.textContent='• '+h; ul.appendChild(li);} }
      async tryORT(){ try{ const s=new window.ort.InferenceSession(); await s.loadModel(window.__ONNX_BASE64__); this.sess=s; this.usesORT=true; }catch(e){ this.usesORT=false; } }
      update(feat){ // feat: {dt, speed, angleErr, spacingSD, peakTension, collisions}
        this.buffer.push(feat); if(this.buffer.length>120) this.buffer.shift();
        let intent='', severity=0;
        if(feat.angleErr>15){ intent='Increase needle entry angle (closer to 90°)'; severity=Math.min(100,(feat.angleErr-10)*2); }
        else if(feat.peakTension>85){ intent='Over-tensioning — ease and equalize pull'; severity=85; }
        else{
          const speeds=this.buffer.map(b=>b.speed||0), sJerks=[];
          for(let i=2;i<this.buffer.length;i++){ sJerks.push(jerk({x:speeds[i-2],y:0,z:0},{x:speeds[i-1],y:0,z:0},{x:speeds[i],y:0,z:0}, feat.dt)); }
          const meanJ = sJerks.reduce((a,b)=>a+b,0)/(sJerks.length||1);
          if(meanJ>50){ intent='Smooth your motion before puncture'; severity=60; }
        }
        if(!intent && feat.spacingSD>2){ intent='Improve bite spacing consistency'; severity=50; }
        if(!intent) intent='Good — continue';
        this.out={intent, severity};
        return this.out;
      }
    }
  </script>

  <!-- ================= SCORE ENGINE ================= -->
  <script type="module" id="score">
    import {clamp} from '#math';
    export class ScoreEngine{
      constructor(){ this.sub={task:0,gears:0,goals:0,osats:0}; this.final=0; this.errors=[]; }
      compute(m){
        const angle=clamp(100-Math.abs(m.angleErr)*3,0,100);
        const spacing=clamp(100-Math.max(0,m.spacingSD-0.5)*20,0,100);
        const tension=clamp(100-Math.max(0,m.peakTension-70)*1.5,0,100);
        const coapt=clamp((m.coaptationMM/10)*100,0,100);
        const task = Math.round(0.3*angle + 0.3*spacing + 0.25*tension + 0.15*coapt);

        const gears = Math.round(0.25*spacing + 0.25*(100-m.pathLengthPenalty) + 0.25*(100-m.tensionOvershoot) + 0.25*(100-m.hintUsage*20));
        const goals = Math.round(0.34*(100-m.depthErrors) + 0.33*(100-m.collisions*10) + 0.33*(100-m.timePenalty));
        const osats = Math.round(0.4*(100-m.collisions*10) + 0.3*(100-m.timePenalty) + 0.3*(100-m.flowBreaks*15));

        this.sub={task,gears,goals,osats};
        this.final = Math.round(0.4*task + 0.25*gears + 0.2*goals + 0.15*osats);
        this.errors=[];
        if(m.angleErr>20) this.errors.push('Shallow needle angle');
        if(m.spacingSD>3) this.errors.push('Uneven bite spacing');
        if(m.peakTension>90) this.errors.push('Over-tensioning risk');
        if(m.collisions>2) this.errors.push('Excess tissue collisions');
        return {sub:this.sub, final:this.final, errors:this.errors};
      }
    }
  </script>

  <!-- ================= HUD (gauges + bars) ================= -->
  <script type="module" id="hud">
    export class HUD{
      constructor(canvas){ this.c=canvas; this.ctx=canvas.getContext('2d'); this.on=true; }
      resize(w,h){ this.c.width=w; this.c.height=h; }
      draw(o){ if(!this.on) return; const ctx=this.ctx; const w=this.c.width, h=this.c.height; ctx.clearRect(0,0,w,h);
        ctx.save(); ctx.translate(110, h-120); this._gauge('Angle', o.angleErr, -30, 30); ctx.restore();
        ctx.save(); ctx.translate(240, h-100); this._bar('Tension', o.peakTension, 0, 100); ctx.restore();
        ctx.save(); ctx.translate(380, h-100); this._bar('Spacing SD', o.spacingSD, 0, 6); ctx.restore();
        ctx.save(); ctx.translate(540, h-100); this._bar('Coaptation mm', o.coaptationMM, 0, 12); ctx.restore();
      }
      _gauge(name,val,lo,hi){ const ctx=this.ctx; ctx.fillStyle='#a6e3ff'; ctx.font='12px system-ui'; ctx.fillText(name, -30, -50); ctx.beginPath(); ctx.strokeStyle='#1b2a45'; ctx.lineWidth=10; ctx.arc(0,0,42,Math.PI,0); ctx.stroke(); const t=(val-lo)/(hi-lo); const ang=Math.PI*(1-t); ctx.beginPath(); ctx.strokeStyle=t>0.7?'#ef4444':(t>0.4?'#f59e0b':'#34d399'); ctx.lineWidth=10; ctx.arc(0,0,42,Math.PI,ang,true); ctx.stroke(); ctx.fillStyle='#94a3b8'; ctx.fillText((val).toFixed(1)+'°', -14, 8); }
      _bar(name,val,lo,hi){ const ctx=this.ctx; const w=140,h=12; const t=(val-lo)/(hi-lo); ctx.fillStyle='#a6e3ff'; ctx.font='12px system-ui'; ctx.fillText(name, 0,-8); ctx.fillStyle='#152033'; ctx.fillRect(0,0,w,h); ctx.fillStyle= t>0.75?'#ef4444':(t>0.5?'#f59e0b':'#34d399'); ctx.fillRect(0,0,Math.max(0,Math.min(w,t*w)),h); ctx.fillStyle='#94a3b8'; ctx.fillText((val).toFixed(2), w+8, 10); }
    }
  </script>

  <!-- ================= REPLAY ================= -->
  <script type="module" id="replay">
    export class Replay{
      constructor(){ this.frames=[]; this.isRecording=false; this.ptr=0; this.mode='idle'; }
      recordFrame(f){ if(this.isRecording) this.frames.push(structuredClone(f)); }
      start(){ this.frames=[]; this.isRecording=true; }
      stop(){ this.isRecording=false; }
      play(){ this.mode='play'; this.ptr=0; }
      step(){ if(this.mode!=='play') return null; if(this.ptr>=this.frames.length){ this.mode='idle'; return null;} return this.frames[this.ptr++]; }
      export(){ return JSON.stringify(this.frames); }
      import(json){ this.frames=JSON.parse(json||'[]'); }
    }
  </script>

  <!-- ================= MAIN ================= -->
  <script type="module" id="main">
    /* Module aliasing: allow inline modules to import via #id */
    const moduleMap = new Map();
    function alias(id){ const s=document.getElementById(id); const url = URL.createObjectURL(new Blob([s.textContent],{type:'application/javascript'})); return url; }
    moduleMap.set('#math', alias('math'));
    moduleMap.set('#physics', alias('physics'));
    moduleMap.set('#scene', alias('scene'));
    moduleMap.set('#io', alias('io'));
    moduleMap.set('#ai', alias('ai'));
    moduleMap.set('#score', alias('score'));
    moduleMap.set('#hud', alias('hud'));
    moduleMap.set('#replay', alias('replay'));
    const imp = (id)=>import(moduleMap.get(id));

    /* ---- Short-hands ---- */
    const $ = (sel)=>document.querySelector(sel);
    const byId=(id)=>document.getElementById(id);

    /* ---- Imports ---- */
    const T = window.THREE;
    const { v3, clamp } = await imp('#math');
    const { PBDCloth, PBDSuture, projectPointOnCurve } = await imp('#physics');
    const { buildValve, updateLeafletMesh } = await imp('#scene');
    const { Input } = await imp('#io');
    const { Coach } = await imp('#ai');
    const { ScoreEngine } = await imp('#score');
    const { HUD } = await imp('#hud');
    const { Replay } = await imp('#replay');

    /* ---- DOM elements ---- */
    const sim = byId('sim'), hud = byId('hud'), minimap = byId('minimap'), computeCanvas = byId('compute');
    const ui = {
      angle:byId('needleAngle'), biteErr:byId('biteError'), spacingSD:byId('spacingSD'),
      tension:byId('tension'), coapt:byId('coaptation'), fps:byId('fps'),
      task:byId('taskScore'), gears:byId('gearsScore'), goals:byId('goalsScore'), osats:byId('osatsScore'), final:byId('finalScore'),
      coachMsg:byId('coachMsg'), coachAria:byId('coach-aria'), hints:byId('hints'), status:byId('status')
    };

    /* ---- Renderer & Camera ---- */
    const renderer = new T.Renderer(sim);
    const cam = new T.Camera();

    /* ---- Input ---- */
    const input = new Input(sim);

    /* ---- Scene / Valve ---- */
    let valve = buildValve(32);
    const meshes = [ valve.ring, valve.leaflet ];

    /* ---- HUD ---- */
    const hudUI = new HUD(hud);

    /* ---- Physics in Worker ---- */
    const workerSrc = document.getElementById('physics-worker').textContent;
    const worker = new Worker(URL.createObjectURL(new Blob([workerSrc],{type:'application/javascript'})));
    const offscreen = computeCanvas.transferControlToOffscreen ? computeCanvas.transferControlToOffscreen() : null;
    worker.postMessage({
      type:'init',
      w:valve.cloth.w, h:valve.cloth.h, dx:0.03, dy:0.03,
      ropeN:70, segLen:0.01, pinTop:true, offscreen
    }, offscreen? [offscreen] : []);

    let clothPositions = new Float32Array(valve.leaflet.vertices.length);
    let ropePositions  = new Float32Array(70*3);
    let ropeTension = 0;

    worker.onmessage = (e)=>{
      const {type} = e.data||{};
      if(type==='state'){
        clothPositions = e.data.cloth;
        ropePositions  = e.data.rope;
        ropeTension    = e.data.tension;
      }
    };

    /* ---- Task state ---- */
    let mode=1; const setMode=(m)=>{ mode=m; ['mode1','mode2','mode3'].forEach((id,i)=>{ byId(id).setAttribute('aria-pressed', String(i+1===mode)); }); ui.status.textContent = m===1?'Ring placement': m===2?'Leaflet bite':'Knot & tension'; };
    setMode(1);
    byId('mode1').onclick=()=>setMode(1); byId('mode2').onclick=()=>setMode(2); byId('mode3').onclick=()=>setMode(3);
    let overlays=true, paused=false; byId('toggleExam').onclick=()=>{ overlays=!overlays; hudUI.on=overlays; ui.status.textContent=overlays?'Training Overlays On':'Exam Mode'; };
    byId('resetBtn').onclick=()=>{ placeInitialTargets(); ui.status.textContent='Reset'; };

    /* ---- Bite targets ---- */
    const bites=[]; const posteriorIndices=[]; for(let i=0;i<valve.curve.length;i++){ if(valve.curve[i].z<0) posteriorIndices.push(i); }
    function placeInitialTargets(){ bites.length=0; const step=Math.floor(posteriorIndices.length/4); const mid=posteriorIndices[Math.floor(posteriorIndices.length/2)];
      bites.push({p:valve.curve[mid-step]}); bites.push({p:valve.curve[mid]}); bites.push({p:valve.curve[mid+step]}); }
    placeInitialTargets();

    /* ---- Instrument tip ---- */
    const tip = { x:0, y:0.05, z:0.6, vx:0, vy:0, vz:0 };

    /* ---- AI Coach & Score ---- */
    const coach = new Coach(); coach.tryORT();
    const scorer = new ScoreEngine();

    /* ---- Metrics ---- */
    const metrics = { angleErr:0, spacingSD:0, peakTension:0, coaptationMM:0, collisions:0, pathLengthPenalty:0, tensionOvershoot:0, hintUsage:0, depthErrors:0, timePenalty:0, flowBreaks:0 };

    /* ---- Replay ---- */
    const replay = new Replay();
    byId('recordBtn').onclick=()=>{ if(replay.isRecording){ replay.stop(); ui.status.textContent='Recording stopped'; } else { replay.start(); ui.status.textContent='Recording…'; } };
    byId('replayBtn').onclick=()=>{ replay.stop(); replay.play(); ui.status.textContent='Replaying'; };
    byId('exportBtn').onclick=()=>{ const blob=new Blob([replay.export()],{type:'application/json'}); const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download='attempt.json'; a.click(); };
    byId('importBtn').onclick=()=>{ const inp=document.createElement('input'); inp.type='file'; inp.accept='application/json'; inp.onchange=()=>{ const f=inp.files[0]; if(!f) return; const r=new FileReader(); r.onload=()=>{ replay.import(r.result); ui.status.textContent='Imported replay'; }; r.readAsText(f); }; inp.click(); };

    /* ---- Resize / Camera ---- */
    function resize(){ sim.width=innerWidth*devicePixelRatio; sim.height=innerHeight*devicePixelRatio; hudUI.resize(sim.width, sim.height); renderer.resize(sim.width, sim.height); cam.update(sim.width, sim.height); }
    addEventListener('resize', resize); resize();
    function updateCamera(){ const o=input.orbit; const cx=Math.sin(o.phi)*Math.cos(o.theta)*o.dist; const cy=Math.cos(o.phi)*o.dist; const cz=Math.sin(o.phi)*Math.sin(o.theta)*o.dist; cam.eye.set(cx+input.pan.x, cy+input.pan.y, cz); cam.center.set(0,0,0); cam.update(renderer.w, renderer.h); }

    /* ---- Screen to world ---- */
    function screenToWorld(x,y){ const rx=x*cam.aspect*Math.tan(cam.fov/2), ry=y*Math.tan(cam.fov/2); const dir=new T.Vec3(rx,ry,-1).norm(); const t = (0.05 - cam.eye.y) / dir.y; const wx = cam.eye.x + dir.x*t; const wy = cam.eye.y + dir.y*t; const wz = cam.eye.z + dir.z*t; return {x:wx,y:wy,z:wz}; }

    /* ---- Mouse interactions ---- */
    sim.addEventListener('mousedown', (e)=>{
      if(e.button!==0) return;
      const p=screenToWorld(input.mouse.x, input.mouse.y);
      if(mode===1){
        const proj = projectPointOnCurve(p, valve.curve);
        if(valve.curve[proj.index].z<0 && proj.dist<0.08){
          bites.push({p:valve.curve[proj.index]}); if(bites.length>3) bites.shift();
        }
      }else if(mode===2){
        // anchor suture to nearest ring point
        const proj = projectPointOnCurve(p, valve.curve);
        const at = valve.curve[proj.index];
        worker.postMessage({type:'step', dt:1/60, anchor:{x:at.x,y:at.y,z:at.z}});
      }
    });

    /* ---- Keyboard toggles ---- */
    addEventListener('keydown', (e)=>{ const k=e.key.toLowerCase(); if(k==='h'){ hudUI.on=!hudUI.on; } if(k==='p'){ paused=!paused; } if(k==='1'){setMode(1)} if(k==='2'){setMode(2)} if(k==='3'){setMode(3)} });

    /* ---- Minimap ---- */
    function drawMinimap(){
      const ctx=minimap.getContext('2d'); const W=minimap.width, H=minimap.height;
      ctx.clearRect(0,0,W,H); ctx.save(); ctx.translate(W/2,H/2); ctx.scale(100,-100);
      ctx.strokeStyle='#334155'; ctx.lineWidth=0.01;
      ctx.beginPath(); valve.curve.forEach((p,i)=>{ (i?ctx.lineTo:ctx.moveTo).call(ctx,p.x,p.z); }); ctx.closePath(); ctx.stroke();
      ctx.scale(1,-1); ctx.fillStyle='#a5b4fc'; ctx.font='10px system-ui';
      for(const L of valve.labels){ ctx.save(); ctx.scale(1,-1); ctx.fillText(L.id, L.p.x*100-6, -L.p.z*100+4); ctx.restore(); }
      ctx.scale(1,-1);
      for(const b of bites){ ctx.fillStyle='#22d3ee'; ctx.beginPath(); ctx.arc(b.p.x, b.p.z, 0.015, 0, Math.PI*2); ctx.fill(); }
      ctx.restore();
    }

    /* ---- Main Loop ---- */
    let last=performance.now(), acc=0, fpsS=0, fpsC=0;
    function frame(){
      const now=performance.now(); const dt=(now-last)/1000; last=now; acc+=dt; fpsS+=dt*1000; fpsC++;
      if(!paused){
        while(acc>1/60){ step(1/60); acc-=1/60; }
        render();
        if(fpsS>1000){ ui.fps.textContent=(fpsC).toFixed(0); fpsS=0; fpsC=0; }
      }
      requestAnimationFrame(frame);
    }

    function step(dt){
      updateCamera();

      // Instrument tip follows mouse unless clutch engaged
      if(!input.clutch){
        const p=screenToWorld(input.mouse.x, input.mouse.y);
        const s=8*dt; tip.vx=(p.x-tip.x)*s; tip.vy=(p.y-tip.y)*s; tip.vz=(p.z-tip.z)*s;
        tip.x+=tip.vx*dt; tip.y+=tip.vy*dt; tip.z+=tip.vz*dt;
      }

      // Ask worker to step physics; anchor suture to center posterior point in modes 2/3
      let anchor = null;
      if(mode!==1){
        const midIdx = posteriorIndices[Math.floor(posteriorIndices.length/2)];
        anchor = valve.curve[midIdx];
      }
      worker.postMessage({type:'step', dt, anchor});

      // Metrics
      metrics.peakTension = Math.max(metrics.peakTension*0.95, ropeTension);

      // Needle angle proxy (camera ray vs tissue normal +Y)
      const ndir = {x:Math.sin(input.orbit.phi)*Math.cos(input.orbit.theta), y:-Math.cos(input.orbit.phi), z:Math.sin(input.orbit.phi)*Math.sin(input.orbit.theta)};
      const nrm = {x:0,y:1,z:0}; const d = (ndir.x*nrm.x + ndir.y*nrm.y + ndir.z*nrm.z);
      const ang = Math.acos(Math.max(-1,Math.min(1,d)))*180/Math.PI; metrics.angleErr = Math.abs(90-ang);

      if(bites.length===3){
        const ds=[]; for(let i=0;i<3;i++){ const a=bites[i].p, b=bites[(i+1)%3].p; const dist=Math.hypot(a.x-b.x,a.z-b.z)*1000/10; ds.push(dist); }
        const m=ds.reduce((a,b)=>a+b,0)/ds.length; const v=ds.reduce((a,b)=>a+(b-m)*(b-m),0)/ds.length; metrics.spacingSD=Math.sqrt(v);
      }

      // Coaptation estimate from cloth centerline height
      metrics.coaptationMM = Math.max(0, (0.12 - Math.abs(averageLeafletY()))*1000);

      // UI values
      ui.angle.textContent = metrics.angleErr.toFixed(1);
      ui.biteErr.textContent = '—';
      ui.spacingSD.textContent = metrics.spacingSD.toFixed(2);
      ui.tension.textContent = ropeTension.toFixed(1);
      ui.coapt.textContent = metrics.coaptationMM.toFixed(1);

      // AI coach
      const feat={ dt, speed:Math.hypot(tip.vx,tip.vy,tip.vz)*100, angleErr:metrics.angleErr, spacingSD:metrics.spacingSD, peakTension:metrics.peakTension, collisions:metrics.collisions };
      const out = coach.update(feat); ui.coachMsg.textContent = out.intent; ui.coachAria.textContent = out.intent;

      // Scoring
      const s=scorer.compute(metrics); ui.task.textContent=s.sub.task; ui.gears.textContent=s.sub.gears; ui.goals.textContent=s.sub.goals; ui.osats.textContent=s.sub.osats; ui.final.textContent=s.final;

      // Replay
      replay.recordFrame({tip:{...tip}, metrics:{...metrics}});
    }

    function averageLeafletY(){
      // clothPositions is Float32Array [x,y,z,...]
      let sum=0, c=0; for(let i=1;i<clothPositions.length;i+=3){ sum+=clothPositions[i]; c++; } return sum/(c||1);
    }

    function render(){
      // Update leaflet mesh from worker positions
      updateLeafletMesh(valve.leaflet, clothPositions);
      renderer.draw(meshes, cam.vp);
      hudUI.draw({ angleErr:metrics.angleErr, peakTension:metrics.peakTension, spacingSD:metrics.spacingSD, coaptationMM:metrics.coaptationMM });
      drawMinimap();
    }

    /* ---- Self-test mode (?test=1) ---- */
    if(new URL(location).searchParams.get('test')==='1'){
      console.group('Self-tests');
      console.assert(Math.abs((new (window.THREEL.Vec3)(1,0,0)).dot(new (window.THREEL.Vec3)(0,1,0)) - 0) < 1e-6, 'Vec3 dot');
      const rope = new PBDSuture(10, 1); rope.step(1/60, 10, [{i:0,p:{x:0,y:0,z:0}}]); console.assert(Math.abs(rope.length()-9) < 1e-3, 'Rope length preserved');
      console.groupEnd();
    }

    requestAnimationFrame(frame);
  </script>
</body>
</html>
