<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Mitral Suture Trainer â€” P2 Triangular Resection (Teach â€¢ Practice â€¢ Assess)</title>
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" />
<style>
  :root{
    --bg:#0b0f14; --ink:#eaf2f8; --mut:#9fb3c4; --ok:#2ed573; --warn:#ffb020; --bad:#ff4d4f;
    --panel:#0f151d; --line:#1f2b36; --accent:#52e2c0;
    --mono: ui-monospace,Menlo,Consolas,monospace; --sans: ui-sans-serif,system-ui,Segoe UI,Roboto,Helvetica,Arial;
  }
  html,body{margin:0;height:100%;background:var(--bg);color:var(--ink);font:14px/1.45 var(--sans)}
  #app{display:grid;grid-template-rows:58px 1fr 30px;height:100%}
  header{display:flex;gap:12px;align-items:center;padding:10px 14px;background:linear-gradient(180deg,#0e1520,#0b1218);border-bottom:1px solid #182330}
  header h1{margin:0;font-size:16px;font-weight:800}
  #toolbar{margin-left:auto;display:flex;gap:10px;flex-wrap:wrap;align-items:center}
  .grp{display:flex;gap:10px;align-items:center;background:#0f1823;border:1px solid #1b2733;border-radius:10px;padding:6px 8px}
  label{color:var(--mut);font-size:12px}
  select,button{background:#101825;color:#e6f0f6;border:1px solid #223243;border-radius:8px;padding:6px 10px;cursor:pointer}
  button:active{transform:translateY(1px)}
  main{display:grid;grid-template-columns:360px 1fr}
  aside{background:var(--panel);border-right:1px solid #1b2733;padding:12px;overflow:auto}
  aside h2{font-size:12px;letter-spacing:.1em;text-transform:uppercase;color:#a7bed1;margin:12px 0 8px}
  .card{background:rgba(9,14,19,.82);border:1px solid var(--line);border-radius:12px;padding:10px;margin-bottom:10px;backdrop-filter:blur(6px)}
  .kpi{display:flex;justify-content:space-between;font-family:var(--mono);font-weight:700}
  .pill{display:inline-block;border:1px solid #223243;border-radius:999px;padding:3px 8px;color:#a6c1d5;font-size:11px;margin:4px 4px 0 0}
  .toolbtn{display:flex;gap:6px;align-items:center;width:100%}
  .toolbtn.active{outline:2px solid #3c5977}
  .coach{background:#0d1621;border-left:4px solid #3b82f6;padding:10px;border-radius:8px}
  .ok{color:var(--ok)} .warn{color:var(--warn)} .bad{color:var(--bad)} .mut{color:#9fb3c4}
  #stage{position:relative;background:radial-gradient(60% 70% at 50% 50%,#0c141b 0%,#0a1016 100%)}
  canvas{display:block;width:100%;height:100%}
  #hud{position:absolute;top:10px;left:10px;display:grid;gap:8px;pointer-events:none}
  #hud .card{pointer-events:auto;min-width:280px}
  #tensionBox{position:absolute;left:12px;bottom:12px;background:rgba(9,14,19,.88);border:1px solid #1f2b36;border-radius:8px;padding:6px 8px;color:#cfe8ff;display:none}
  #tensionBox input[type=range]{width:180px}
  #coachBox{position:absolute;right:12px;top:12px;width:min(420px,36vw);max-height:60vh;overflow:auto;background:rgba(9,14,19,.88);border:1px solid #1f2b36;border-radius:12px;padding:12px;display:none}
  #coachBox h3{margin:0 0 6px 0}
  #ghostNext{position:absolute;right:12px;bottom:12px;background:rgba(12,18,27,.88);border:1px dashed #335; padding:6px 10px;border-radius:10px;color:#cfe8ff;display:none}
  footer{display:flex;gap:10px;align-items:center;padding:6px 10px;border-top:1px solid #182330;color:#8dadc1}
  #status{color:#cfe8ff}
</style>
</head>
<body>
<div id="app">
  <header>
    <h1>Mitral Suture Trainer â€” P2 Triangular Resection Closure</h1>
    <div id="toolbar">
      <div class="grp">
        <label>Mode</label>
        <select id="mode">
          <option value="teach">Teach (step-gated)</option>
          <option value="practice">Practice (AI Copilot)</option>
          <option value="assess">Assess (scored)</option>
        </select>
      </div>
      <div class="grp">
        <label>Case</label>
        <select id="case">
          <option value="p2_mid">P2 central wedge</option>
          <option value="p2_wide">P2 wide wedge</option>
          <option value="p2_small">P2 small wedge</option>
        </select>
        <button id="load">Load case</button>
      </div>
      <div class="grp">
        <button id="start">Start</button>
        <button id="reset">Reset</button>
        <button id="export">Export JSON</button>
      </div>
    </div>
  </header>

  <main>
    <aside>
      <h2>Tools</h2>
      <div class="card">
        <button class="toolbtn" id="tool_place">ðŸª¡ Place bite (entry â†’ exit)</button>
        <button class="toolbtn" id="tool_tension">ðŸŽ¯ Tighten knot (set tension)</button>
        <button class="toolbtn" id="tool_remove">ðŸ§¹ Remove last bite</button>
        <button class="toolbtn" id="tool_finish">âœ… Finish & score</button>
      </div>

      <h2>Targets (clinical)</h2>
      <div class="card">
        <ul class="mut" style="margin:0 0 6px 16px; padding:0">
          <li>Bite depth: <b>4â€“6 mm</b> from cut edge (both sides)</li>
          <li>Bite angle: <b>â‰ˆ60Â°Â±15Â°</b> to edge</li>
          <li>Spacing: uniform <b>~4â€“5 mm</b> along wedge</li>
          <li>Symmetry: entryâ‰ˆexit depth</li>
          <li>Tension: coaptation flush (no gap, no strangulation)</li>
        </ul>
        <div class="pill">Depth bands are painted on the edge (2â€“8 mm)</div>
      </div>

      <h2>Session metrics</h2>
      <div class="card" id="scoreSummary">
        <div class="kpi"><span>Bites placed</span><span id="biteN">0</span></div>
        <div class="kpi"><span>Avg depth error</span><span id="depthErr">â€”</span></div>
        <div class="kpi"><span>Avg angle error</span><span id="angleErr">â€”</span></div>
        <div class="kpi"><span>Spacing CV</span><span id="spacing">â€”</span></div>
        <div class="kpi"><span>Symmetry error</span><span id="sym">â€”</span></div>
        <div class="kpi"><span>Residual gap</span><span id="gap">â€”</span></div>
        <div class="kpi"><span>Time</span><span id="time">â€”</span></div>
        <div class="kpi"><span>Overall</span><span id="overall">â€”</span></div>
      </div>

      <h2>Coach log</h2>
      <div class="card coach" id="coachFeed" style="white-space:pre-wrap">â€”</div>

      <h2>Shortcuts</h2>
      <div class="card">
        <div class="pill">Left click: place entry/exit</div>
        <div class="pill">Z: remove last â€¢ F: finish</div>
        <div class="pill">Shift+drag: pan â€¢ Wheel: zoom</div>
      </div>
    </aside>

    <section id="stage">
      <div id="hud">
        <div class="card">
          <div style="font-weight:800;margin-bottom:6px">Step</div>
          <div id="stepText">Click left edge (entry)</div>
        </div>
        <div class="card">
          <div style="font-weight:800;margin-bottom:6px">Realtime feedback</div>
          <div id="fb">â€”</div>
        </div>
      </div>
      <div id="tensionBox">Tension <input id="tens" type="range" min="0.70" max="1.00" step="0.01" value="1.00"> <span id="tv">loose</span></div>
      <div id="coachBox" class="coach">
        <h3 id="coachTitle">Teaching Mode</h3>
        <div id="coachText">When youâ€™re ready, place the <b>apex bite</b>: entry on LEFT, exit on RIGHT, depth 5 mm, angle ~60Â°.</div>
        <div style="margin-top:8px"><button id="coachPrev">â—€ Back</button> <button id="coachNext">Next â–¶</button></div>
      </div>
      <div id="ghostNext">Next target shown as <span style="color:#FFEB99">gold dot</span>. Keep 4â€“6 mm depth and ~5 mm spacing.</div>
    </section>
  </main>

  <footer>
    <div>Surgeon view â€¢ Realistic needle arc + suture tension â€¢ Step-gated teaching, AI Copilot coaching. For education; not a medical device.</div>
    <div id="status"></div>
  </footer>
</div>

<script type="module">
/* ============ Status & helpers ============ */
const clamp = (x,a,b)=>Math.max(a,Math.min(b,x));
const now = ()=>performance.now();
function setStatus(t, cls=''){ const el=document.getElementById('status'); el.textContent=t; el.className=cls; }

/* ============ OFFLINE-FIRST loader (local â†’ CDNs) ============ */
async function loadThree() {
  const tries = [
    // 1) LOCAL files (recommended) â€” works offline / behind firewalls
    async ()=>({
      THREE:        await import('./lib/three.module.js'),
      OrbitControls:(await import('./lib/controls.OrbitControls.js')).OrbitControls,
      Line2:        (await import('./lib/lines.Line2.js')).Line2,
      LineGeometry: (await import('./lib/lines.LineGeometry.js')).LineGeometry,
      LineMaterial: (await import('./lib/lines.LineMaterial.js')).LineMaterial
    }),
    // 2) CDNs as fallbacks
    async ()=>({
      THREE:        await import('https://unpkg.com/three@0.160.0/build/three.module.js'),
      OrbitControls:(await import('https://unpkg.com/three@0.160.0/examples/jsm/controls/OrbitControls.js')).OrbitControls,
      Line2:        (await import('https://unpkg.com/three@0.160.0/examples/jsm/lines/Line2.js')).Line2,
      LineGeometry: (await import('https://unpkg.com/three@0.160.0/examples/jsm/lines/LineGeometry.js')).LineGeometry,
      LineMaterial: (await import('https://unpkg.com/three@0.160.0/examples/jsm/lines/LineMaterial.js')).LineMaterial
    }),
    async ()=>({
      THREE:        await import('https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js'),
      OrbitControls:(await import('https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/controls/OrbitControls.js')).OrbitControls,
      Line2:        (await import('https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/lines/Line2.js')).Line2,
      LineGeometry: (await import('https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/lines/LineGeometry.js')).LineGeometry,
      LineMaterial: (await import('https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/lines/LineMaterial.js')).LineMaterial
    })
  ];
  let lastErr=null;
  for(const t of tries){ try{ return await t(); } catch(e){ lastErr=e; } }
  throw lastErr || new Error('Three.js failed to load from all sources');
}
setStatus('Loading 3D engineâ€¦');
const { THREE, OrbitControls, Line2, LineGeometry, LineMaterial } = await loadThree().catch(e=>{ console.error(e); setStatus('Could not load 3D engine (local/ CDN blocked?)','bad'); throw e; });
setStatus('Loaded.','ok');

/* ============ Scene / camera ============ */
const stage = document.getElementById('stage');
const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true });
renderer.setSize(stage.clientWidth, stage.clientHeight);
renderer.setPixelRatio(Math.min(2, window.devicePixelRatio||1));
stage.appendChild(renderer.domElement);

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x0b1016);

const camera = new THREE.PerspectiveCamera(50, stage.clientWidth/stage.clientHeight, 0.1, 5000);
camera.position.set(0, 70, 160);

const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true; controls.dampingFactor=0.06; controls.minDistance=90; controls.maxDistance=260;

const hemi = new THREE.HemisphereLight(0xbfdcff, 0x0a0d10, 0.85);
const key  = new THREE.DirectionalLight(0xffffff, 1.15); key.position.set(200,240,180); key.castShadow = true;
const fill = new THREE.DirectionalLight(0xaaccff, 0.35); fill.position.set(-160,40,-80);
scene.add(hemi,key,fill);

const floor = new THREE.Mesh(new THREE.CircleGeometry(800,64), new THREE.MeshStandardMaterial({color:0x0b1219, metalness:0.15, roughness:0.95}));
floor.rotation.x = -Math.PI/2; floor.receiveShadow = true; scene.add(floor);

/* ============ Anatomy (posterior wedge edges with depth bands) ============ */
const mm = v=>v;
const ANN_RES=96;
function dShapePoints(Rlat=mm(18), Rantr=mm(15), saddle=mm(6)){
  const pts=[]; for(let i=0;i<ANN_RES;i++){ const t=i/ANN_RES, th=t*Math.PI*2, w=(Math.cos(th)>0)?0.5:1.0;
    const rX=THREE.MathUtils.lerp(Rantr,Rlat,w), rZ=Rlat;
    const x=rX*Math.cos(th), z=rZ*Math.sin(th), y=saddle*Math.cos(2*th); pts.push(new THREE.Vector3(x,y,z)); }
  return pts;
}
const annPts=dShapePoints(18,15,6); const annCurve=new THREE.CatmullRomCurve3(annPts,true);
const annulus=new THREE.Mesh(new THREE.TubeGeometry(annCurve, ANN_RES, 1.3, 32, true), new THREE.MeshStandardMaterial({color:0x8fa6c2, metalness:.45, roughness:.35}));
annulus.castShadow=annulus.receiveShadow=true; scene.add(annulus);

/* Papillary muscles (context) */
const papAL=new THREE.Mesh(new THREE.ConeGeometry(3.4,16,24), new THREE.MeshStandardMaterial({color:0x405a70,metalness:.4,roughness:.55}));
const papPM=papAL.clone(); papAL.position.set(+15,-36,+15); papPM.position.set(-18,-40,-18); papAL.rotation.x=papPM.rotation.x=Math.PI; scene.add(papAL,papPM);

/* Leaflet fabric texture */
function makeLeafletTexture(){
  const c=document.createElement('canvas'); c.width=512; c.height=512; const g=c.getContext('2d');
  const grd=g.createLinearGradient(0,0,0,512); grd.addColorStop(0,'#eef5ff'); grd.addColorStop(1,'#e7eefc'); g.fillStyle=grd; g.fillRect(0,0,512,512);
  g.globalAlpha=0.18; g.strokeStyle='#c9d7ef';
  for(let i=0;i<220;i++){ const x=Math.random()*512, y=Math.random()*512, R=8+Math.random()*28; g.beginPath(); g.ellipse(x,y,R,R*0.35,Math.random()*Math.PI,0,Math.PI*2); g.stroke(); }
  const img=g.getImageData(0,0,512,512); for(let i=0;i<img.data.length;i+=4){ img.data[i]+= (Math.random()*8)|0; img.data[i+1]+= (Math.random()*8)|0; img.data[i+2]+= (Math.random()*6)|0; } g.putImageData(img,0,0);
  const tex=new THREE.CanvasTexture(c); tex.wrapS=tex.wrapT=THREE.RepeatWrapping; tex.repeat.set(2,1); return tex;
}
const leafletTex=makeLeafletTexture();

/* Posterior resection edges */
const EDGE_SEGS=56, STRIP_W=mm(8);
function posteriorEdgeCurve(){
  const pts=[]; for(let i=ANN_RES*0.55;i<ANN_RES*0.98;i+= (ANN_RES*0.43)/EDGE_SEGS ){ const p=annPts[Math.floor(i)%ANN_RES].clone(); p.y -= 1.5*Math.cos((i/(ANN_RES*0.43))*Math.PI); pts.push(p); }
  return new THREE.CatmullRomCurve3(pts,false);
}
let basePosterior=posteriorEdgeCurve();
function resectionPair(base, dz){ const pts=base.getPoints(EDGE_SEGS); const rightPts=pts.map(p=>p.clone().add(new THREE.Vector3(0,0,dz))); return {left:new THREE.CatmullRomCurve3(pts), right:new THREE.CatmullRomCurve3(rightPts)};}
let gapDZ=mm(6); let edges=resectionPair(basePosterior,gapDZ);

function stripFromCurve(curve,color,alpha=0.95,paintDepth=false){
  const pts=curve.getPoints(EDGE_SEGS);
  const geom=new THREE.BufferGeometry(), vtx=new Float32Array((EDGE_SEGS+1)*2*3), uv=new Float32Array((EDGE_SEGS+1)*2*2), idx=[];
  for(let i=0;i<=EDGE_SEGS;i++){
    const p=pts[i], dir=(i<EDGE_SEGS? pts[i+1].clone().sub(pts[i]) : pts[i].clone().sub(pts[i-1])).normalize();
    const up=new THREE.Vector3(0,1,0), n=new THREE.Vector3().crossVectors(dir,up).normalize();
    const a=p.clone().add(n.clone().multiplyScalar(STRIP_W/2)), b=p.clone().add(n.clone().multiplyScalar(-STRIP_W/2));
    vtx.set([a.x,a.y,a.z],i*6+0); vtx.set([b.x,b.y,b.z],i*6+3); uv.set([0,i/EDGE_SEGS],i*4+0); uv.set([1,i/EDGE_SEGS],i*4+2);
    if(i<EDGE_SEGS){ const k=i*2; idx.push(k,k+1,k+2,k+1,k+3,k+2); }
  }
  geom.setAttribute('position', new THREE.BufferAttribute(vtx,3)); geom.setAttribute('uv', new THREE.BufferAttribute(uv,2)); geom.setIndex(idx); geom.computeVertexNormals();
  let mat;
  if(paintDepth){
    const c=document.createElement('canvas'); c.width=256; c.height=1024; const g=c.getContext('2d');
    g.fillStyle='rgba(240,248,255,0.97)'; g.fillRect(0,0,256,1024); g.strokeStyle='rgba(60,90,150,0.55)'; g.lineWidth=2;
    for(let x=16;x<256;x+= (STRIP_W/6)*(256/STRIP_W) ){ g.beginPath(); g.moveTo(x,0); g.lineTo(x,1024); g.stroke(); }
    const mm2px=256/STRIP_W, x1=Math.round((STRIP_W/2-6)*mm2px), x2=Math.round((STRIP_W/2-4)*mm2px);
    g.fillStyle='rgba(255,235,153,0.35)'; g.fillRect(x1,0,(x2-x1),1024);
    const tex=new THREE.CanvasTexture(c); tex.wrapS=tex.wrapT=THREE.RepeatWrapping;
    mat=new THREE.MeshStandardMaterial({map:tex,color,metalness:.06,roughness:.82,side:THREE.DoubleSide,transparent:true,opacity:alpha});
  } else {
    mat=new THREE.MeshStandardMaterial({map:leafletTex,color,metalness:.06,roughness:.82,side:THREE.DoubleSide,transparent:true,opacity:alpha});
  }
  const mesh=new THREE.Mesh(geom,mat); mesh.castShadow=mesh.receiveShadow=true; return mesh;
}
let leftStrip=stripFromCurve(edges.left,0xf1f7ff,0.98,true);
let rightStrip=stripFromCurve(edges.right,0xe7efff,0.95,true);
scene.add(leftStrip,rightStrip);

/* Simple anterior context surface */
(function anteriorSurface(){
  const pts=[]; for(let i=ANN_RES*0.05;i<ANN_RES*0.55;i+= (ANN_RES*0.5)/42 ){ const p=annPts[Math.floor(i)%ANN_RES].clone(); const n=annPts[(Math.floor(i+1))%ANN_RES].clone().sub(annPts[(Math.floor(i-1+ANN_RES))%ANN_RES]).normalize(); const up=new THREE.Vector3(0,1,0); const lat=new THREE.Vector3().crossVectors(n,up).normalize(); p.addScaledVector(lat,-mm(18)); p.y -= mm(2)*Math.sin(i); pts.push(p); }
  const curve=new THREE.CatmullRomCurve3(pts); const g=new THREE.TubeGeometry(curve, 42, 9, 32, false);
  const m=new THREE.MeshStandardMaterial({map:leafletTex,color:0xf7fbff,metalness:.06,roughness:.82,transparent:true,opacity:0.22,side:THREE.DoubleSide});
  const mesh=new THREE.Mesh(g,m); mesh.receiveShadow=true; scene.add(mesh);
})();

/* ============ Needle & Suture rope ============ */
const needleGroup=new THREE.Group(); scene.add(needleGroup);
function makeNeedle(radius=mm(8), span=Math.PI*3/8){ const tube=new THREE.TorusGeometry(radius,0.5,18,96,span); const mat=new THREE.MeshStandardMaterial({color:0xa0b8cd,metalness:.8,roughness:.25}); const mesh=new THREE.Mesh(tube,mat); mesh.rotation.y=Math.PI/2; return mesh; }
function computeNeedlePath(entry,exit){ const mid=entry.clone().add(exit).multiplyScalar(0.5), chord=exit.clone().sub(entry), L=chord.length(); const R=Math.max(mm(6), L/1.8); const up=new THREE.Vector3(0,1,0); const n=new THREE.Vector3().crossVectors(chord,up).normalize(); return {mid,n,R,span:Math.PI*0.8}; }
let BUSY=false;
function animateNeedle(entry,exit,onDone){ BUSY=true; needleGroup.clear(); const {mid,n,R,span}=computeNeedlePath(entry,exit); const mesh=makeNeedle(R,span); needleGroup.add(mesh); const z=exit.clone().sub(entry).normalize(), x=new THREE.Vector3().crossVectors(n,z).normalize(), y=new THREE.Vector3().crossVectors(z,x).normalize(); const basis=new THREE.Matrix4().makeBasis(x,y,z), pos=new THREE.Matrix4().makeTranslation(mid.x,mid.y,mid.z); mesh.matrixAutoUpdate=false; let t=0; (function tick(){ t+=0.03; const angle=-span/2+span*Math.min(1,t); const rot=new THREE.Matrix4().makeRotationX(angle); mesh.matrix=pos.clone().multiply(basis).multiply(rot); renderer.render(scene,camera); if(t<1){ requestAnimationFrame(tick); } else { BUSY=false; onDone&&onDone(); } })(); }

class Rope{
  constructor(a,b,segments=18){ this.nodes=[]; for(let i=0;i<=segments;i++) this.nodes.push(a.clone().lerp(b,i/segments)); this.restLen=this.totalLength(); this.targetScale=1.0; }
  totalLength(){ let L=0; for(let i=1;i<this.nodes.length;i++) L+=this.nodes[i].distanceTo(this.nodes[i-1]); return L; }
  tighten(s){ this.targetScale=clamp(s,0.7,1.0); }
  step(){ const want=this.restLen*this.targetScale, have=this.totalLength(), excess=have-want; if(Math.abs(excess)<0.01) return; const perSeg=excess/(this.nodes.length-1); for(let i=1;i<this.nodes.length-1;i++){ const prev=this.nodes[i-1], cur=this.nodes[i], nxt=this.nodes[i+1]; const u1=cur.clone().sub(prev).normalize(), u2=nxt.clone().sub(cur).normalize(); cur.addScaledVector(u1,-perSeg*0.25).addScaledVector(u2,perSeg*0.25);} }
  mesh(){ const geo=new LineGeometry(), arr=[]; for(const p of this.nodes) arr.push(p.x,p.y,p.z); geo.setPositions(arr); const mat=new LineMaterial({color:0xfff2c2, linewidth:2, worldUnits:true}); const line=new Line2(geo,mat); line.computeLineDistances(); line.userData.update=()=>{ const a=[]; for(const p of this.nodes) a.push(p.x,p.y,p.z); geo.setPositions(a); }; return line; }
}

/* ============ UI refs ============ */
const ui={
  mode:document.getElementById('mode'), caseSel:document.getElementById('case'),
  loadBtn:document.getElementById('load'), startBtn:document.getElementById('start'),
  resetBtn:document.getElementById('reset'), exportBtn:document.getElementById('export'),
  tool_place:document.getElementById('tool_place'), tool_tension:document.getElementById('tool_tension'),
  tool_remove:document.getElementById('tool_remove'), tool_finish:document.getElementById('tool_finish'),
  stepText:document.getElementById('stepText'), fb:document.getElementById('fb'),
  biteN:document.getElementById('biteN'), depthErr:document.getElementById('depthErr'), angleErr:document.getElementById('angleErr'),
  spacing:document.getElementById('spacing'), sym:document.getElementById('sym'), gap:document.getElementById('gap'),
  time:document.getElementById('time'), overall:document.getElementById('overall'),
  tensionBox:document.getElementById('tensionBox'), tens:document.getElementById('tens'), tv:document.getElementById('tv'),
  coachFeed:document.getElementById('coachFeed'), coachBox:document.getElementById('coachBox'),
  coachTitle:document.getElementById('coachTitle'), coachText:document.getElementById('coachText'),
  coachPrev:document.getElementById('coachPrev'), coachNext:document.getElementById('coachNext'),
  ghostNext:document.getElementById('ghostNext')
};
let tool='place'; setTool('place');
ui.tool_place.onclick=()=>setTool('place'); ui.tool_tension.onclick=()=>setTool('tension');
ui.tool_remove.onclick=removeLastBite; ui.tool_finish.onclick=finalize;
document.addEventListener('keydown',e=>{ if(e.key==='z'||e.key==='Z') removeLastBite(); if(e.key==='f'||e.key==='F') finalize(); });

/* ============ Cases & framing ============ */
function loadCase(kind){ const ck=kind==='p2_wide'?'wide':kind==='p2_small'?'small':'mid'; gapDZ=(ck==='wide'?mm(8):ck==='small'?mm(4):mm(6));
  scene.remove(leftStrip,rightStrip); basePosterior=posteriorEdgeCurve(); edges=resectionPair(basePosterior,gapDZ);
  leftStrip=stripFromCurve(edges.left,0xf1f7ff,0.98,true); rightStrip=stripFromCurve(edges.right,0xe7efff,0.95,true);
  scene.add(leftStrip,rightStrip); frameView(); clearAll();
}
function frameView(){ const box=new THREE.Box3().setFromObject(leftStrip).union(new THREE.Box3().setFromObject(rightStrip)); const c=box.getCenter(new THREE.Vector3()); controls.target.copy(c); camera.position.set(c.x,c.y+60,c.z+160); }

/* ============ Picking & workflow ============ */
const ray=new THREE.Raycaster(), mouse=new THREE.Vector2();
renderer.domElement.addEventListener('pointermove',e=>{ const r=renderer.domElement.getBoundingClientRect(); mouse.x=((e.clientX-r.left)/r.width)*2-1; mouse.y=-((e.clientY-r.top)/r.height)*2+1; });
renderer.domElement.addEventListener('pointerdown', onClick);
let step=0, entryP=null, exitP=null, activeBiteIdx=-1, sessionStart=now();
const bites=[];

function onClick(){ if(BUSY || tool!=='place') return;
  ray.setFromCamera(mouse,camera);
  const hitL=ray.intersectObject(leftStrip,false)[0], hitR=ray.intersectObject(rightStrip,false)[0];
  if(step===0){ if(!hitL || hitL.object!==leftStrip){ ui.fb.textContent='Place ENTRY on LEFT edge (gold band 4â€“6 mm).'; return; }
    entryP=hitL.point.clone(); step=1; ui.stepText.textContent='Click right edge (exit)'; ui.fb.textContent='Good. Now place EXIT on RIGHT edge.'; flash(entryP,0xFFEB99);
  } else {
    if(!hitR || hitR.object!==rightStrip){ ui.fb.textContent='Place EXIT on RIGHT edge.'; return; }
    exitP=hitR.point.clone(); BUSY=true;
    animateNeedle(entryP,exitP,()=>{
      const rope=new Rope(entryP,exitP,18), line=rope.mesh(); scene.add(line);
      const dL=depthFromEdge(edges.left,entryP), dR=depthFromEdge(edges.right,exitP);
      const chord=exitP.clone().sub(entryP), angErr=angleError(dL.tangent,chord), symErr=Math.abs(dL.depth-dR.depth);
      const spacing=bites.length? entryP.distanceTo(bites.at(-1).entry):NaN;
      const b={ entry:entryP.clone(), exit:exitP.clone(), rope, line, depthL:dL.depth, depthR:dR.depth, angleErr:angErr, symmetry:symErr, spacingFromPrev:spacing, get residual(){ return residualGap(rope); }, get tension(){ return 1.0-rope.targetScale; } };
      bites.push(b); activeBiteIdx=bites.length-1; showTensionFor(b); refreshScore();
      if(ui.mode.value==='practice') coachSay(aiCopilotAdvice(b));
      if(ui.mode.value==='teach'   && TEACH_STEPS[teachIdx].gate()) { teachIdx=Math.min(teachIdx+1,TEACH_STEPS.length-1); showCoach(); }
      step=0; entryP=null; exitP=null; BUSY=false; ui.stepText.textContent='Click left edge (entry)'; ui.fb.textContent='Bite placed.'; hintNextTarget();
    });
  }
}
function flash(p,color=0xFFEB99){ const m=new THREE.Mesh(new THREE.SphereGeometry(1.4), new THREE.MeshBasicMaterial({color})); m.position.copy(p); scene.add(m); setTimeout(()=>scene.remove(m),900); }

/* Depth/angle helpers */
function nearestOn(curve,p){ let bestT=0,bestD=1e9; for(let i=0;i<=EDGE_SEGS;i++){ const t=i/EDGE_SEGS,q=curve.getPoint(t), d=q.distanceTo(p); if(d<bestD){bestD=d;bestT=t;} } const q=curve.getPoint(bestT), tangent=curve.getTangent(bestT).normalize(), lateral=new THREE.Vector3().crossVectors(tangent,new THREE.Vector3(0,1,0)).normalize(); return {pos:q,tangent,lateral}; }
function depthFromEdge(curve,p){ const pr=nearestOn(curve,p), d=p.clone().sub(pr.pos); const depth=Math.abs(d.dot(pr.lateral)); return {depth,tangent:pr.tangent,base:pr.pos,lateral:pr.lateral}; }
function angleError(edgeTangent,chordVec){ const edge=edgeTangent.clone().normalize(), chord=chordVec.clone().normalize(); const d=clamp(Math.abs(edge.dot(chord)),0,1); const ang=Math.acos(d)*180/Math.PI; return Math.abs(ang-60); }
function residualGap(rope){ const L=rope.totalLength(), want=rope.restLen*rope.targetScale, gain=L-want; return clamp((gapDZ-gain*0.4),0,gapDZ); }

/* Teach/Copilot */
const TEACH_STEPS=[
  {id:'intro',title:'Orientation',text:'This is P2 with a triangular wedge excised. Depth bands (2â€“8 mm) are painted; target is 4â€“6 mm (gold). Start with the apex bite.', gate:()=>true},
  {id:'apex', title:'Apex bite', text:'Place the apex bite: LEFT entry then RIGHT exit, both near 5 mm, angle ~60Â°, symmetric.', gate:()=> bites.length>=1 && within(bites[0],{depth:[4,6],angle:15,sym:1.0})},
  {id:'mid',  title:'Second bite', text:'Place the second bite ~5 mm away; same criteria.', gate:()=> bites.length>=2 && within(bites[1],{depth:[4,6],angle:15,sym:1.0})},
  {id:'series',title:'Complete series', text:'Complete closure with even spacing (~4â€“5 mm). Then tighten.', gate:()=> bites.length>=4 },
  {id:'tension',title:'Tension', text:'Switch to â€œTighten knotâ€ and adjust until residual gap is minimal without strangulation.', gate:()=> avgResidual()<=2.0 }
];
let teachIdx=0;
function within(b,lim){ const okD=(b.depthL>=lim.depth[0]&&b.depthL<=lim.depth[1]&&b.depthR>=lim.depth[0]&&b.depthR<=lim.depth[1]); const okA=(b.angleErr<=lim.angle); const okS=(b.symmetry<=lim.sym); return okD&&okA&&okS; }
function avgResidual(){ if(!bites.length) return Infinity; return bites.reduce((a,x)=>a+x.residual,0)/bites.length; }
function showCoach(){ if(ui.mode.value!=='teach'){ ui.coachBox.style.display='none'; return;} ui.coachBox.style.display='block'; ui.coachTitle.textContent=`Teaching â€” Step ${teachIdx+1}/${TEACH_STEPS.length}: ${TEACH_STEPS[teachIdx].title}`; ui.coachText.textContent=TEACH_STEPS[teachIdx].text; }
ui.coachPrev.onclick=()=>{ teachIdx=Math.max(0,teachIdx-1); showCoach(); };
ui.coachNext.onclick=()=>{ if(TEACH_STEPS[teachIdx].gate()) teachIdx=Math.min(TEACH_STEPS.length-1,teachIdx+1); showCoach(); };

function coachSay(msg){ ui.coachFeed.textContent=msg; }
function aiCopilotAdvice(b){ const adv=[]; if(b.angleErr>25) adv.push('Angle too parallel â€” roll wrist to drive more perpendicular (~60Â°).'); else if(b.angleErr>15) adv.push('Slightly shallow angle â€” bias needle toward perpendicular.'); if(b.depthL<4||b.depthR<4) adv.push('Depth too shallow â€” move into gold band (4â€“6 mm).'); if(b.depthL>6||b.depthR>6) adv.push('Depth too deep â€” stay within 4â€“6 mm.'); if(Math.abs(b.depthL-b.depthR)>1.2) adv.push('Asymmetric entry/exit â€” adjust exit ~1â€“2 mm to match.'); if(bites.length>1){ const s=b.entry.distanceTo(bites.at(-2).entry); if(s<3.2) adv.push('Bites too close â€” target 4â€“5 mm.'); if(s>6.0) adv.push('Bites too far â€” target 4â€“5 mm.'); } if(!adv.length) adv.push('Nice bite. Maintain this pattern.'); return adv.join('\n'); }
function hintNextTarget(){ ui.ghostNext.style.display = (ui.mode.value==='practice') ? 'block':'none'; }

/* Tension widget */
function showTensionFor(b){ ui.tensionBox.style.display='block'; const s=ui.tens, lab=ui.tv; s.value=b.rope.targetScale.toFixed(2); const upd=()=>{ const t=1-parseFloat(s.value); lab.textContent=(t<0.05?'loose': t>0.25?'tight':'ok'); lab.style.color=(t<0.05?'#9fb3c4': t>0.25?'#ffb020':'#2ed573'); }; s.oninput=()=>{ b.rope.tighten(parseFloat(s.value)); upd(); }; upd(); if(ui.mode.value==='practice'){ if(b.residual>4) coachSay('Tension under-corrected â€” tighten until edges approximate (avoid strangulation).'); }}

/* Remove/Reset/Finalize */
function removeLastBite(){ const b=bites.pop(); if(!b) return; scene.remove(b.line); refreshScore(); ui.fb.textContent='Removed last bite.'; if(!bites.length) ui.tensionBox.style.display='none'; }
function clearAll(){ while(bites.length){ const b=bites.pop(); scene.remove(b.line);} entryP=null; exitP=null; step=0; activeBiteIdx=-1; ui.tensionBox.style.display='none'; sessionStart=now(); ['biteN','depthErr','angleErr','spacing','sym','gap','overall','time'].forEach(id=>ui[id].textContent='â€”'); ui.stepText.textContent='Click left edge (entry)'; ui.fb.textContent='â€”'; needleGroup.clear(); if(ui.mode.value==='teach'){ teachIdx=0; showCoach(); } }
function finalize(){ if(!bites.length){ ui.fb.textContent='Place at least one bite before finishing.'; return; } const s=computeScores(); ui.fb.innerHTML=`<span class="${s.overall>=4?'ok':s.overall>=3?'warn':'bad'}">Finished. Overall ${s.overall.toFixed(1)}/5</span>`; if(ui.mode.value==='practice'){ if(s.overall<3.5) coachSay('Run again focusing on angle (~60Â°) and symmetric depth.'); else coachSay('Great. Try the wide wedge next.'); }}

/* Metrics / Score */
function mean(a){ return a.reduce((x,y)=>x+y,0)/a.length; }
function stdev(a){ const m=mean(a); return Math.sqrt(mean(a.map(v=>(v-m)*(v-m)))); }
function cv(a){ return mean(a)>0 ? stdev(a)/mean(a) : NaN; }
function computeScores(){ if(!bites.length) return {overall:NaN}; const targetDepth=5; const d=[],a=[],sp=[],sy=[],rg=[]; for(let i=0;i<bites.length;i++){ const b=bites[i]; d.push((Math.abs(b.depthL-targetDepth)+Math.abs(b.depthR-targetDepth))/2); a.push(b.angleErr); if(i>0) sp.push(b.entry.distanceTo(bites[i-1].entry)); sy.push(b.symmetry); rg.push(b.residual);} const dE=mean(d), aE=mean(a), spCV=sp.length?cv(sp):NaN, sE=mean(sy), rG=mean(rg); const sDepth=clamp(5-dE*0.8,1,5), sAngle=clamp(5-Math.max(0,aE-5)*0.12,1,5), sSpace=isFinite(spCV)?clamp(5-spCV*8,1,5):3, sSym=clamp(5-sE*0.6,1,5), sGap=clamp(5-rG*0.6,1,5); const overall=(sDepth*0.28 + sAngle*0.18 + sSpace*0.18 + sSym*0.18 + sGap*0.18); return {dE,aE,spCV,sE,rG,overall}; }
function refreshScore(){ const s=computeScores(); ui.biteN.textContent=bites.length+''; ui.depthErr.textContent=isFinite(s.dE)? s.dE.toFixed(1)+' mm':'â€”'; ui.angleErr.textContent=isFinite(s.aE)? s.aE.toFixed(1)+'Â°':'â€”'; ui.spacing.textContent=isFinite(s.spCV)? (s.spCV*100).toFixed(0)+'%':'â€”'; ui.sym.textContent=isFinite(s.sE)? s.sE.toFixed(1)+' mm':'â€”'; ui.gap.textContent=isFinite(s.rG)? s.rG.toFixed(1)+' mm':'â€”'; ui.overall.textContent=isFinite(s.overall)? s.overall.toFixed(1)+'/5':'â€”'; ui.time.textContent=((now()-sessionStart)/1000).toFixed(1)+' s'; }

/* Toolbar */
function setTool(t){ tool=t; ['place','tension','remove','finish'].forEach(k=>document.getElementById('tool_'+k).classList.toggle('active',k===t)); ui.stepText.textContent=(t==='place'?'Click left edge (entry)': t==='tension'?'Select last bite then adjust tension':''); }
ui.loadBtn.onclick=()=>loadCase(ui.caseSel.value);
ui.startBtn.onclick=()=>{ sessionStart=now(); if(ui.mode.value==='teach'){ ui.coachBox.style.display='block'; showCoach(); } if(ui.mode.value==='practice'){ ui.ghostNext.style.display='block'; } };
ui.resetBtn.onclick=clearAll; ui.exportBtn.onclick=exportJSON;
ui.mode.onchange=()=>{ clearAll(); if(ui.mode.value==='teach'){ ui.coachBox.style.display='block'; showCoach(); ui.ghostNext.style.display='none'; } else if(ui.mode.value==='practice'){ ui.coachBox.style.display='none'; ui.ghostNext.style.display='block'; } else { ui.coachBox.style.display='none'; ui.ghostNext.style.display='none'; } };
function exportJSON(){ const payload={ when:new Date().toISOString(), mode:ui.mode.value, case:ui.caseSel.value, bites:bites.map(b=>({ entry:b.entry, exit:b.exit, depthL:b.depthL, depthR:b.depthR, angleErr:b.angleErr, symmetry:b.symmetry, residual:b.residual, tension:b.tension })), summary:computeScores(), time_s:((now()-sessionStart)/1000).toFixed(1) }; const blob=new Blob([JSON.stringify(payload,null,2)],{type:'application/json'}); const url=URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download='mitral_suture_session.json'; a.click(); URL.revokeObjectURL(url); }

/* Render & resize */
function tick(){ requestAnimationFrame(tick); if(activeBiteIdx>=0 && bites[activeBiteIdx]){ const b=bites[activeBiteIdx]; b.rope.step(); b.line.userData.update && b.line.userData.update(); } controls.update(); renderer.render(scene,camera); }
tick();
window.addEventListener('resize',()=>{ renderer.setSize(stage.clientWidth,stage.clientHeight); camera.aspect=stage.clientWidth/stage.clientHeight; camera.updateProjectionMatrix(); });

/* Boot */
function boot(){ loadCase('p2_mid'); setStatus('Ready','ok'); ui.coachFeed.textContent='Choose a mode: Teaching guides step-by-step; Practice gives AI Copilot tips; Assess scores strictly.'; }
boot();
</script>
</body>
</html>
