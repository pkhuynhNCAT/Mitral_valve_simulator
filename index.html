<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Mitral Suture Trainer â€” P2 Triangular Resection (Teach Â· Practice Â· Assess)</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
  :root{
    --bg:#0b0f14; --ink:#eaf2f8; --mut:#9fb3c4; --ok:#2ed573; --warn:#ffb020; --bad:#ff4d4f;
    --panel:#0f151d; --line:#1f2b36; --accent:#52e2c0;
    --mono: ui-monospace, Menlo, Consolas, "Liberation Mono", monospace;
    --sans: ui-sans-serif, system-ui, Segoe UI, Roboto, Helvetica, Arial;
  }
  html,body{margin:0;height:100%;background:var(--bg);color:var(--ink);font:14px/1.45 var(--sans)}
  #app{display:grid;grid-template-rows:58px 1fr 30px;height:100%}

  header{display:flex;gap:12px;align-items:center;padding:10px 14px;background:linear-gradient(180deg,#0e1520,#0b1218);border-bottom:1px solid #182330}
  header h1{margin:0;font-size:16px;font-weight:800;letter-spacing:.2px}
  #toolbar{margin-left:auto;display:flex;gap:10px;flex-wrap:wrap;align-items:center}
  .grp{display:flex;gap:10px;align-items:center;background:#0f1823;border:1px solid #1b2733;border-radius:10px;padding:6px 8px}
  label{color:var(--mut);font-size:12px}
  select,button{background:#101825;color:#e6f0f6;border:1px solid #223243;border-radius:8px;padding:6px 10px;cursor:pointer}
  button:active{transform:translateY(1px)}

  main{display:grid;grid-template-columns:360px 1fr}
  aside{background:var(--panel);border-right:1px solid #1b2733;padding:12px;overflow:auto}
  aside h2{font-size:12px;letter-spacing:.1em;text-transform:uppercase;color:#a7bed1;margin:12px 0 8px}
  .card{background:rgba(9,14,19,.82);border:1px solid var(--line);border-radius:12px;padding:10px;margin-bottom:10px;backdrop-filter:blur(6px)}
  .kpi{display:flex;justify-content:space-between;font-family:var(--mono);font-weight:700}
  .pill{display:inline-block;border:1px solid #223243;border-radius:999px;padding:3px 8px;color:#a6c1d5;font-size:11px;margin:4px 4px 0 0}
  .toolbtn{display:flex;gap:6px;align-items:center;width:100%}
  .toolbtn.active{outline:2px solid #3c5977}
  .coach{background:#0d1621;border-left:4px solid #3b82f6;padding:10px;border-radius:8px}

  #stage{position:relative;background:radial-gradient(60% 70% at 50% 50%,#0c141b 0%,#0a1016 100%)}
  canvas{display:block;width:100%;height:100%}

  #hud{position:absolute;top:10px;left:10px;display:grid;gap:8px;pointer-events:none}
  #hud .card{pointer-events:auto;min-width:280px}
  #tensionBox{position:absolute;left:12px;bottom:12px;background:rgba(9,14,19,.88);border:1px solid #1f2b36;border-radius:8px;padding:6px 8px;color:#cfe8ff;display:none}
  #tensionBox input[type=range]{width:180px}
  #coachBox{position:absolute;right:12px;top:12px;width:min(420px,36vw);max-height:60vh;overflow:auto;background:rgba(9,14,19,.88);border:1px solid #1f2b36;border-radius:12px;padding:12px;display:none}
  #ghostNext{position:absolute;right:12px;bottom:12px;background:rgba(12,18,27,.88);border:1px dashed #335; padding:6px 10px;border-radius:10px;color:#cfe8ff;display:none}

  footer{display:flex;gap:10px;align-items:center;padding:6px 10px;border-top:1px solid #182330;color:#8dadc1}
  #status{color:#cfe8ff}
  .ok{color:var(--ok)} .warn{color:var(--warn)} .bad{color:var(--bad)} .mut{color:#9fb3c4}
</style>
</head>
<body>
<div id="app">
  <header>
    <h1>Mitral Suture Trainer â€” P2 Triangular Resection Closure</h1>
    <div id="toolbar">
      <div class="grp">
        <label>Mode</label>
        <select id="mode">
          <option value="teach">Teach (step-gated)</option>
          <option value="practice">Practice (AI Copilot)</option>
          <option value="assess">Assess (scored)</option>
        </select>
      </div>
      <div class="grp">
        <label>Case</label>
        <select id="case">
          <option value="p2_mid">P2 central wedge</option>
          <option value="p2_wide">P2 wide wedge</option>
          <option value="p2_small">P2 small wedge</option>
        </select>
        <button id="load">Load case</button>
      </div>
      <div class="grp">
        <button id="start">Start</button>
        <button id="reset">Reset</button>
        <button id="export">Export JSON</button>
      </div>
    </div>
  </header>

  <main>
    <aside>
      <h2>Tools</h2>
      <div class="card">
        <button class="toolbtn" id="tool_place">ðŸª¡ Place bite (entry â†’ exit)</button>
        <button class="toolbtn" id="tool_tension">ðŸŽ¯ Tighten knot (set tension)</button>
        <button class="toolbtn" id="tool_remove">ðŸ§¹ Remove last bite</button>
        <button class="toolbtn" id="tool_finish">âœ… Finish & score</button>
      </div>

      <h2>Targets (clinical)</h2>
      <div class="card">
        <ul class="mut" style="margin:0 0 6px 16px; padding:0">
          <li>Bite depth: <b>4â€“6 mm</b> from cut edge (both sides)</li>
          <li>Bite angle: <b>â‰ˆ60Â°Â±15Â°</b> to edge</li>
          <li>Spacing: uniform <b>~4â€“5 mm</b> along wedge</li>
          <li>Symmetry: entryâ‰ˆexit depth</li>
          <li>Tension: coaptation flush (no gap, no strangulation)</li>
        </ul>
        <div class="pill">Depth bands are painted on each edge (2â€“8 mm), with a gold 4â€“6 mm zone.</div>
      </div>

      <h2>Session metrics</h2>
      <div class="card">
        <div class="kpi"><span>Bites placed</span><span id="biteN">0</span></div>
        <div class="kpi"><span>Avg depth error</span><span id="depthErr">â€”</span></div>
        <div class="kpi"><span>Avg angle error</span><span id="angleErr">â€”</span></div>
        <div class="kpi"><span>Spacing CV</span><span id="spacing">â€”</span></div>
        <div class="kpi"><span>Symmetry error</span><span id="sym">â€”</span></div>
        <div class="kpi"><span>Residual gap</span><span id="gap">â€”</span></div>
        <div class="kpi"><span>Time</span><span id="time">â€”</span></div>
        <div class="kpi"><span>Overall</span><span id="overall">â€”</span></div>
      </div>

      <h2>Coach log</h2>
      <div class="card coach" id="coachFeed" style="white-space:pre-wrap">â€”</div>

      <h2>Shortcuts</h2>
      <div class="card">
        <div class="pill">Left click: place entry/exit</div>
        <div class="pill">Z: remove last â€¢ F: finish</div>
        <div class="pill">Drag to rotate scene; Shift+Drag pan; Wheel zoom</div>
      </div>
    </aside>

    <section id="stage">
      <canvas id="cv"></canvas>

      <div id="hud">
        <div class="card">
          <div style="font-weight:800;margin-bottom:6px">Step</div>
          <div id="stepText">Click left edge (entry)</div>
        </div>
        <div class="card">
          <div style="font-weight:800;margin-bottom:6px">Realtime feedback</div>
          <div id="fb">â€”</div>
        </div>
      </div>

      <div id="tensionBox">Tension <input id="tens" type="range" min="0.70" max="1.00" step="0.01" value="1.00"> <span id="tv">loose</span></div>

      <div id="coachBox" class="coach">
        <h3 id="coachTitle">Teaching Mode</h3>
        <div id="coachText">Place the <b>apex bite</b>: entry on LEFT, exit on RIGHT, depth ~5 mm (gold band), angle ~60Â°.</div>
        <div style="margin-top:8px"><button id="coachPrev">â—€ Back</button> <button id="coachNext">Next â–¶</button></div>
      </div>

      <div id="ghostNext">Next target shown as <span style="color:#FFEB99">gold dot</span>. Keep 4â€“6 mm depth and ~5 mm spacing.</div>
    </section>
  </main>

  <footer>
    <div>Pure Canvas-2D (no libraries). Surgeon view Â· step-gated teaching Â· AI-like guidance Â· strict scoring. For education; not a medical device.</div>
    <div id="status"></div>
  </footer>
</div>

<script>
/* ===================== utilities & canvas ===================== */
const clamp=(x,a,b)=>Math.max(a,Math.min(b,x));
const lerp =(a,b,t)=>a+(b-a)*t;
const now  =()=>performance.now();

const statusEl=document.getElementById('status');
function setStatus(m,cls=''){ statusEl.textContent=m; statusEl.className=cls; }

const cv=document.getElementById('cv'); const ctx=cv.getContext('2d');
function fitCanvas(){
  const dpr=Math.max(1, window.devicePixelRatio||1);
  const w=cv.clientWidth, h=cv.clientHeight;
  cv.width = Math.round(w*dpr); cv.height = Math.round(h*dpr);
  ctx.setTransform(dpr,0,0,dpr,0,0);
}
window.addEventListener('resize', fitCanvas);
fitCanvas();

const ui={
  mode:document.getElementById('mode'), caseSel:document.getElementById('case'),
  loadBtn:document.getElementById('load'), startBtn:document.getElementById('start'),
  resetBtn:document.getElementById('reset'), exportBtn:document.getElementById('export'),
  tool_place:document.getElementById('tool_place'), tool_tension:document.getElementById('tool_tension'),
  tool_remove:document.getElementById('tool_remove'), tool_finish:document.getElementById('tool_finish'),
  stepText:document.getElementById('stepText'), fb:document.getElementById('fb'),
  biteN:document.getElementById('biteN'), depthErr:document.getElementById('depthErr'), angleErr:document.getElementById('angleErr'),
  spacing:document.getElementById('spacing'), sym:document.getElementById('sym'), gap:document.getElementById('gap'),
  time:document.getElementById('time'), overall:document.getElementById('overall'),
  tensionBox:document.getElementById('tensionBox'), tens:document.getElementById('tens'), tv:document.getElementById('tv'),
  coachFeed:document.getElementById('coachFeed'), coachBox:document.getElementById('coachBox'),
  coachTitle:document.getElementById('coachTitle'), coachText:document.getElementById('coachText'),
  coachPrev:document.getElementById('coachPrev'), coachNext:document.getElementById('coachNext'),
  ghostNext:document.getElementById('ghostNext')
};
let tool='place'; setTool('place');
ui.tool_place.onclick =()=>setTool('place');
ui.tool_tension.onclick=()=>setTool('tension');
ui.tool_remove.onclick =removeLastBite;
ui.tool_finish.onclick =finalize;

document.addEventListener('keydown',e=>{
  if(e.key==='z'||e.key==='Z') removeLastBite();
  if(e.key==='f'||e.key==='F') finalize();
});

/* ===================== geometry (surgeon view 2D) ===================== */
function pxPerMm(){ return Math.min(cv.clientWidth, cv.clientHeight)/300*10; } // heuristic
const center =()=>({ x: cv.clientWidth*0.5, y: cv.clientHeight*0.55 });
function ellipsePosteriorPts(segments){
  const c=center(); const RX=Math.min(cv.clientWidth, cv.clientHeight)*0.24;
  const RY=Math.min(cv.clientWidth, cv.clientHeight)*0.18;
  const start=0.55*Math.PI*2, end=0.98*Math.PI*2; // posterior arc
  const pts=[];
  for(let i=0;i<=segments;i++){
    const t=i/segments, th=lerp(start,end,t);
    const x=c.x + RX*Math.cos(th);
    const y=c.y + RY*Math.sin(th) - 1.5*Math.cos(t*Math.PI); // crown
    pts.push({x,y});
  }
  return pts;
}
let EDGE_SEGS=64;
let STRIP_W_MM=8, gapMM=6;
let basePts=ellipsePosteriorPts(EDGE_SEGS);
function normals(pts){ // lateral normals (per-vertex)
  const ns=[];
  for(let i=0;i<pts.length;i++){
    const a=pts[Math.max(0,i-1)], b=pts[Math.min(pts.length-1,i+1)];
    const dx=b.x-a.x, dy=b.y-a.y; // tangent
    const L=Math.hypot(dx,dy)||1;
    ns.push({x: -dy/L, y: dx/L}); // rotate 90Â° (lateral-ish)
  }
  return ns;
}
function offsetCurve(pts, ns, d){ return pts.map((p,i)=>({x:p.x+ns[i].x*d, y:p.y+ns[i].y*d})); }

function buildEdges(){
  basePts=ellipsePosteriorPts(EDGE_SEGS);
  const ns=normals(basePts);
  const dz=gapMM*pxPerMm();
  const left  = basePts.map(p=>({...p}));
  const right = basePts.map((p,i)=>({x:p.x+ns[i].x*dz, y:p.y+ns[i].y*dz}));
  return {left,right,ns};
}
let edges=buildEdges();

/* ===================== drawing helpers ===================== */
function drawGrid(){
  const w=cv.clientWidth, h=cv.clientHeight;
  ctx.save(); ctx.strokeStyle='#14202a'; ctx.lineWidth=1;
  for(let x=0;x<w;x+=40){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,h); ctx.stroke(); }
  for(let y=0;y<h;y+=40){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(w,y); ctx.stroke(); }
  ctx.restore();
}
function pathFromPoly(poly){
  ctx.beginPath(); ctx.moveTo(poly[0].x, poly[0].y);
  for(let i=1;i<poly.length;i++) ctx.lineTo(poly[i].x, poly[i].y);
}
function stripPolygon(centerPts, ns, widthPx){
  const half=widthPx/2; const A=[], B=[];
  for(let i=0;i<centerPts.length;i++){
    const p=centerPts[i]; const n=ns[i];
    A.push({x:p.x+n.x*half, y:p.y+n.y*half});
    B.push({x:p.x-n.x*half, y:p.y-n.y*half});
  }
  return {upper:A, lower:B};
}
function fillStrip(centerPts, ns, color, alpha=0.95){
  const {upper,lower}=stripPolygon(centerPts, ns, STRIP_W_MM*pxPerMm());
  ctx.save(); ctx.globalAlpha=alpha; ctx.fillStyle=color; ctx.beginPath();
  ctx.moveTo(upper[0].x,upper[0].y);
  for(let i=1;i<upper.length;i++) ctx.lineTo(upper[i].x,upper[i].y);
  for(let i=lower.length-1;i>=0;i--) ctx.lineTo(lower[i].x,lower[i].y);
  ctx.closePath(); ctx.fill(); ctx.restore();
}
function fillTargetBand(edgePts, ns, insideSign){ // paints 4â€“6 mm band from edge centerline
  const mm2px=pxPerMm(), d1=4*mm2px*insideSign, d2=6*mm2px*insideSign;
  const inner=edgePts.map((p,i)=>({x:p.x+ns[i].x*d1, y:p.y+ns[i].y*d1}));
  const outer=edgePts.map((p,i)=>({x:p.x+ns[i].x*d2, y:p.y+ns[i].y*d2}));
  ctx.save(); ctx.fillStyle='rgba(255,235,153,0.35)';
  ctx.beginPath(); ctx.moveTo(inner[0].x, inner[0].y); for(let i=1;i<inner.length;i++) ctx.lineTo(inner[i].x,inner[i].y);
  for(let i=outer.length-1;i>=0;i--) ctx.lineTo(outer[i].x, outer[i].y);
  ctx.closePath(); ctx.fill(); ctx.restore();
}
function drawAnnulus(){
  const c=center(), RX=Math.min(cv.clientWidth, cv.clientHeight)*0.24, RY=Math.min(cv.clientWidth, cv.clientHeight)*0.18;
  ctx.save(); ctx.strokeStyle='#8fa6c2'; ctx.lineWidth=3;
  ctx.beginPath(); for(let a=0;a<=Math.PI*2+0.001;a+=0.02){ const x=c.x+RX*Math.cos(a), y=c.y+RY*Math.sin(a)*0.95; if(a===0) ctx.moveTo(x,y); else ctx.lineTo(x,y); }
  ctx.stroke(); ctx.restore();
}
function drawPapillary(){
  const al={x:center().x+pxPerMm()*15*0.9, y:center().y+pxPerMm()*27}, pm={x:center().x-pxPerMm()*16*0.9, y:center().y+pxPerMm()*30};
  ctx.save(); ctx.fillStyle='#3e566e';
  ctx.beginPath(); ctx.arc(al.x,al.y,6,0,Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.arc(pm.x,pm.y,6,0,Math.PI*2); ctx.fill();
  ctx.restore();
}
function drawLabel(text, pos){
  ctx.save(); ctx.fillStyle='#cfe8ff'; ctx.font='700 13px Segoe UI'; ctx.textAlign='center'; ctx.fillText(text, pos.x, pos.y-10); ctx.restore();
}

/* ===================== measurement helpers ===================== */
function nearestOnEdge(edgePts, p){
  // sample along polyline, find nearest point and local tangent & lateral
  let best={x:edgePts[0].x,y:edgePts[0].y}, bestD=1e9, bestIdx=0;
  for(let i=0;i<edgePts.length;i++){
    const q=edgePts[i]; const d=Math.hypot(p.x-q.x,p.y-q.y);
    if(d<bestD){ best=q; bestD=d; bestIdx=i; }
  }
  const i1=Math.max(0,bestIdx-1), i2=Math.min(edgePts.length-1,bestIdx+1);
  const tx=edgePts[i2].x-edgePts[i1].x, ty=edgePts[i2].y-edgePts[i1].y; // tangent
  const tL=Math.hypot(tx,ty)||1; const tang={x:tx/tL, y:ty/tL};
  const lat={x:-tang.y, y:tang.x}; // lateral normal
  return {pos:best, tangent:tang, lateral:lat};
}
function depthFromEdge(edgePts, p, insideSign){
  const pr=nearestOnEdge(edgePts, p);
  const dx=p.x-pr.pos.x, dy=p.y-pr.pos.y;
  const signed = dx*pr.lateral.x + dy*pr.lateral.y;
  const mmDepth = (signed*insideSign)/pxPerMm();
  return { depth: Math.abs(mmDepth), base: pr.pos, tangent: pr.tangent, lateral: pr.lateral };
}
function angleErrorDeg(edgeTangent, chord){
  const t=edgeTangent, L=Math.hypot(chord.x,chord.y)||1;
  const ux=chord.x/L, uy=chord.y/L;
  const d=Math.abs(t.x*ux + t.y*uy); // |cosÎ¸|
  const ang=Math.acos(clamp(d,0,1))*180/Math.PI; // 0 parallel, 90 perp
  return Math.abs(ang-60);
}

/* ===================== needle & rope (2D) ===================== */
let BUSY=false, anim=null;
function animateNeedle(entry, exit, cb){
  BUSY=true; let t=0; const span=0.8*Math.PI; const mid={x:(entry.x+exit.x)/2, y:(entry.y+exit.y)/2};
  const chord={x:exit.x-entry.x, y:exit.y-entry.y}, L=Math.hypot(chord.x,chord.y)||1, nx=-chord.y/L, ny=chord.x/L;
  const R=Math.max(6, L/1.8);
  function tick(){
    if(!BUSY) return;
    drawAll(); // redraw base
    // draw path arc up to angle
    ctx.save(); ctx.strokeStyle='#9ab5c9'; ctx.lineWidth=4; ctx.lineCap='round';
    ctx.beginPath();
    for(let a=-span/2;a<=(-span/2+span*t); a+=0.02){
      const x=mid.x + (chord.x/2)*Math.cos(a) + nx*R*Math.sin(a);
      const y=mid.y + (chord.y/2)*Math.cos(a) + ny*R*Math.sin(a);
      if(a===-span/2) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    ctx.stroke(); ctx.restore();
    t+=0.04;
    if(t<1){ anim=requestAnimationFrame(tick); } else { BUSY=false; cb&&cb(); }
  }
  tick();
}

class Rope {
  constructor(a,b,segments=18){
    this.nodes=[];
    for(let i=0;i<=segments;i++){
      this.nodes.push({ x: lerp(a.x,b.x,i/segments), y: lerp(a.y,b.y,i/segments) });
    }
    this.restLen = this.length();
    this.targetScale = 1.0;
  }
  length(){ let L=0; for(let i=1;i<this.nodes.length;i++){ const p=this.nodes[i], q=this.nodes[i-1]; L+=Math.hypot(p.x-q.x,p.y-q.y);} return L; }
  tighten(s){ this.targetScale=clamp(s,0.7,1.0); }
  step(){
    const want=this.restLen*this.targetScale, have=this.length(), excess=have-want;
    if(Math.abs(excess)<0.01) return;
    const per=excess/(this.nodes.length-1);
    for(let i=1;i<this.nodes.length-1;i++){
      const p=this.nodes[i], q=this.nodes[i-1], r=this.nodes[i+1];
      const u1={x:p.x-q.x,y:p.y-q.y}; let l1=Math.hypot(u1.x,u1.y)||1; u1.x/=l1; u1.y/=l1;
      const u2={x:r.x-p.x,y:r.y-p.y}; let l2=Math.hypot(u2.x,u2.y)||1; u2.x/=l2; u2.y/=l2;
      p.x += -u1.x*per*0.25 +  u2.x*per*0.25;
      p.y += -u1.y*per*0.25 +  u2.y*per*0.25;
    }
  }
  draw(){
    ctx.save(); ctx.strokeStyle='#fff2c2'; ctx.lineWidth=2;
    ctx.beginPath(); ctx.moveTo(this.nodes[0].x, this.nodes[0].y);
    for(let i=1;i<this.nodes.length;i++) ctx.lineTo(this.nodes[i].x, this.nodes[i].y);
    ctx.stroke(); ctx.restore();
  }
}

/* ===================== task state ===================== */
let sessionStart=now();
let step=0, entryP=null, exitP=null, activeIdx=-1;
const bites=[]; // {entry,exit, rope, depthL,depthR, angleErr, symmetry, spacingFromPrev, residual, tension}
function residualGap(rope){ const L=rope.length(), want=rope.restLen*rope.targetScale, gain=L-want; return clamp((gapMM*pxPerMm() - gain*0.4)/pxPerMm(), 0, gapMM); }

/* ===================== Teach / Practice scripts ===================== */
const TEACH_STEPS=[
  { id:'intro', title:'Orientation', text:'This is P2 with a triangular wedge excised. Depth bands (2â€“8 mm) are painted; target is 4â€“6 mm (gold). Start with the apex bite.', gate:()=>true },
  { id:'apex',  title:'Apex bite', text:'Place the apex bite: LEFT entry â†’ RIGHT exit, both near 5 mm and angle ~60Â°, symmetric.', gate:()=> bites.length>=1 && within(bites[0],{depth:[4,6],angle:15,sym:1.0}) },
  { id:'mid',   title:'Second bite', text:'Place the second bite ~5 mm away with same criteria.', gate:()=> bites.length>=2 && within(bites[1],{depth:[4,6],angle:15,sym:1.0}) },
  { id:'series',title:'Complete series', text:'Complete closure with even spacing (~4â€“5 mm). Then tighten.', gate:()=> bites.length>=4 },
  { id:'tension',title:'Tension', text:'Switch to â€œTighten knotâ€ and adjust until residual gap is minimal without strangulation.', gate:()=> avgResidual()<=2.0 }
];
let teachIdx=0;
function within(b,lim){
  const okD=(b.depthL>=lim.depth[0]&&b.depthL<=lim.depth[1]&&b.depthR>=lim.depth[0]&&b.depthR<=lim.depth[1]);
  const okA=(b.angleErr<=lim.angle);
  const okS=(Math.abs(b.depthL-b.depthR)<=lim.sym);
  return okD && okA && okS;
}
function avgResidual(){ if(!bites.length) return 999; return bites.reduce((s,b)=>s+b.residual,0)/bites.length; }
function showCoach(){
  if(ui.mode.value!=='teach'){ ui.coachBox.style.display='none'; return; }
  ui.coachBox.style.display='block';
  ui.coachTitle.textContent = `Teaching â€” Step ${teachIdx+1}/${TEACH_STEPS.length}: ${TEACH_STEPS[teachIdx].title}`;
  ui.coachText.textContent  = TEACH_STEPS[teachIdx].text;
}
ui.coachPrev.onclick=()=>{ teachIdx=Math.max(0,teachIdx-1); showCoach(); };
ui.coachNext.onclick=()=>{ if(TEACH_STEPS[teachIdx].gate()) teachIdx=Math.min(teachIdx+1,TEACH_STEPS.length-1); showCoach(); };

function coachSay(t){ ui.coachFeed.textContent=t; }
function copilotAdvice(b){
  const adv=[];
  if(b.angleErr>25) adv.push('Angle too parallel â€” roll wrist toward perpendicular (~60Â°).');
  else if(b.angleErr>15) adv.push('Slightly shallow angle â€” bias more perpendicular.');
  if(b.depthL<4 || b.depthR<4) adv.push('Depth too shallow â€” move bites into gold band (4â€“6 mm).');
  if(b.depthL>6 || b.depthR>6) adv.push('Depth too deep â€” stay within 4â€“6 mm.');
  if(Math.abs(b.depthL-b.depthR)>1.2) adv.push('Asymmetric entry/exit â€” adjust exit ~1â€“2 mm to match.');
  if(bites.length>1){
    const s=distance(b.entry, bites[bites.length-2].entry);
    if(s<3.2) adv.push('Bites too close â€” target 4â€“5 mm spacing.');
    if(s>6.0) adv.push('Bites too far â€” target 4â€“5 mm spacing.');
  }
  if(!adv.length) adv.push('Nice bite. Maintain this pattern along the wedge.');
  return adv.join('\n');
}

/* ===================== interaction & picking ===================== */
function distance(a,b){ return Math.hypot(a.x-b.x,a.y-b.y); }
function pickPointOnStrip(edgePts, ns, insideSign, mx,my){
  // Accept click if within strip width band measured from edge centerline
  const pr=nearestOnEdge(edgePts, {x:mx,y:my});
  const dx=mx-pr.pos.x, dy=my-pr.pos.y;
  const signed = dx*pr.lateral.x + dy*pr.lateral.y;
  const half=STRIP_W_MM*pxPerMm()/2;
  if(Math.abs(signed) > half+8) return null; // not within strip
  // snap to point at depth limited within strip
  const snapped={ x: pr.pos.x + pr.lateral.x * clamp(signed, -half, half),
                  y: pr.pos.y + pr.lateral.y * clamp(signed, -half, half) };
  return snapped;
}
let dragging=false, lastMouse={x:0,y:0}, cam={tx:0,ty:0, scale:1};
cv.addEventListener('mousedown', e=>{
  const rect=cv.getBoundingClientRect();
  const x=(e.clientX-rect.left), y=(e.clientY-rect.top);
  if(e.shiftKey){ dragging=true; lastMouse={x,y}; return; }
  if(BUSY || tool!=='place') return;
  handleClick(x,y);
});
cv.addEventListener('mousemove', e=>{
  if(!dragging) return;
  const r=cv.getBoundingClientRect();
  const x=(e.clientX-r.left), y=(e.clientY-r.top);
  cam.tx += (x-lastMouse.x); cam.ty += (y-lastMouse.y);
  lastMouse={x,y};
  drawAll();
});
cv.addEventListener('mouseup', ()=>dragging=false);
cv.addEventListener('wheel', e=>{ const s=Math.exp(-e.deltaY*0.001); cam.scale*=s; drawAll(); e.preventDefault(); }, {passive:false});

function toWorld(p){ // simple pan/zoom transform
  return { x:(p.x - cv.clientWidth/2 - cam.tx)/cam.scale + cv.clientWidth/2,
           y:(p.y - cv.clientHeight/2 - cam.ty)/cam.scale + cv.clientHeight/2 };
}
function fromWorld(p){
  return { x:(p.x - cv.clientWidth/2)*cam.scale + cv.clientWidth/2 + cam.tx,
           y:(p.y - cv.clientHeight/2)*cam.scale + cv.clientHeight/2 + cam.ty };
}
function handleClick(sx,sy){
  const {x,y}=toWorld({x:sx,y:sy});
  // entry must be on LEFT strip; exit on RIGHT strip
  const ns=normals(basePts);
  if(step===0){
    const p=pickPointOnStrip(edges.left, ns, +1, x,y); // +1 means "inside" direction
    if(!p){ ui.fb.textContent='Place ENTRY on LEFT edge (gold band 4â€“6 mm).'; return; }
    entryP=p; step=1; ui.stepText.textContent='Click right edge (exit)'; ui.fb.textContent='Good. Now place EXIT on RIGHT edge.'; drawAll(true, entryP);
  } else {
    const p=pickPointOnStrip(edges.right, ns, -1, x,y); // -1 inside for right edge
    if(!p){ ui.fb.textContent='Place EXIT on RIGHT edge.'; return; }
    exitP=p;
    BUSY=true;
    animateNeedle(entryP, exitP, ()=>{
      const rope=new Rope(entryP, exitP, 18);
      // measure
      const dL=depthFromEdge(edges.left,  entryP, +1);
      const dR=depthFromEdge(edges.right, exitP, -1);
      const chord={x:exitP.x-entryP.x, y:exitP.y-entryP.y};
      const angErr=angleErrorDeg(dL.tangent, chord);
      const symErr=Math.abs(dL.depth - dR.depth);
      const spacing=bites.length? distance(entryP, bites[bites.length-1].entry):NaN;

      const b={
        entry:entryP, exit:exitP, rope,
        depthL:dL.depth, depthR:dR.depth, angleErr:angErr, symmetry:symErr,
        spacingFromPrev: spacing,
        get residual(){ return residualGap(rope); },
        get tension(){ return 1.0 - rope.targetScale; }
      };
      bites.push(b); activeIdx=bites.length-1;
      showTensionFor(b);
      if(ui.mode.value==='practice') coachSay(copilotAdvice(b));
      if(ui.mode.value==='teach'){ if(TEACH_STEPS[teachIdx].gate()) teachIdx=Math.min(teachIdx+1, TEACH_STEPS.length-1); showCoach(); }
      step=0; entryP=null; exitP=null; BUSY=false; ui.stepText.textContent='Click left edge (entry)'; ui.fb.textContent='Bite placed.';
      drawAll();
      refreshScore();
      hintNextTarget();
    });
  }
}

/* ===================== tension UI ===================== */
function showTensionFor(b){
  ui.tensionBox.style.display='block';
  ui.tens.value=b.rope.targetScale.toFixed(2);
  function updateLabel(){
    const t=1-parseFloat(ui.tens.value);
    ui.tv.textContent=(t<0.05?'loose': t>0.25?'tight':'ok');
    ui.tv.style.color=(t<0.05?'#9fb3c4': t>0.25?'#ffb020':'#2ed573');
  }
  ui.tens.oninput=()=>{ b.rope.tighten(parseFloat(ui.tens.value)); updateLabel(); drawAll(); };
  updateLabel();
}

/* ===================== scoring & export ===================== */
function mean(a){ return a.reduce((s,x)=>s+x,0)/a.length; }
function stdev(a){ const m=mean(a); return Math.sqrt(mean(a.map(x=>(x-m)*(x-m)))); }
function cv(a){ return mean(a)>0? stdev(a)/mean(a): NaN; }
function computeScores(){
  if(!bites.length) return {overall:NaN};
  const target=5;
  const depthErrs=[], angErrs=[], spacings=[], symErrs=[], res=[];
  bites.forEach((b,i)=>{ depthErrs.push((Math.abs(b.depthL-target)+Math.abs(b.depthR-target))/2); angErrs.push(b.angleErr); if(i>0) spacings.push(distance(b.entry,bites[i-1].entry)); symErrs.push(b.symmetry); res.push(b.residual); });
  const dE=mean(depthErrs), aE=mean(angErrs), spCV=spacings.length?cv(spacings):NaN, sE=mean(symErrs), rG=mean(res);
  const sDepth=clamp(5-dE*0.8,1,5), sAngle=clamp(5-Math.max(0,aE-5)*0.12,1,5), sSpace=isFinite(spCV)?clamp(5-spCV*8,1,5):3, sSym=clamp(5-sE*0.6,1,5), sGap=clamp(5-rG*0.6,1,5);
  const overall=(sDepth*0.28 + sAngle*0.18 + sSpace*0.18 + sSym*0.18 + sGap*0.18);
  return {dE,aE,spCV,sE,rG,overall};
}
function refreshScore(){
  const s=computeScores();
  ui.biteN.textContent=bites.length+'';
  ui.depthErr.textContent=isFinite(s.dE)? s.dE.toFixed(1)+' mm':'â€”';
  ui.angleErr.textContent=isFinite(s.aE)? s.aE.toFixed(1)+'Â°':'â€”';
  ui.spacing.textContent=isFinite(s.spCV)? (s.spCV*100).toFixed(0)+'%':'â€”';
  ui.sym.textContent=isFinite(s.sE)? s.sE.toFixed(1)+' mm':'â€”';
  ui.gap.textContent=isFinite(s.rG)? s.rG.toFixed(1)+' mm':'â€”';
  ui.overall.textContent=isFinite(s.overall)? s.overall.toFixed(1)+'/5':'â€”';
  ui.time.textContent=((now()-sessionStart)/1000).toFixed(1)+' s';
}
function exportJSON(){
  const payload={
    when:new Date().toISOString(),
    mode:ui.mode.value, case:ui.caseSel.value,
    bites:bites.map(b=>({ entry:b.entry, exit:b.exit, depthL:b.depthL, depthR:b.depthR, angleErr:b.angleErr, symmetry:b.symmetry, residual:b.residual, tension:b.tension })),
    summary:computeScores(), time_s:((now()-sessionStart)/1000).toFixed(1)
  };
  const blob=new Blob([JSON.stringify(payload,null,2)],{type:'application/json'});
  const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download='mitral_suture_session.json'; a.click(); URL.revokeObjectURL(a.href);
}

/* ===================== remove / reset / finalize ===================== */
function removeLastBite(){ const b=bites.pop(); if(!b) return; drawAll(); refreshScore(); ui.fb.textContent='Removed last bite.'; if(!bites.length) ui.tensionBox.style.display='none'; }
function clearAll(){
  bites.length=0; entryP=null; exitP=null; step=0; activeIdx=-1; sessionStart=now();
  ['biteN','depthErr','angleErr','spacing','sym','gap','overall','time'].forEach(id=>ui[id].textContent='â€”');
  ui.tensionBox.style.display='none'; ui.stepText.textContent='Click left edge (entry)'; ui.fb.textContent='â€”'; drawAll();
  if(ui.mode.value==='teach'){ teachIdx=0; showCoach(); }
}
function finalize(){
  if(!bites.length){ ui.fb.textContent='Place at least one bite before finishing.'; return; }
  const s=computeScores();
  ui.fb.innerHTML=`<span class="${s.overall>=4?'ok':s.overall>=3?'warn':'bad'}">Finished. Overall ${s.overall.toFixed(1)}/5</span>`;
  if(ui.mode.value==='practice'){
    if(s.overall<3.5) coachSay('Run again focusing on angle (~60Â°) and symmetric depth.'); else coachSay('Great. Try the wide wedge next.');
  }
}

/* ===================== toolbar ===================== */
function setTool(t){ tool=t; ['place','tension','remove','finish'].forEach(k=>document.getElementById('tool_'+k).classList.toggle('active',k===t)); ui.stepText.textContent=(t==='place'?'Click left edge (entry)': t==='tension'?'Select last bite then adjust tension':''); }
ui.loadBtn.onclick=()=>{ // rebuild edges for case
  const v=ui.caseSel.value; gapMM=(v==='p2_wide'?8: v==='p2_small'?4:6); edges=buildEdges(); clearAll();
};
ui.startBtn.onclick=()=>{ sessionStart=now(); if(ui.mode.value==='teach'){ ui.coachBox.style.display='block'; showCoach(); } if(ui.mode.value==='practice'){ ui.ghostNext.style.display='block'; } };
ui.resetBtn.onclick=clearAll;
ui.exportBtn.onclick=exportJSON;
ui.mode.onchange=()=>{ clearAll(); if(ui.mode.value==='teach'){ ui.coachBox.style.display='block'; showCoach(); ui.ghostNext.style.display='none'; } else if(ui.mode.value==='practice'){ ui.coachBox.style.display='none'; ui.ghostNext.style.display='block'; } else { ui.coachBox.style.display='none'; ui.ghostNext.style.display='none'; } };

/* ===================== main draw ===================== */
function drawAll(showEntry=false, entryPt=null){
  // apply camera transform
  ctx.save();
  ctx.translate(cv.clientWidth/2 + cam.tx, cv.clientHeight/2 + cam.ty);
  ctx.scale(cam.scale, cam.scale);
  ctx.translate(-cv.clientWidth/2, -cv.clientHeight/2);

  ctx.clearRect(0,0,cv.clientWidth,cv.clientHeight);
  // backdrop grid
  ctx.save(); ctx.globalAlpha=0.35; drawGrid(); ctx.restore();

  // annulus & papillary
  drawAnnulus(); drawPapillary();

  // posterior strips
  const ns=normals(basePts);
  fillStrip(edges.right, ns, 'rgba(231,239,255,0.95)');
  fillStrip(edges.left , ns, 'rgba(241,247,255,0.98)');
  fillTargetBand(edges.left , ns, +1);
  fillTargetBand(edges.right, ns, -1);

  // labels
  drawLabel('P2 left edge', edges.left[Math.floor(edges.left.length*0.6)]);
  drawLabel('P2 right edge', edges.right[Math.floor(edges.right.length*0.6)]);

  // suture ropes
  bites.forEach(b=>{ b.rope.step(); b.rope.draw(); });

  // ghost next hint
  if(ui.mode.value==='practice' && bites.length){
    const last=bites[bites.length-1].entry;
    ctx.save(); ctx.fillStyle='#FFEB99'; ctx.beginPath(); ctx.arc(last.x+pxPerMm()*5, last.y, 4, 0, Math.PI*2); ctx.fill(); ctx.restore();
  }

  // highlight entry during step
  if(showEntry && entryPt){
    ctx.save(); ctx.fillStyle='#FFEB99'; ctx.beginPath(); ctx.arc(entryPt.x, entryPt.y, 3.5, 0, Math.PI*2); ctx.fill(); ctx.restore();
  }

  ctx.restore();
}

/* ===================== boot ===================== */
function boot(){
  setStatus('Ready','ok');
  edges=buildEdges();
  drawAll();
  ui.coachFeed.textContent='Choose a mode: Teaching guides step by step; Practice gives AI-style coaching; Assess scores strictly.';
}
boot();
</script>
</body>
</html>
